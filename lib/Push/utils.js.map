{"version":3,"sources":["../../src/Push/utils.js"],"names":["isPushIncrementing","getLocalesFromPush","transformPushBodyForLocale","stripLocalesFromBody","bodiesPerLocales","groupByLocaleIdentifier","validatePushType","applyDeviceTokenExists","body","data","badge","toLowerCase","localizableKeys","Set","Object","keys","reduce","memo","key","forEach","localizableKey","indexOf","push","slice","length","locale","localeValue","locales","result","default","installations","map","installation","added","localeIdentifier","where","validPushTypes","deviceTypeField","deviceType","deviceTypes","Array","isArray","concat","i","Parse","Error","PUSH_MISCONFIGURED","hasOwnProperty"],"mappings":";;;;;QAGgBA,kB,GAAAA,kB;QASAC,kB,GAAAA,kB;QAeAC,0B,GAAAA,0B;QAeAC,oB,GAAAA,oB;QAYAC,gB,GAAAA,gB;QAWAC,uB,GAAAA,uB;QAyBAC,gB,GAAAA,gB;QAiBAC,sB,GAAAA,sB;;AA3GhB;;;;AACA;;;;;;AAEO,SAASP,kBAAT,CAA4BQ,IAA5B,EAAkC;AACvC,SAAOA,KAAKC,IAAL,IACAD,KAAKC,IAAL,CAAUC,KADV,IAEA,OAAOF,KAAKC,IAAL,CAAUC,KAAjB,IAA0B,QAF1B,IAGAF,KAAKC,IAAL,CAAUC,KAAV,CAAgBC,WAAhB,MAAiC,WAHxC;AAID;;AAED,MAAMC,kBAAkB,CAAC,OAAD,EAAU,OAAV,CAAxB;;AAEO,SAASX,kBAAT,CAA4BO,IAA5B,EAAkC;AACvC,QAAMC,OAAOD,KAAKC,IAAlB;AACA,MAAI,CAACA,IAAL,EAAW;AACT,WAAO,EAAP;AACD;AACD,SAAO,CAAC,GAAG,IAAII,GAAJ,CAAQC,OAAOC,IAAP,CAAYN,IAAZ,EAAkBO,MAAlB,CAAyB,CAACC,IAAD,EAAOC,GAAP,KAAe;AACzDN,oBAAgBO,OAAhB,CAAyBC,cAAD,IAAoB;AAC1C,UAAIF,IAAIG,OAAJ,CAAa,GAAED,cAAe,GAA9B,KAAqC,CAAzC,EAA4C;AAC1CH,aAAKK,IAAL,CAAUJ,IAAIK,KAAJ,CAAUH,eAAeI,MAAf,GAAwB,CAAlC,CAAV;AACD;AACF,KAJD;AAKA,WAAOP,IAAP;AACD,GAPkB,EAOhB,EAPgB,CAAR,CAAJ,CAAP;AAQD;;AAEM,SAASf,0BAAT,CAAoCM,IAApC,EAA0CiB,MAA1C,EAAkD;AACvD,QAAMhB,OAAOD,KAAKC,IAAlB;AACA,MAAI,CAACA,IAAL,EAAW;AACT,WAAOD,IAAP;AACD;AACDA,SAAO,wBAASA,IAAT,CAAP;AACAI,kBAAgBO,OAAhB,CAAyBD,GAAD,IAAS;AAC/B,UAAMQ,cAAclB,KAAKC,IAAL,CAAW,GAAES,GAAI,IAAGO,MAAO,EAA3B,CAApB;AACA,QAAIC,WAAJ,EAAiB;AACflB,WAAKC,IAAL,CAAUS,GAAV,IAAiBQ,WAAjB;AACD;AACF,GALD;AAMA,SAAOvB,qBAAqBK,IAArB,CAAP;AACD;;AAEM,SAASL,oBAAT,CAA8BK,IAA9B,EAAoC;AACzC,MAAI,CAACA,KAAKC,IAAV,EAAgB;AAAE,WAAOD,IAAP;AAAc;AAChCM,SAAOC,IAAP,CAAYP,KAAKC,IAAjB,EAAuBU,OAAvB,CAAgCD,GAAD,IAAS;AACtCN,oBAAgBO,OAAhB,CAAyBC,cAAD,IAAoB;AAC1C,UAAIF,IAAIG,OAAJ,CAAa,GAAED,cAAe,GAA9B,KAAqC,CAAzC,EAA4C;AAC1C,eAAOZ,KAAKC,IAAL,CAAUS,GAAV,CAAP;AACD;AACF,KAJD;AAKD,GAND;AAOA,SAAOV,IAAP;AACD;;AAEM,SAASJ,gBAAT,CAA0BI,IAA1B,EAAgCmB,UAAU,EAA1C,EAA8C;AACnD;AACA,QAAMC,SAASD,QAAQX,MAAR,CAAe,CAACC,IAAD,EAAOQ,MAAP,KAAkB;AAC9CR,SAAKQ,MAAL,IAAevB,2BAA2BM,IAA3B,EAAiCiB,MAAjC,CAAf;AACA,WAAOR,IAAP;AACD,GAHc,EAGZ,EAHY,CAAf;AAIA;AACAW,SAAOC,OAAP,GAAiB1B,qBAAqBK,IAArB,CAAjB;AACA,SAAOoB,MAAP;AACD;;AAEM,SAASvB,uBAAT,CAAiCyB,aAAjC,EAAgDH,UAAU,EAA1D,EAA8D;AACnE,SAAOG,cAAcd,MAAd,CAAqB,CAACe,GAAD,EAAMC,YAAN,KAAuB;AACjD,QAAIC,QAAQ,KAAZ;AACAN,YAAQR,OAAR,CAAiBM,MAAD,IAAY;AAC1B,UAAIQ,KAAJ,EAAW;AACT;AACD;AACD,UAAID,aAAaE,gBAAb,IAAiCF,aAAaE,gBAAb,CAA8Bb,OAA9B,CAAsCI,MAAtC,MAAkD,CAAvF,EAA0F;AACxFQ,gBAAQ,IAAR;AACAF,YAAIN,MAAJ,IAAcM,IAAIN,MAAJ,KAAe,EAA7B;AACAM,YAAIN,MAAJ,EAAYH,IAAZ,CAAiBU,YAAjB;AACD;AACF,KATD;AAUA,QAAI,CAACC,KAAL,EAAY;AACVF,UAAIF,OAAJ,CAAYP,IAAZ,CAAiBU,YAAjB;AACD;AACD,WAAOD,GAAP;AACD,GAhBM,EAgBJ,EAACF,SAAS,EAAV,EAhBI,CAAP;AAiBD;;AAED;;;;;AAKO,SAASvB,gBAAT,CAA0B6B,QAAQ,EAAlC,EAAsCC,iBAAiB,EAAvD,EAA2D;AAChE,MAAIC,kBAAkBF,MAAMG,UAAN,IAAoB,EAA1C;AACA,MAAIC,cAAc,EAAlB;AACA,MAAI,OAAOF,eAAP,KAA2B,QAA/B,EAAyC;AACvCE,gBAAYjB,IAAZ,CAAiBe,eAAjB;AACD,GAFD,MAEO,IAAIG,MAAMC,OAAN,CAAcJ,gBAAgB,KAAhB,CAAd,CAAJ,EAA2C;AAChDE,gBAAYG,MAAZ,CAAmBL,gBAAgB,KAAhB,CAAnB;AACD;AACD,OAAK,IAAIM,IAAI,CAAb,EAAgBA,IAAIJ,YAAYf,MAAhC,EAAwCmB,GAAxC,EAA6C;AAC3C,QAAIL,aAAaC,YAAYI,CAAZ,CAAjB;AACA,QAAIP,eAAef,OAAf,CAAuBiB,UAAvB,IAAqC,CAAzC,EAA4C;AAC1C,YAAM,IAAIM,eAAMC,KAAV,CAAgBD,eAAMC,KAAN,CAAYC,kBAA5B,EACJR,aAAa,8BADT,CAAN;AAED;AACF;AACF;;AAEM,SAAS/B,sBAAT,CAAgC4B,KAAhC,EAAuC;AAC5CA,UAAQ,wBAASA,KAAT,CAAR;AACA,MAAI,CAACA,MAAMY,cAAN,CAAqB,aAArB,CAAL,EAA0C;AACxCZ,UAAM,aAAN,IAAuB,EAAC,WAAW,IAAZ,EAAvB;AACD;AACD,SAAOA,KAAP;AACD","file":"utils.js","sourcesContent":["import Parse    from 'parse/node';\nimport deepcopy from 'deepcopy';\n\nexport function isPushIncrementing(body) {\n  return body.data &&\n         body.data.badge &&\n         typeof body.data.badge == 'string' &&\n         body.data.badge.toLowerCase() == \"increment\"\n}\n\nconst localizableKeys = ['alert', 'title'];\n\nexport function getLocalesFromPush(body) {\n  const data = body.data;\n  if (!data) {\n    return [];\n  }\n  return [...new Set(Object.keys(data).reduce((memo, key) => {\n    localizableKeys.forEach((localizableKey) => {\n      if (key.indexOf(`${localizableKey}-`) == 0) {\n        memo.push(key.slice(localizableKey.length + 1));\n      }\n    });\n    return memo;\n  }, []))];\n}\n\nexport function transformPushBodyForLocale(body, locale) {\n  const data = body.data;\n  if (!data) {\n    return body;\n  }\n  body = deepcopy(body);\n  localizableKeys.forEach((key) => {\n    const localeValue = body.data[`${key}-${locale}`];\n    if (localeValue) {\n      body.data[key] = localeValue;\n    }\n  });\n  return stripLocalesFromBody(body);\n}\n\nexport function stripLocalesFromBody(body) {\n  if (!body.data) { return body; }\n  Object.keys(body.data).forEach((key) => {\n    localizableKeys.forEach((localizableKey) => {\n      if (key.indexOf(`${localizableKey}-`) == 0) {\n        delete body.data[key];\n      }\n    });\n  });\n  return body;\n}\n\nexport function bodiesPerLocales(body, locales = []) {\n  // Get all tranformed bodies for each locale\n  const result = locales.reduce((memo, locale) => {\n    memo[locale] = transformPushBodyForLocale(body, locale);\n    return memo;\n  }, {});\n  // Set the default locale, with the stripped body\n  result.default = stripLocalesFromBody(body);\n  return result;\n}\n\nexport function groupByLocaleIdentifier(installations, locales = []) {\n  return installations.reduce((map, installation) => {\n    let added = false;\n    locales.forEach((locale) => {\n      if (added) {\n        return;\n      }\n      if (installation.localeIdentifier && installation.localeIdentifier.indexOf(locale) === 0) {\n        added = true;\n        map[locale] = map[locale] || [];\n        map[locale].push(installation);\n      }\n    });\n    if (!added) {\n      map.default.push(installation);\n    }\n    return map;\n  }, {default: []});\n}\n\n/**\n * Check whether the deviceType parameter in qury condition is valid or not.\n * @param {Object} where A query condition\n * @param {Array} validPushTypes An array of valid push types(string)\n */\nexport function validatePushType(where = {}, validPushTypes = []) {\n  var deviceTypeField = where.deviceType || {};\n  var deviceTypes = [];\n  if (typeof deviceTypeField === 'string') {\n    deviceTypes.push(deviceTypeField);\n  } else if (Array.isArray(deviceTypeField['$in'])) {\n    deviceTypes.concat(deviceTypeField['$in']);\n  }\n  for (var i = 0; i < deviceTypes.length; i++) {\n    var deviceType = deviceTypes[i];\n    if (validPushTypes.indexOf(deviceType) < 0) {\n      throw new Parse.Error(Parse.Error.PUSH_MISCONFIGURED,\n        deviceType + ' is not supported push type.');\n    }\n  }\n}\n\nexport function applyDeviceTokenExists(where) {\n  where = deepcopy(where);\n  if (!where.hasOwnProperty('deviceToken')) {\n    where['deviceToken'] = {'$exists': true};\n  }\n  return where;\n}\n"]}