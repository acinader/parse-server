{"version":3,"sources":["../../src/Push/PushQueue.js"],"names":["PUSH_CHANNEL","DEFAULT_BATCH_SIZE","PushQueue","constructor","config","channel","defaultPushChannel","batchSize","parsePublisher","ParseMessageQueue","createPublisher","Parse","applicationId","enqueue","body","where","auth","pushStatus","limit","order","Promise","resolve","then","rest","find","count","results","complete","setRunning","Math","ceil","skip","query","pushWorkItem","objectId","publish","JSON","stringify"],"mappings":";;;;;;;AAAA;;AACA;;;;AACA;;AACA;;;;;;AAEA,MAAMA,eAAe,mBAArB;AACA,MAAMC,qBAAqB,GAA3B;;AAEO,MAAMC,SAAN,CAAgB;;AAKrB;AACA;AACAC,cAAYC,SAAc,EAA1B,EAA8B;AAC5B,SAAKC,OAAL,GAAeD,OAAOC,OAAP,IAAkBH,UAAUI,kBAAV,EAAjC;AACA,SAAKC,SAAL,GAAiBH,OAAOG,SAAP,IAAoBN,kBAArC;AACA,SAAKO,cAAL,GAAsBC,qCAAkBC,eAAlB,CAAkCN,MAAlC,CAAtB;AACD;;AAED,SAAOE,kBAAP,GAA4B;AAC1B,WAAQ,GAAEK,eAAMC,aAAc,IAAGZ,YAAa,EAA9C;AACD;;AAEDa,UAAQC,IAAR,EAAcC,KAAd,EAAqBX,MAArB,EAA6BY,IAA7B,EAAmCC,UAAnC,EAA+C;AAC7C,UAAMC,QAAQ,KAAKX,SAAnB;;AAEAQ,YAAQ,mCAAuBA,KAAvB,CAAR;;AAEA;AACA,UAAMI,QAAQ,UAAd;AACA,WAAOC,QAAQC,OAAR,GAAkBC,IAAlB,CAAuB,MAAM;AAClC,aAAOC,eAAKC,IAAL,CAAUpB,MAAV,EACLY,IADK,EAEL,eAFK,EAGLD,KAHK,EAIL,EAACG,OAAO,CAAR,EAAWO,OAAO,IAAlB,EAJK,CAAP;AAKD,KANM,EAMJH,IANI,CAMC,CAAC,EAACI,OAAD,EAAUD,KAAV,EAAD,KAAsB;AAC5B,UAAI,CAACC,OAAD,IAAYD,SAAS,CAAzB,EAA4B;AAC1B,eAAOR,WAAWU,QAAX,EAAP;AACD;AACDV,iBAAWW,UAAX,CAAsBC,KAAKC,IAAL,CAAUL,QAAQP,KAAlB,CAAtB;AACA,UAAIa,OAAO,CAAX;AACA,aAAOA,OAAON,KAAd,EAAqB;AACnB,cAAMO,QAAQ,EAAEjB,KAAF;AACZG,eADY;AAEZa,cAFY;AAGZZ,eAHY,EAAd;;AAKA,cAAMc,eAAe;AACnBnB,cADmB;AAEnBkB,eAFmB;AAGnBf,sBAAY,EAAEiB,UAAUjB,WAAWiB,QAAvB,EAHO;AAInBtB,yBAAeR,OAAOQ;AAJH,SAArB;AAMA,aAAKJ,cAAL,CAAoB2B,OAApB,CAA4B,KAAK9B,OAAjC,EAA0C+B,KAAKC,SAAL,CAAeJ,YAAf,CAA1C;AACAF,gBAAQb,KAAR;AACD;AACF,KA3BM,CAAP;AA4BD;AApDoB;QAAVhB,S,GAAAA,S","file":"PushQueue.js","sourcesContent":["import { ParseMessageQueue }      from '../ParseMessageQueue';\nimport rest                       from '../rest';\nimport { applyDeviceTokenExists } from './utils';\nimport Parse from 'parse/node';\n\nconst PUSH_CHANNEL = 'parse-server-push';\nconst DEFAULT_BATCH_SIZE = 100;\n\nexport class PushQueue {\n  parsePublisher: Object;\n  channel: String;\n  batchSize: Number;\n\n  // config object of the publisher, right now it only contains the redisURL,\n  // but we may extend it later.\n  constructor(config: any = {}) {\n    this.channel = config.channel || PushQueue.defaultPushChannel();\n    this.batchSize = config.batchSize || DEFAULT_BATCH_SIZE;\n    this.parsePublisher = ParseMessageQueue.createPublisher(config);\n  }\n\n  static defaultPushChannel() {\n    return `${Parse.applicationId}-${PUSH_CHANNEL}`;\n  }\n\n  enqueue(body, where, config, auth, pushStatus) {\n    const limit = this.batchSize;\n\n    where = applyDeviceTokenExists(where);\n\n    // Order by objectId so no impact on the DB\n    const order = 'objectId';\n    return Promise.resolve().then(() => {\n      return rest.find(config,\n        auth,\n        '_Installation',\n        where,\n        {limit: 0, count: true});\n    }).then(({results, count}) => {\n      if (!results || count == 0) {\n        return pushStatus.complete();\n      }\n      pushStatus.setRunning(Math.ceil(count / limit));\n      let skip = 0;\n      while (skip < count) {\n        const query = { where,\n          limit,\n          skip,\n          order };\n\n        const pushWorkItem = {\n          body,\n          query,\n          pushStatus: { objectId: pushStatus.objectId },\n          applicationId: config.applicationId\n        }\n        this.parsePublisher.publish(this.channel, JSON.stringify(pushWorkItem));\n        skip += limit;\n      }\n    });\n  }\n}\n"]}