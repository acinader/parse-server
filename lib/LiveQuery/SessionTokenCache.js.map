{"version":3,"sources":["../../src/LiveQuery/SessionTokenCache.js"],"names":["userForSessionToken","sessionToken","q","Parse","Query","equalTo","first","useMasterKey","then","session","Promise","error","get","SessionTokenCache","constructor","timeout","maxSize","cache","LRU","max","maxAge","getUserId","userId","logger","verbose","as","user","id","set"],"mappings":";;;;;;;AAAA;;;;AACA;;;;AACA;;;;;;AAEA,SAASA,mBAAT,CAA6BC,YAA7B,EAA0C;AACxC,MAAIC,IAAI,IAAIC,eAAMC,KAAV,CAAgB,UAAhB,CAAR;AACAF,IAAEG,OAAF,CAAU,cAAV,EAA0BJ,YAA1B;AACA,SAAOC,EAAEI,KAAF,CAAQ,EAACC,cAAa,IAAd,EAAR,EAA6BC,IAA7B,CAAkC,UAASC,OAAT,EAAiB;AACxD,QAAG,CAACA,OAAJ,EAAY;AACV,aAAON,eAAMO,OAAN,CAAcC,KAAd,CAAoB,oCAApB,CAAP;AACD;AACD,WAAOF,QAAQG,GAAR,CAAY,MAAZ,CAAP;AACD,GALM,CAAP;AAMD;;AAED,MAAMC,iBAAN,CAAwB;;AAGtBC,cAAYC,UAAkB,KAAK,EAAL,GAAU,EAAV,GAAe,EAAf,GAAoB,IAAlD,EAAwDC,UAAkB,KAA1E,EAAiF;AAC/E,SAAKC,KAAL,GAAa,IAAIC,kBAAJ,CAAQ;AACnBC,WAAKH,OADc;AAEnBI,cAAQL;AAFW,KAAR,CAAb;AAID;;AAEDM,YAAUpB,YAAV,EAAqC;AACnC,QAAI,CAACA,YAAL,EAAmB;AACjB,aAAOE,eAAMO,OAAN,CAAcC,KAAd,CAAoB,oBAApB,CAAP;AACD;AACD,UAAMW,SAAS,KAAKL,KAAL,CAAWL,GAAX,CAAeX,YAAf,CAAf;AACA,QAAIqB,MAAJ,EAAY;AACVC,uBAAOC,OAAP,CAAe,+CAAf,EAAgEF,MAAhE,EAAwErB,YAAxE;AACA,aAAOE,eAAMO,OAAN,CAAce,EAAd,CAAiBH,MAAjB,CAAP;AACD;AACD,WAAOtB,oBAAoBC,YAApB,EAAkCO,IAAlC,CAAwCkB,IAAD,IAAU;AACtDH,uBAAOC,OAAP,CAAe,+CAAf,EAAgEE,KAAKC,EAArE,EAAyE1B,YAAzE;AACA,YAAMqB,SAASI,KAAKC,EAApB;AACA,WAAKV,KAAL,CAAWW,GAAX,CAAe3B,YAAf,EAA6BqB,MAA7B;AACA,aAAOnB,eAAMO,OAAN,CAAce,EAAd,CAAiBH,MAAjB,CAAP;AACD,KALM,EAKHX,KAAD,IAAW;AACZY,uBAAOZ,KAAP,CAAa,oDAAb,EAAmEV,YAAnE,EAAiFU,KAAjF;AACA,aAAOR,eAAMO,OAAN,CAAcC,KAAd,CAAoBA,KAApB,CAAP;AACD,KARM,CAAP;AASD;AA5BqB;;QAgCtBE,iB,GAAAA,iB","file":"SessionTokenCache.js","sourcesContent":["import Parse from 'parse/node';\nimport LRU from 'lru-cache';\nimport logger from '../logger';\n\nfunction userForSessionToken(sessionToken){\n  var q = new Parse.Query(\"_Session\");\n  q.equalTo(\"sessionToken\", sessionToken);\n  return q.first({useMasterKey:true}).then(function(session){\n    if(!session){\n      return Parse.Promise.error(\"No session found for session token\");\n    }\n    return session.get(\"user\");\n  });\n}\n\nclass SessionTokenCache {\n  cache: Object;\n\n  constructor(timeout: number = 30 * 24 * 60 * 60 * 1000, maxSize: number = 10000) {\n    this.cache = new LRU({\n      max: maxSize,\n      maxAge: timeout\n    });\n  }\n\n  getUserId(sessionToken: string): any {\n    if (!sessionToken) {\n      return Parse.Promise.error('Empty sessionToken');\n    }\n    const userId = this.cache.get(sessionToken);\n    if (userId) {\n      logger.verbose('Fetch userId %s of sessionToken %s from Cache', userId, sessionToken);\n      return Parse.Promise.as(userId);\n    }\n    return userForSessionToken(sessionToken).then((user) => {\n      logger.verbose('Fetch userId %s of sessionToken %s from Parse', user.id, sessionToken);\n      const userId = user.id;\n      this.cache.set(sessionToken, userId);\n      return Parse.Promise.as(userId);\n    }, (error) => {\n      logger.error('Can not fetch userId for sessionToken %j, error %j', sessionToken, error);\n      return Parse.Promise.error(error);\n    });\n  }\n}\n\nexport {\n  SessionTokenCache\n}\n"]}