{"version":3,"sources":["../../src/LiveQuery/ParseLiveQueryServer.js"],"names":["ParseLiveQueryServer","constructor","server","config","clients","Map","subscriptions","keyPairs","key","Object","keys","set","logger","verbose","Parse","disableSingleInstance","serverURL","appId","applicationId","javascriptKey","javaScriptKey","masterKey","initialize","parseWebSocketServer","ParseWebSocketServer","parseWebsocket","_onConnect","websocketTimeout","subscriber","ParsePubSub","createSubscriber","subscribe","on","channel","messageStr","message","JSON","parse","e","error","_inflateParseObject","_onAfterSave","_onAfterDelete","sessionTokenCache","SessionTokenCache","cacheTimeout","currentParseObject","className","parseObject","_finishFetch","originalParseObject","deletedParseObject","toJSON","id","size","classSubscriptions","get","debug","subscription","values","isSubscriptionMatched","_matchesSubscription","clientId","requestIds","_","entries","clientRequestIds","client","requestId","acl","getACL","_matchesACL","then","isMatched","pushDelete","isOriginalSubscriptionMatched","isCurrentSubscriptionMatched","originalACLCheckingPromise","Promise","as","originalACL","currentACLCheckingPromise","currentACL","when","isOriginalMatched","isCurrentMatched","hash","type","functionName","request","tv4","validate","RequestSchema","op","Client","pushError","_handleConnect","_handleSubscribe","_handleUpdateSubscription","_handleUnsubscribe","info","has","event","delete","subscriptionInfo","subscriptionInfos","deleteClientSubscription","hasSubscribingClient","query","getPublicReadAccess","hasMasterKey","getSubscriptionInfo","subscriptionSessionToken","sessionToken","getUserId","userId","getReadAccess","isSubscriptionSessionTokenMatched","resolve","reject","acl_has_roles","permissionsById","some","startsWith","user","User","rolesQuery","Query","Role","equalTo","find","useMasterKey","roles","role","getRoleReadAccess","catch","isRoleMatched","clientSessionToken","_validateKeys","_hasMasterKey","pushConnect","validKeyPairs","hasOwnProperty","isValid","secret","subscriptionHash","Subscription","where","fields","addSubscriptionInfo","addClientSubscription","pushSubscribe","notifyClient","deleteSubscriptionInfo","pushUnsubscribe"],"mappings":"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","file":"ParseLiveQueryServer.js","sourcesContent":["import tv4 from 'tv4';\nimport Parse from 'parse/node';\nimport { Subscription } from './Subscription';\nimport { Client } from './Client';\nimport { ParseWebSocketServer } from './ParseWebSocketServer';\nimport logger from '../logger';\nimport RequestSchema from './RequestSchema';\nimport { matchesQuery, queryHash } from './QueryTools';\nimport { ParsePubSub } from './ParsePubSub';\nimport { SessionTokenCache } from './SessionTokenCache';\nimport _ from 'lodash';\nimport uuid from 'uuid';\nimport { runLiveQueryEventHandlers } from '../triggers';\n\nclass ParseLiveQueryServer {\n  clients: Map;\n  // className -> (queryHash -> subscription)\n  subscriptions: Object;\n  parseWebSocketServer: Object;\n  keyPairs : any;\n  // The subscriber we use to get object update from publisher\n  subscriber: Object;\n\n  constructor(server: any, config: any) {\n    this.server = server;\n    this.clients = new Map();\n    this.subscriptions = new Map();\n\n    config = config || {};\n\n    // Store keys, convert obj to map\n    const keyPairs = config.keyPairs || {};\n    this.keyPairs = new Map();\n    for (const key of Object.keys(keyPairs)) {\n      this.keyPairs.set(key, keyPairs[key]);\n    }\n    logger.verbose('Support key pairs', this.keyPairs);\n\n    // Initialize Parse\n    Parse.Object.disableSingleInstance();\n\n    const serverURL = config.serverURL || Parse.serverURL;\n    Parse.serverURL = serverURL;\n    const appId = config.appId || Parse.applicationId;\n    const javascriptKey = Parse.javaScriptKey;\n    const masterKey = config.masterKey || Parse.masterKey;\n    Parse.initialize(appId, javascriptKey, masterKey);\n\n    // Initialize websocket server\n    this.parseWebSocketServer = new ParseWebSocketServer(\n      server,\n      (parseWebsocket) => this._onConnect(parseWebsocket),\n      config.websocketTimeout\n    );\n\n    // Initialize subscriber\n    this.subscriber = ParsePubSub.createSubscriber(config);\n    this.subscriber.subscribe(Parse.applicationId + 'afterSave');\n    this.subscriber.subscribe(Parse.applicationId + 'afterDelete');\n    // Register message handler for subscriber. When publisher get messages, it will publish message\n    // to the subscribers and the handler will be called.\n    this.subscriber.on('message', (channel, messageStr) => {\n      logger.verbose('Subscribe messsage %j', messageStr);\n      let message;\n      try {\n        message = JSON.parse(messageStr);\n      } catch(e) {\n        logger.error('unable to parse message', messageStr, e);\n        return;\n      }\n      this._inflateParseObject(message);\n      if (channel === Parse.applicationId + 'afterSave') {\n        this._onAfterSave(message);\n      } else if (channel === Parse.applicationId + 'afterDelete') {\n        this._onAfterDelete(message);\n      } else {\n        logger.error('Get message %s from unknown channel %j', message, channel);\n      }\n    });\n\n    // Initialize sessionToken cache\n    this.sessionTokenCache = new SessionTokenCache(config.cacheTimeout);\n  }\n\n  // Message is the JSON object from publisher. Message.currentParseObject is the ParseObject JSON after changes.\n  // Message.originalParseObject is the original ParseObject JSON.\n  _inflateParseObject(message: any): void {\n    // Inflate merged object\n    const currentParseObject = message.currentParseObject;\n    let className = currentParseObject.className;\n    let parseObject = new Parse.Object(className);\n    parseObject._finishFetch(currentParseObject);\n    message.currentParseObject = parseObject;\n    // Inflate original object\n    const originalParseObject = message.originalParseObject;\n    if (originalParseObject) {\n      className = originalParseObject.className;\n      parseObject = new Parse.Object(className);\n      parseObject._finishFetch(originalParseObject);\n      message.originalParseObject = parseObject;\n    }\n  }\n\n  // Message is the JSON object from publisher after inflated. Message.currentParseObject is the ParseObject after changes.\n  // Message.originalParseObject is the original ParseObject.\n  _onAfterDelete(message: any): void {\n    logger.verbose(Parse.applicationId + 'afterDelete is triggered');\n\n    const deletedParseObject = message.currentParseObject.toJSON();\n    const className = deletedParseObject.className;\n    logger.verbose('ClassName: %j | ObjectId: %s', className, deletedParseObject.id);\n    logger.verbose('Current client number : %d', this.clients.size);\n\n    const classSubscriptions = this.subscriptions.get(className);\n    if (typeof classSubscriptions === 'undefined') {\n      logger.debug('Can not find subscriptions under this class ' + className);\n      return;\n    }\n    for (const subscription of classSubscriptions.values()) {\n      const isSubscriptionMatched = this._matchesSubscription(deletedParseObject, subscription);\n      if (!isSubscriptionMatched) {\n        continue;\n      }\n      for (const [clientId, requestIds] of _.entries(subscription.clientRequestIds)) {\n        const client = this.clients.get(clientId);\n        if (typeof client === 'undefined') {\n          continue;\n        }\n        for (const requestId of requestIds) {\n          const acl = message.currentParseObject.getACL();\n          // Check ACL\n          this._matchesACL(acl, client, requestId).then((isMatched) => {\n            if (!isMatched) {\n              return null;\n            }\n            client.pushDelete(requestId, deletedParseObject);\n          }, (error) => {\n            logger.error('Matching ACL error : ', error);\n          });\n        }\n      }\n    }\n  }\n\n  // Message is the JSON object from publisher after inflated. Message.currentParseObject is the ParseObject after changes.\n  // Message.originalParseObject is the original ParseObject.\n  _onAfterSave(message: any): void {\n    logger.verbose(Parse.applicationId + 'afterSave is triggered');\n\n    let originalParseObject = null;\n    if (message.originalParseObject) {\n      originalParseObject = message.originalParseObject.toJSON();\n    }\n    const currentParseObject = message.currentParseObject.toJSON();\n    const className = currentParseObject.className;\n    logger.verbose('ClassName: %s | ObjectId: %s', className, currentParseObject.id);\n    logger.verbose('Current client number : %d', this.clients.size);\n\n    const classSubscriptions = this.subscriptions.get(className);\n    if (typeof classSubscriptions === 'undefined') {\n      logger.debug('Can not find subscriptions under this class ' + className);\n      return;\n    }\n    for (const subscription of classSubscriptions.values()) {\n      const isOriginalSubscriptionMatched = this._matchesSubscription(originalParseObject, subscription);\n      const isCurrentSubscriptionMatched = this._matchesSubscription(currentParseObject, subscription);\n      for (const [clientId, requestIds] of _.entries(subscription.clientRequestIds)) {\n        const client = this.clients.get(clientId);\n        if (typeof client === 'undefined') {\n          continue;\n        }\n        for (const requestId of requestIds) {\n          // Set orignal ParseObject ACL checking promise, if the object does not match\n          // subscription, we do not need to check ACL\n          let originalACLCheckingPromise;\n          if (!isOriginalSubscriptionMatched) {\n            originalACLCheckingPromise = Parse.Promise.as(false);\n          } else {\n            let originalACL;\n            if (message.originalParseObject) {\n              originalACL = message.originalParseObject.getACL();\n            }\n            originalACLCheckingPromise = this._matchesACL(originalACL, client, requestId);\n          }\n          // Set current ParseObject ACL checking promise, if the object does not match\n          // subscription, we do not need to check ACL\n          let currentACLCheckingPromise;\n          if (!isCurrentSubscriptionMatched) {\n            currentACLCheckingPromise = Parse.Promise.as(false);\n          } else {\n            const currentACL = message.currentParseObject.getACL();\n            currentACLCheckingPromise = this._matchesACL(currentACL, client, requestId);\n          }\n\n          Parse.Promise.when(\n            originalACLCheckingPromise,\n            currentACLCheckingPromise\n          ).then((isOriginalMatched, isCurrentMatched) => {\n            logger.verbose('Original %j | Current %j | Match: %s, %s, %s, %s | Query: %s',\n              originalParseObject,\n              currentParseObject,\n              isOriginalSubscriptionMatched,\n              isCurrentSubscriptionMatched,\n              isOriginalMatched,\n              isCurrentMatched,\n              subscription.hash\n            );\n\n            // Decide event type\n            let type;\n            if (isOriginalMatched && isCurrentMatched) {\n              type = 'Update';\n            } else if (isOriginalMatched && !isCurrentMatched) {\n              type = 'Leave';\n            } else if (!isOriginalMatched && isCurrentMatched) {\n              if (originalParseObject) {\n                type = 'Enter';\n              } else {\n                type = 'Create';\n              }\n            } else {\n              return null;\n            }\n            const functionName = 'push' + type;\n            client[functionName](requestId, currentParseObject);\n          }, (error) => {\n            logger.error('Matching ACL error : ', error);\n          });\n        }\n      }\n    }\n  }\n\n  _onConnect(parseWebsocket: any): void {\n    parseWebsocket.on('message', (request) => {\n      if (typeof request === 'string') {\n        try {\n          request = JSON.parse(request);\n        } catch(e) {\n          logger.error('unable to parse request', request, e);\n          return;\n        }\n      }\n      logger.verbose('Request: %j', request);\n\n      // Check whether this request is a valid request, return error directly if not\n      if (!tv4.validate(request, RequestSchema['general']) || !tv4.validate(request, RequestSchema[request.op])) {\n        Client.pushError(parseWebsocket, 1, tv4.error.message);\n        logger.error('Connect message error %s', tv4.error.message);\n        return;\n      }\n\n      switch(request.op) {\n      case 'connect':\n        this._handleConnect(parseWebsocket, request);\n        break;\n      case 'subscribe':\n        this._handleSubscribe(parseWebsocket, request);\n        break;\n      case 'update':\n        this._handleUpdateSubscription(parseWebsocket, request);\n        break;\n      case 'unsubscribe':\n        this._handleUnsubscribe(parseWebsocket, request);\n        break;\n      default:\n        Client.pushError(parseWebsocket, 3, 'Get unknown operation');\n        logger.error('Get unknown operation', request.op);\n      }\n    });\n\n    parseWebsocket.on('disconnect', () => {\n      logger.info(`Client disconnect: ${parseWebsocket.clientId}`);\n      const clientId = parseWebsocket.clientId;\n      if (!this.clients.has(clientId)) {\n        runLiveQueryEventHandlers({\n          event: 'ws_disconnect_error',\n          clients: this.clients.size,\n          subscriptions: this.subscriptions.size,\n          error: `Unable to find client ${clientId}`\n        });\n        logger.error(`Can not find client ${clientId} on disconnect`);\n        return;\n      }\n\n      // Delete client\n      const client = this.clients.get(clientId);\n      this.clients.delete(clientId);\n\n      // Delete client from subscriptions\n      for (const [requestId, subscriptionInfo] of _.entries(client.subscriptionInfos)) {\n        const subscription = subscriptionInfo.subscription;\n        subscription.deleteClientSubscription(clientId, requestId);\n\n        // If there is no client which is subscribing this subscription, remove it from subscriptions\n        const classSubscriptions = this.subscriptions.get(subscription.className);\n        if (!subscription.hasSubscribingClient()) {\n          classSubscriptions.delete(subscription.hash);\n        }\n        // If there is no subscriptions under this class, remove it from subscriptions\n        if (classSubscriptions.size === 0) {\n          this.subscriptions.delete(subscription.className);\n        }\n      }\n\n      logger.verbose('Current clients %d', this.clients.size);\n      logger.verbose('Current subscriptions %d', this.subscriptions.size);\n      runLiveQueryEventHandlers({\n        event: 'ws_disconnect',\n        clients: this.clients.size,\n        subscriptions: this.subscriptions.size\n      });\n    });\n\n    runLiveQueryEventHandlers({\n      event: 'ws_connect',\n      clients: this.clients.size,\n      subscriptions: this.subscriptions.size\n    });\n  }\n\n  _matchesSubscription(parseObject: any, subscription: any): boolean {\n    // Object is undefined or null, not match\n    if (!parseObject) {\n      return false;\n    }\n    return matchesQuery(parseObject, subscription.query);\n  }\n\n  _matchesACL(acl: any, client: any, requestId: number): any {\n    // Return true directly if ACL isn't present, ACL is public read, or client has master key\n    if (!acl || acl.getPublicReadAccess() || client.hasMasterKey) {\n      return Parse.Promise.as(true);\n    }\n    // Check subscription sessionToken matches ACL first\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    if (typeof subscriptionInfo === 'undefined') {\n      return Parse.Promise.as(false);\n    }\n\n    const subscriptionSessionToken = subscriptionInfo.sessionToken;\n    return this.sessionTokenCache.getUserId(subscriptionSessionToken).then((userId) => {\n      return acl.getReadAccess(userId);\n    }).then((isSubscriptionSessionTokenMatched) => {\n      if (isSubscriptionSessionTokenMatched) {\n        return Parse.Promise.as(true);\n      }\n\n      // Check if the user has any roles that match the ACL\n      return new Parse.Promise((resolve, reject) => {\n\n        // Resolve false right away if the acl doesn't have any roles\n        const acl_has_roles = Object.keys(acl.permissionsById).some(key => key.startsWith(\"role:\"));\n        if (!acl_has_roles) {\n          return resolve(false);\n        }\n\n        this.sessionTokenCache.getUserId(subscriptionSessionToken)\n          .then((userId) => {\n\n            // Pass along a null if there is no user id\n            if (!userId) {\n              return Parse.Promise.as(null);\n            }\n\n            // Prepare a user object to query for roles\n            // To eliminate a query for the user, create one locally with the id\n            var user = new Parse.User();\n            user.id = userId;\n            return user;\n\n          })\n          .then((user) => {\n\n            // Pass along an empty array (of roles) if no user\n            if (!user) {\n              return Parse.Promise.as([]);\n            }\n\n            // Then get the user's roles\n            var rolesQuery = new Parse.Query(Parse.Role);\n            rolesQuery.equalTo(\"users\", user);\n            return rolesQuery.find({useMasterKey:true});\n          }).\n          then((roles) => {\n\n            // Finally, see if any of the user's roles allow them read access\n            for (const role of roles) {\n              if (acl.getRoleReadAccess(role)) {\n                return resolve(true);\n              }\n            }\n            resolve(false);\n          })\n          .catch((error) => {\n            reject(error);\n          });\n\n      });\n    }).then((isRoleMatched) => {\n\n      if(isRoleMatched) {\n        return Parse.Promise.as(true);\n      }\n\n      // Check client sessionToken matches ACL\n      const clientSessionToken = client.sessionToken;\n      return this.sessionTokenCache.getUserId(clientSessionToken).then((userId) => {\n        return acl.getReadAccess(userId);\n      });\n    }).then((isMatched) => {\n      return Parse.Promise.as(isMatched);\n    }, () => {\n      return Parse.Promise.as(false);\n    });\n  }\n\n  _handleConnect(parseWebsocket: any, request: any): any {\n    if (!this._validateKeys(request, this.keyPairs)) {\n      Client.pushError(parseWebsocket, 4, 'Key in request is not valid');\n      logger.error('Key in request is not valid');\n      return;\n    }\n    const hasMasterKey = this._hasMasterKey(request, this.keyPairs);\n    const clientId = uuid();\n    const client = new Client(clientId, parseWebsocket, hasMasterKey);\n    parseWebsocket.clientId = clientId;\n    this.clients.set(parseWebsocket.clientId, client);\n    logger.info(`Create new client: ${parseWebsocket.clientId}`);\n    client.pushConnect();\n    runLiveQueryEventHandlers({\n      event: 'connect',\n      clients: this.clients.size,\n      subscriptions: this.subscriptions.size\n    });\n  }\n\n  _hasMasterKey(request: any, validKeyPairs: any): boolean {\n    if(!validKeyPairs || validKeyPairs.size == 0 ||\n      !validKeyPairs.has(\"masterKey\")) {\n      return false;\n    }\n    if(!request || !request.hasOwnProperty(\"masterKey\")) {\n      return false;\n    }\n    return request.masterKey === validKeyPairs.get(\"masterKey\");\n  }\n\n  _validateKeys(request: any, validKeyPairs: any): boolean {\n    if (!validKeyPairs || validKeyPairs.size == 0) {\n      return true;\n    }\n    let isValid = false;\n    for (const [key, secret] of validKeyPairs) {\n      if (!request[key] || request[key] !== secret) {\n        continue;\n      }\n      isValid = true;\n      break;\n    }\n    return isValid;\n  }\n\n  _handleSubscribe(parseWebsocket: any, request: any): any {\n    // If we can not find this client, return error to client\n    if (!parseWebsocket.hasOwnProperty('clientId')) {\n      Client.pushError(parseWebsocket, 2, 'Can not find this client, make sure you connect to server before subscribing');\n      logger.error('Can not find this client, make sure you connect to server before subscribing');\n      return;\n    }\n    const client = this.clients.get(parseWebsocket.clientId);\n\n    // Get subscription from subscriptions, create one if necessary\n    const subscriptionHash = queryHash(request.query);\n    // Add className to subscriptions if necessary\n    const className = request.query.className;\n    if (!this.subscriptions.has(className)) {\n      this.subscriptions.set(className, new Map());\n    }\n    const classSubscriptions = this.subscriptions.get(className);\n    let subscription;\n    if (classSubscriptions.has(subscriptionHash)) {\n      subscription = classSubscriptions.get(subscriptionHash);\n    } else {\n      subscription = new Subscription(className, request.query.where, subscriptionHash);\n      classSubscriptions.set(subscriptionHash, subscription);\n    }\n\n    // Add subscriptionInfo to client\n    const subscriptionInfo = {\n      subscription: subscription\n    };\n    // Add selected fields and sessionToken for this subscription if necessary\n    if (request.query.fields) {\n      subscriptionInfo.fields = request.query.fields;\n    }\n    if (request.sessionToken) {\n      subscriptionInfo.sessionToken = request.sessionToken;\n    }\n    client.addSubscriptionInfo(request.requestId, subscriptionInfo);\n\n    // Add clientId to subscription\n    subscription.addClientSubscription(parseWebsocket.clientId, request.requestId);\n\n    client.pushSubscribe(request.requestId);\n\n    logger.verbose(`Create client ${parseWebsocket.clientId} new subscription: ${request.requestId}`);\n    logger.verbose('Current client number: %d', this.clients.size);\n    runLiveQueryEventHandlers({\n      event: 'subscribe',\n      clients: this.clients.size,\n      subscriptions: this.subscriptions.size\n    });\n  }\n\n  _handleUpdateSubscription(parseWebsocket: any, request: any): any {\n    this._handleUnsubscribe(parseWebsocket, request, false);\n    this._handleSubscribe(parseWebsocket, request);\n  }\n\n  _handleUnsubscribe(parseWebsocket: any, request: any, notifyClient: bool = true): any {\n    // If we can not find this client, return error to client\n    if (!parseWebsocket.hasOwnProperty('clientId')) {\n      Client.pushError(parseWebsocket, 2, 'Can not find this client, make sure you connect to server before unsubscribing');\n      logger.error('Can not find this client, make sure you connect to server before unsubscribing');\n      return;\n    }\n    const requestId = request.requestId;\n    const client = this.clients.get(parseWebsocket.clientId);\n    if (typeof client === 'undefined') {\n      Client.pushError(parseWebsocket, 2, 'Cannot find client with clientId '  + parseWebsocket.clientId +\n        '. Make sure you connect to live query server before unsubscribing.');\n      logger.error('Can not find this client ' + parseWebsocket.clientId);\n      return;\n    }\n\n    const subscriptionInfo = client.getSubscriptionInfo(requestId);\n    if (typeof subscriptionInfo === 'undefined') {\n      Client.pushError(parseWebsocket, 2, 'Cannot find subscription with clientId '  + parseWebsocket.clientId +\n        ' subscriptionId ' + requestId + '. Make sure you subscribe to live query server before unsubscribing.');\n      logger.error('Can not find subscription with clientId ' + parseWebsocket.clientId +  ' subscriptionId ' + requestId);\n      return;\n    }\n\n    // Remove subscription from client\n    client.deleteSubscriptionInfo(requestId);\n    // Remove client from subscription\n    const subscription = subscriptionInfo.subscription;\n    const className = subscription.className;\n    subscription.deleteClientSubscription(parseWebsocket.clientId, requestId);\n    // If there is no client which is subscribing this subscription, remove it from subscriptions\n    const classSubscriptions = this.subscriptions.get(className);\n    if (!subscription.hasSubscribingClient()) {\n      classSubscriptions.delete(subscription.hash);\n    }\n    // If there is no subscriptions under this class, remove it from subscriptions\n    if (classSubscriptions.size === 0) {\n      this.subscriptions.delete(className);\n    }\n    runLiveQueryEventHandlers({\n      event: 'unsubscribe',\n      clients: this.clients.size,\n      subscriptions: this.subscriptions.size\n    });\n\n    if (!notifyClient) {\n      return;\n    }\n\n    client.pushUnsubscribe(request.requestId);\n\n    logger.verbose(`Delete client: ${parseWebsocket.clientId} | subscription: ${request.requestId}`);\n  }\n}\n\nexport {\n  ParseLiveQueryServer\n}\n"]}