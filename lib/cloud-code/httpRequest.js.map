{"version":3,"sources":["../../src/cloud-code/httpRequest.js"],"names":["encodeBody","body","headers","contentTypeKeys","Object","keys","filter","key","match","length","querystring","stringify","log","error","contentType","JSON","module","exports","options","promise","Parse","Promise","callbacks","success","uri","assign","followRedirect","followRedirects","params","qs","parse","encoding","response","reject","httpResponse","HTTPResponse","status","resolve"],"mappings":"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","file":"httpRequest.js","sourcesContent":["import request from 'request';\nimport Parse from 'parse/node';\nimport HTTPResponse from './HTTPResponse';\nimport querystring from 'querystring';\nimport log from '../logger';\n\nvar encodeBody = function({body, headers = {}}) {\n  if (typeof body !== 'object') {\n    return {body, headers};\n  }\n  var contentTypeKeys = Object.keys(headers).filter((key) => {\n    return key.match(/content-type/i) != null;\n  });\n\n  if (contentTypeKeys.length == 0) {\n    // no content type\n    //  As per https://parse.com/docs/cloudcode/guide#cloud-code-advanced-sending-a-post-request the default encoding is supposedly x-www-form-urlencoded\n\n    body = querystring.stringify(body);\n    headers['Content-Type'] = 'application/x-www-form-urlencoded';\n  } else {\n    /* istanbul ignore next */\n    if (contentTypeKeys.length > 1) {\n      log.error('Parse.Cloud.httpRequest', 'multiple content-type headers are set.');\n    }\n    // There maybe many, we'll just take the 1st one\n    var contentType = contentTypeKeys[0];\n    if (headers[contentType].match(/application\\/json/i)) {\n      body = JSON.stringify(body);\n    } else if(headers[contentType].match(/application\\/x-www-form-urlencoded/i)) {\n      body = querystring.stringify(body);\n    }\n  }\n  return {body, headers};\n}\n\nmodule.exports = function(options) {\n  var promise = new Parse.Promise();\n  var callbacks = {\n    success: options.success,\n    error: options.error\n  };\n  delete options.success;\n  delete options.error;\n  delete options.uri; // not supported\n  options = Object.assign(options,  encodeBody(options));\n  // set follow redirects to false by default\n  options.followRedirect = options.followRedirects == true;\n  // support params options\n  if (typeof options.params === 'object') {\n    options.qs = options.params;\n  } else if (typeof options.params === 'string') {\n    options.qs = querystring.parse(options.params);\n  }\n  // force the response as a buffer\n  options.encoding = null;\n\n  request(options, (error, response, body) => {\n    if (error) {\n      if (callbacks.error) {\n        callbacks.error(error);\n      }\n      return promise.reject(error);\n    }\n    const httpResponse = new HTTPResponse(response, body);\n\n    // Consider <200 && >= 400 as errors\n    if (httpResponse.status < 200 || httpResponse.status >= 400) {\n      if (callbacks.error) {\n        callbacks.error(httpResponse);\n      }\n      return promise.reject(httpResponse);\n    } else {\n      if (callbacks.success) {\n        callbacks.success(httpResponse);\n      }\n      return promise.resolve(httpResponse);\n    }\n  });\n  return promise;\n};\n\nmodule.exports.encodeBody = encodeBody;\n"]}