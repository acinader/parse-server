{"version":3,"sources":["../src/rest.js"],"names":["Parse","require","RestQuery","RestWrite","triggers","checkTriggers","className","config","types","some","triggerType","getTrigger","Types","applicationId","checkLiveQuery","liveQueryController","hasLiveQuery","find","auth","restWhere","restOptions","clientSDK","enforceRoleSecurity","maybeRunQueryTrigger","beforeFind","then","result","query","execute","get","objectId","del","Error","INVALID_JSON","isUnauthenticated","SESSION_MISSING","inflatedObject","Promise","resolve","hasTriggers","forWrite","response","results","length","firstResult","isMaster","user","id","INVALID_SESSION_TOKEN","cacheAdapter","cacheController","sessionToken","Object","fromJSON","onAfterDelete","maybeRunTrigger","beforeDelete","OBJECT_NOT_FOUND","getUserRoles","options","acl","push","concat","userRoles","database","destroy","afterDelete","catch","error","handleSessionMissingError","create","restObject","write","update","originalRestObject","code","classesWithMasterOnlyAccess","method","OPERATION_FORBIDDEN","indexOf","isReadOnly","module","exports"],"mappings":"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","file":"rest.js","sourcesContent":["// This file contains helpers for running operations in REST format.\n// The goal is that handlers that explicitly handle an express route\n// should just be shallow wrappers around things in this file, but\n// these functions should not explicitly depend on the request\n// object.\n// This means that one of these handlers can support multiple\n// routes. That's useful for the routes that do really similar\n// things.\n\nvar Parse = require('parse/node').Parse;\n\nvar RestQuery = require('./RestQuery');\nvar RestWrite = require('./RestWrite');\nvar triggers = require('./triggers');\n\nfunction checkTriggers(className, config, types) {\n  return types.some((triggerType) => {\n    return triggers.getTrigger(className, triggers.Types[triggerType], config.applicationId);\n  });\n}\n\nfunction checkLiveQuery(className, config) {\n  return config.liveQueryController && config.liveQueryController.hasLiveQuery(className)\n}\n\n// Returns a promise for an object with optional keys 'results' and 'count'.\nfunction find(config, auth, className, restWhere, restOptions, clientSDK) {\n  enforceRoleSecurity('find', className, auth);\n  return triggers.maybeRunQueryTrigger(triggers.Types.beforeFind, className, restWhere, restOptions, config, auth).then((result) => {\n    restWhere = result.restWhere || restWhere;\n    restOptions = result.restOptions || restOptions;\n    const query = new RestQuery(config, auth, className, restWhere, restOptions, clientSDK);\n    return query.execute();\n  });\n}\n\n// get is just like find but only queries an objectId.\nconst get = (config, auth, className, objectId, restOptions, clientSDK) => {\n  var restWhere = { objectId };\n  enforceRoleSecurity('get', className, auth);\n  return triggers.maybeRunQueryTrigger(triggers.Types.beforeFind, className, restWhere, restOptions, config, auth, true).then((result) => {\n    restWhere = result.restWhere || restWhere;\n    restOptions = result.restOptions || restOptions;\n    const query = new RestQuery(config, auth, className, restWhere, restOptions, clientSDK);\n    return query.execute();\n  });\n}\n\n// Returns a promise that doesn't resolve to any useful value.\nfunction del(config, auth, className, objectId) {\n  if (typeof objectId !== 'string') {\n    throw new Parse.Error(Parse.Error.INVALID_JSON,\n      'bad objectId');\n  }\n\n  if (className === '_User' && auth.isUnauthenticated()) {\n    throw new Parse.Error(Parse.Error.SESSION_MISSING,\n      'Insufficient auth to delete user');\n  }\n\n  enforceRoleSecurity('delete', className, auth);\n\n  var inflatedObject;\n\n  return Promise.resolve().then(() => {\n    const hasTriggers = checkTriggers(className, config, ['beforeDelete', 'afterDelete']);\n    const hasLiveQuery = checkLiveQuery(className, config);\n    if (hasTriggers || hasLiveQuery || className == '_Session') {\n      return new RestQuery(config, auth, className, { objectId })\n        .forWrite()\n        .execute()\n        .then((response) => {\n          if (response && response.results && response.results.length) {\n            const firstResult = response.results[0];\n            firstResult.className = className;\n            if (className === '_Session' && !auth.isMaster) {\n              if (!auth.user || firstResult.user.objectId !== auth.user.id) {\n                throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN, 'Invalid session token');\n              }\n            }\n            var cacheAdapter = config.cacheController;\n            cacheAdapter.user.del(firstResult.sessionToken);\n            inflatedObject = Parse.Object.fromJSON(firstResult);\n            // Notify LiveQuery server if possible\n            config.liveQueryController.onAfterDelete(inflatedObject.className, inflatedObject);\n            return triggers.maybeRunTrigger(triggers.Types.beforeDelete, auth, inflatedObject, null,  config);\n          }\n          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND,\n            'Object not found for delete.');\n        });\n    }\n    return Promise.resolve({});\n  }).then(() => {\n    if (!auth.isMaster) {\n      return auth.getUserRoles();\n    } else {\n      return;\n    }\n  }).then(() => {\n    var options = {};\n    if (!auth.isMaster) {\n      options.acl = ['*'];\n      if (auth.user) {\n        options.acl.push(auth.user.id);\n        options.acl = options.acl.concat(auth.userRoles);\n      }\n    }\n\n    return config.database.destroy(className, {\n      objectId: objectId\n    }, options);\n  }).then(() => {\n    return triggers.maybeRunTrigger(triggers.Types.afterDelete, auth, inflatedObject, null, config);\n  }).catch((error) => {\n    handleSessionMissingError(error, className, auth);\n  });\n}\n\n// Returns a promise for a {response, status, location} object.\nfunction create(config, auth, className, restObject, clientSDK) {\n  enforceRoleSecurity('create', className, auth);\n  var write = new RestWrite(config, auth, className, null, restObject, null, clientSDK);\n  return write.execute();\n}\n\n// Returns a promise that contains the fields of the update that the\n// REST API is supposed to return.\n// Usually, this is just updatedAt.\nfunction update(config, auth, className, restWhere, restObject, clientSDK) {\n  enforceRoleSecurity('update', className, auth);\n\n  return Promise.resolve().then(() => {\n    const hasTriggers = checkTriggers(className, config, ['beforeSave', 'afterSave']);\n    const hasLiveQuery = checkLiveQuery(className, config);\n    if (hasTriggers || hasLiveQuery) {\n      // Do not use find, as it runs the before finds\n      return new RestQuery(config, auth, className, restWhere)\n        .forWrite()\n        .execute();\n    }\n    return Promise.resolve({});\n  }).then(({ results }) => {\n    var originalRestObject;\n    if (results && results.length) {\n      originalRestObject = results[0];\n    }\n    return new RestWrite(config, auth, className, restWhere, restObject, originalRestObject, clientSDK)\n      .execute();\n  }).catch((error) => {\n    handleSessionMissingError(error, className, auth);\n  });\n}\n\nfunction handleSessionMissingError(error, className) {\n  // If we're trying to update a user without / with bad session token\n  if (className === '_User'\n      && error.code === Parse.Error.OBJECT_NOT_FOUND) {\n    throw new Parse.Error(Parse.Error.SESSION_MISSING, 'Insufficient auth.');\n  }\n  throw error;\n}\n\nconst classesWithMasterOnlyAccess = ['_JobStatus', '_PushStatus', '_Hooks', '_GlobalConfig', '_JobSchedule'];\n// Disallowing access to the _Role collection except by master key\nfunction enforceRoleSecurity(method, className, auth) {\n  if (className === '_Installation' && !auth.isMaster) {\n    if (method === 'delete' || method === 'find') {\n      const error = `Clients aren't allowed to perform the ${method} operation on the installation collection.`\n      throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n    }\n  }\n\n  //all volatileClasses are masterKey only\n  if(classesWithMasterOnlyAccess.indexOf(className) >= 0 && !auth.isMaster){\n    const error = `Clients aren't allowed to perform the ${method} operation on the ${className} collection.`\n    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n  }\n\n  // readOnly masterKey is not allowed\n  if (auth.isReadOnly && (method === 'delete' || method === 'create' || method === 'update')) {\n    const error = `read-only masterKey isn't allowed to perform the ${method} operation.`\n    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n  }\n}\n\nmodule.exports = {\n  create,\n  del,\n  find,\n  get,\n  update\n};\n"]}