{"version":3,"sources":["../src/cryptoUtils.js"],"names":["randomHexString","randomString","newObjectId","newToken","md5Hash","size","Error","toString","chars","objectId","bytes","i","length","readUInt8","string","update","digest"],"mappings":";;;;;QAKgBA,e,GAAAA,e;QAgBAC,Y,GAAAA,Y;QAgBAC,W,GAAAA,W;QAKAC,Q,GAAAA,Q;QAIAC,O,GAAAA,O;;AA5ChB;;AAEA;AACO,SAASJ,eAAT,CAAyBK,IAAzB,EAA+C;AACpD,MAAIA,SAAS,CAAb,EAAgB;AACd,UAAM,IAAIC,KAAJ,CAAU,yCAAV,CAAN;AACD;AACD,MAAID,OAAO,CAAP,KAAa,CAAjB,EAAoB;AAClB,UAAM,IAAIC,KAAJ,CAAU,8CAAV,CAAN;AACD;AACD,SAAO,yBAAYD,OAAO,CAAnB,EAAsBE,QAAtB,CAA+B,KAA/B,CAAP;AACD;;AAED;AACA;AACA;AACA;AACA;AACA;;;AACO,SAASN,YAAT,CAAsBI,IAAtB,EAA4C;AACjD,MAAIA,SAAS,CAAb,EAAgB;AACd,UAAM,IAAIC,KAAJ,CAAU,sCAAV,CAAN;AACD;AACD,QAAME,QAAS,+BACF,4BADE,GAEF,YAFb;AAGA,MAAIC,WAAW,EAAf;AACA,QAAMC,QAAQ,yBAAYL,IAAZ,CAAd;AACA,OAAK,IAAIM,IAAI,CAAb,EAAgBA,IAAID,MAAME,MAA1B,EAAkC,EAAED,CAApC,EAAuC;AACrCF,gBAAYD,MAAME,MAAMG,SAAN,CAAgBF,CAAhB,IAAqBH,MAAMI,MAAjC,CAAZ;AACD;AACD,SAAOH,QAAP;AACD;;AAED;AACO,SAASP,WAAT,CAAqBG,OAAe,EAApC,EAAgD;AACrD,SAAOJ,aAAaI,IAAb,CAAP;AACD;;AAED;AACO,SAASF,QAAT,GAA4B;AACjC,SAAOH,gBAAgB,EAAhB,CAAP;AACD;;AAEM,SAASI,OAAT,CAAiBU,MAAjB,EAAyC;AAC9C,SAAO,wBAAW,KAAX,EAAkBC,MAAlB,CAAyBD,MAAzB,EAAiCE,MAAjC,CAAwC,KAAxC,CAAP;AACD","file":"cryptoUtils.js","sourcesContent":["/* @flow */\n\nimport { randomBytes, createHash } from 'crypto';\n\n// Returns a new random hex string of the given even size.\nexport function randomHexString(size: number): string {\n  if (size === 0) {\n    throw new Error('Zero-length randomHexString is useless.');\n  }\n  if (size % 2 !== 0) {\n    throw new Error('randomHexString size must be divisible by 2.')\n  }\n  return randomBytes(size / 2).toString('hex');\n}\n\n// Returns a new random alphanumeric string of the given size.\n//\n// Note: to simplify implementation, the result has slight modulo bias,\n// because chars length of 62 doesn't divide the number of all bytes\n// (256) evenly. Such bias is acceptable for most cases when the output\n// length is long enough and doesn't need to be uniform.\nexport function randomString(size: number): string {\n  if (size === 0) {\n    throw new Error('Zero-length randomString is useless.');\n  }\n  const chars = ('ABCDEFGHIJKLMNOPQRSTUVWXYZ' +\n               'abcdefghijklmnopqrstuvwxyz' +\n               '0123456789');\n  let objectId = '';\n  const bytes = randomBytes(size);\n  for (let i = 0; i < bytes.length; ++i) {\n    objectId += chars[bytes.readUInt8(i) % chars.length];\n  }\n  return objectId;\n}\n\n// Returns a new random alphanumeric string suitable for object ID.\nexport function newObjectId(size: number = 10): string {\n  return randomString(size);\n}\n\n// Returns a new random hex string suitable for secure tokens.\nexport function newToken(): string {\n  return randomHexString(32);\n}\n\nexport function md5Hash(string: string): string {\n  return createHash('md5').update(string).digest('hex');\n}\n"]}