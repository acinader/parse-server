{"version":3,"sources":["../src/batch.js"],"names":["Parse","require","url","path","batchPath","mountOnto","router","route","req","handleBatch","parseURL","URL","parse","undefined","makeBatchRoutingPathFunction","originalUrl","serverURL","publicServerURL","apiPrefixLength","length","apiPrefix","slice","makeRoutablePath","requestPath","Error","INVALID_JSON","posix","join","localPath","publicPath","newPath","Array","isArray","body","requests","endsWith","config","promises","map","restRequest","routablePath","request","auth","info","tryRouteRequest","method","then","response","success","error","code","message","Promise","all","results","module","exports"],"mappings":"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","file":"batch.js","sourcesContent":["const Parse = require('parse/node').Parse;\nconst url = require('url');\nconst path = require('path');\n// These methods handle batch requests.\nconst batchPath = '/batch';\n\n// Mounts a batch-handler onto a PromiseRouter.\nfunction mountOnto(router) {\n  router.route('POST', batchPath, (req) => {\n    return handleBatch(router, req);\n  });\n}\n\nfunction parseURL(URL) {\n  if (typeof URL === 'string') {\n    return url.parse(URL)\n  }\n  return undefined;\n}\n\nfunction makeBatchRoutingPathFunction(originalUrl, serverURL, publicServerURL) {\n  serverURL = serverURL ? parseURL(serverURL) : undefined;\n  publicServerURL = publicServerURL ? parseURL(publicServerURL) : undefined;\n\n  const apiPrefixLength = originalUrl.length - batchPath.length;\n  let apiPrefix = originalUrl.slice(0, apiPrefixLength);\n\n  const makeRoutablePath = function(requestPath) {\n    // The routablePath is the path minus the api prefix\n    if (requestPath.slice(0, apiPrefix.length) != apiPrefix) {\n      throw new Parse.Error(\n        Parse.Error.INVALID_JSON,\n        'cannot route batch path ' + requestPath);\n    }\n    return path.posix.join('/', requestPath.slice(apiPrefix.length));\n  }\n\n  if (serverURL && publicServerURL\n        && (serverURL.path != publicServerURL.path)) {\n    const localPath = serverURL.path;\n    const publicPath = publicServerURL.path;\n    // Override the api prefix\n    apiPrefix = localPath;\n    return function(requestPath) {\n      // Build the new path by removing the public path\n      // and joining with the local path\n      const newPath = path.posix.join('/', localPath, '/' , requestPath.slice(publicPath.length));\n      // Use the method for local routing\n      return makeRoutablePath(newPath);\n    }\n  }\n\n  return makeRoutablePath;\n}\n\n// Returns a promise for a {response} object.\n// TODO: pass along auth correctly\nfunction handleBatch(router, req) {\n  if (!Array.isArray(req.body.requests)) {\n    throw new Parse.Error(Parse.Error.INVALID_JSON,\n      'requests must be an array');\n  }\n\n  // The batch paths are all from the root of our domain.\n  // That means they include the API prefix, that the API is mounted\n  // to. However, our promise router does not route the api prefix. So\n  // we need to figure out the API prefix, so that we can strip it\n  // from all the subrequests.\n  if (!req.originalUrl.endsWith(batchPath)) {\n    throw 'internal routing problem - expected url to end with batch';\n  }\n\n  const makeRoutablePath = makeBatchRoutingPathFunction(req.originalUrl, req.config.serverURL, req.config.publicServerURL);\n\n  const promises = req.body.requests.map((restRequest) => {\n    const routablePath = makeRoutablePath(restRequest.path);\n    // Construct a request that we can send to a handler\n    const request = {\n      body: restRequest.body,\n      config: req.config,\n      auth: req.auth,\n      info: req.info\n    };\n\n    return router.tryRouteRequest(restRequest.method, routablePath, request).then((response) => {\n      return {success: response.response};\n    }, (error) => {\n      return {error: {code: error.code, error: error.message}};\n    });\n  });\n\n  return Promise.all(promises).then((results) => {\n    return {response: results};\n  });\n}\n\nmodule.exports = {\n  mountOnto,\n  makeBatchRoutingPathFunction\n};\n"]}