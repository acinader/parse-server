{"version":3,"sources":["../src/PromiseRouter.js"],"names":["Layer","require","validateParameter","key","value","match","PromiseRouter","constructor","routes","appId","mountRoutes","merge","router","route","push","method","path","handlers","handler","length","req","reduce","promise","then","Promise","resolve","layer","params","Object","keys","forEach","mountOnto","expressApp","toLowerCase","makeExpressHandler","call","expressRouter","express","Router","tryRouteRequest","request","Parse","Error","INVALID_JSON","reject","promiseHandler","res","next","url","maskSensitiveUrl","body","assign","headers","log","logRequest","result","response","location","text","error","logResponse","status","send","set","header","json","e","maskUrl","originalUrl","toString","shouldMaskUrl","includes"],"mappings":";;;;;;AAOA;;;;AACA;;;;AACA;;;;AACA;;;;AAVA;AACA;AACA;AACA;AACA;AACA;;AAMA,MAAMA,QAAQC,QAAQ,0BAAR,CAAd;;AAEA,SAASC,iBAAT,CAA2BC,GAA3B,EAAgCC,KAAhC,EAAuC;AACrC,MAAID,OAAO,WAAX,EAAwB;AACtB,QAAIC,MAAMC,KAAN,CAAY,yBAAZ,CAAJ,EAA4C;AAC1C,aAAOD,KAAP;AACD;AACF,GAJD,MAIO,IAAID,OAAO,UAAX,EAAuB;AAC5B,QAAIC,MAAMC,KAAN,CAAY,cAAZ,CAAJ,EAAiC;AAC/B,aAAOD,KAAP;AACD;AACF,GAJM,MAIA;AACL,WAAOA,KAAP;AACD;AACF;;AAGc,MAAME,aAAN,CAAoB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,cAAYC,SAAS,EAArB,EAAyBC,KAAzB,EAAgC;AAC9B,SAAKD,MAAL,GAAcA,MAAd;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,WAAL;AACD;;AAED;AACA;AACAA,gBAAc,CAAE;;AAEhB;AACAC,QAAMC,MAAN,EAAc;AACZ,SAAK,IAAIC,KAAT,IAAkBD,OAAOJ,MAAzB,EAAiC;AAC/B,WAAKA,MAAL,CAAYM,IAAZ,CAAiBD,KAAjB;AACD;AACF;;AAEDA,QAAME,MAAN,EAAcC,IAAd,EAAoB,GAAGC,QAAvB,EAAiC;AAC/B,YAAOF,MAAP;AACA,WAAK,MAAL;AACA,WAAK,KAAL;AACA,WAAK,KAAL;AACA,WAAK,QAAL;AACE;AACF;AACE,cAAM,0BAA0BA,MAAhC;AAPF;;AAUA,QAAIG,UAAUD,SAAS,CAAT,CAAd;;AAEA,QAAIA,SAASE,MAAT,GAAkB,CAAtB,EAAyB;AACvBD,gBAAU,UAASE,GAAT,EAAc;AACtB,eAAOH,SAASI,MAAT,CAAgB,CAACC,OAAD,EAAUJ,OAAV,KAAsB;AAC3C,iBAAOI,QAAQC,IAAR,CAAa,MAAM;AACxB,mBAAOL,QAAQE,GAAR,CAAP;AACD,WAFM,CAAP;AAGD,SAJM,EAIJI,QAAQC,OAAR,EAJI,CAAP;AAKD,OAND;AAOD;;AAED,SAAKjB,MAAL,CAAYM,IAAZ,CAAiB;AACfE,YAAMA,IADS;AAEfD,cAAQA,MAFO;AAGfG,eAASA,OAHM;AAIfQ,aAAO,IAAI1B,KAAJ,CAAUgB,IAAV,EAAgB,IAAhB,EAAsBE,OAAtB;AAJQ,KAAjB;AAMD;;AAED;AACA;AACA;AACA;AACAb,QAAMU,MAAN,EAAcC,IAAd,EAAoB;AAClB,SAAK,IAAIH,KAAT,IAAkB,KAAKL,MAAvB,EAA+B;AAC7B,UAAIK,MAAME,MAAN,IAAgBA,MAApB,EAA4B;AAC1B;AACD;AACD,YAAMW,QAAQb,MAAMa,KAAN,IAAe,IAAI1B,KAAJ,CAAUa,MAAMG,IAAhB,EAAsB,IAAtB,EAA4BH,MAAMK,OAAlC,CAA7B;AACA,YAAMb,QAAQqB,MAAMrB,KAAN,CAAYW,IAAZ,CAAd;AACA,UAAIX,KAAJ,EAAW;AACT,cAAMsB,SAASD,MAAMC,MAArB;AACAC,eAAOC,IAAP,CAAYF,MAAZ,EAAoBG,OAApB,CAA6B3B,GAAD,IAAS;AACnCwB,iBAAOxB,GAAP,IAAcD,kBAAkBC,GAAlB,EAAuBwB,OAAOxB,GAAP,CAAvB,CAAd;AACD,SAFD;AAGA,eAAO,EAACwB,QAAQA,MAAT,EAAiBT,SAASL,MAAMK,OAAhC,EAAP;AACD;AACF;AACF;;AAED;AACAa,YAAUC,UAAV,EAAsB;AACpB,SAAKxB,MAAL,CAAYsB,OAAZ,CAAqBjB,KAAD,IAAW;AAC7B,YAAME,SAASF,MAAME,MAAN,CAAakB,WAAb,EAAf;AACA,YAAMf,UAAUgB,mBAAmB,KAAKzB,KAAxB,EAA+BI,MAAMK,OAArC,CAAhB;AACAc,iBAAWjB,MAAX,EAAmBoB,IAAnB,CAAwBH,UAAxB,EAAoCnB,MAAMG,IAA1C,EAAgDE,OAAhD;AACD,KAJD;AAKA,WAAOc,UAAP;AACD;;AAEDI,kBAAgB;AACd,WAAO,KAAKL,SAAL,CAAeM,kBAAQC,MAAR,EAAf,CAAP;AACD;;AAEDC,kBAAgBxB,MAAhB,EAAwBC,IAAxB,EAA8BwB,OAA9B,EAAuC;AACrC,QAAInC,QAAQ,KAAKA,KAAL,CAAWU,MAAX,EAAmBC,IAAnB,CAAZ;AACA,QAAI,CAACX,KAAL,EAAY;AACV,YAAM,IAAIoC,eAAMC,KAAV,CACJD,eAAMC,KAAN,CAAYC,YADR,EAEJ,kBAAkB5B,MAAlB,GAA2B,GAA3B,GAAiCC,IAF7B,CAAN;AAGD;AACDwB,YAAQb,MAAR,GAAiBtB,MAAMsB,MAAvB;AACA,WAAO,IAAIH,OAAJ,CAAY,CAACC,OAAD,EAAUmB,MAAV,KAAqB;AACtCvC,YAAMa,OAAN,CAAcsB,OAAd,EAAuBjB,IAAvB,CAA4BE,OAA5B,EAAqCmB,MAArC;AACD,KAFM,CAAP;AAGD;AAxGgC;;kBAAdtC,a,EA2GrB;AACA;AACA;AACA;;AACA,SAAS4B,kBAAT,CAA4BzB,KAA5B,EAAmCoC,cAAnC,EAAmD;AACjD,SAAO,UAASzB,GAAT,EAAc0B,GAAd,EAAmBC,IAAnB,EAAyB;AAC9B,QAAI;AACF,YAAMC,MAAMC,iBAAiB7B,GAAjB,CAAZ;AACA,YAAM8B,OAAOtB,OAAOuB,MAAP,CAAc,EAAd,EAAkB/B,IAAI8B,IAAtB,CAAb;AACA,YAAMnC,SAASK,IAAIL,MAAnB;AACA,YAAMqC,UAAUhC,IAAIgC,OAApB;AACAC,uBAAIC,UAAJ,CAAe;AACbvC,cADa;AAEbiC,WAFa;AAGbI,eAHa;AAIbF;AAJa,OAAf;AAMAL,qBAAezB,GAAf,EAAoBG,IAApB,CAA0BgC,MAAD,IAAY;AACnC,YAAI,CAACA,OAAOC,QAAR,IAAoB,CAACD,OAAOE,QAA5B,IAAwC,CAACF,OAAOG,IAApD,EAA0D;AACxDL,2BAAIM,KAAJ,CAAU,gEAAV;AACA,gBAAM,6BAAN;AACD;;AAEDN,yBAAIO,WAAJ,CAAgB,EAAE7C,MAAF,EAAUiC,GAAV,EAAeO,MAAf,EAAhB;;AAEA,YAAIM,SAASN,OAAOM,MAAP,IAAiB,GAA9B;AACAf,YAAIe,MAAJ,CAAWA,MAAX;;AAEA,YAAIN,OAAOG,IAAX,EAAiB;AACfZ,cAAIgB,IAAJ,CAASP,OAAOG,IAAhB;AACA;AACD;;AAED,YAAIH,OAAOE,QAAX,EAAqB;AACnBX,cAAIiB,GAAJ,CAAQ,UAAR,EAAoBR,OAAOE,QAA3B;AACA;AACA;AACA,cAAI,CAACF,OAAOC,QAAZ,EAAsB;AACpBV,gBAAIgB,IAAJ,CAAS,2BAA2BP,OAAOE,QAA3C;AACA;AACD;AACF;AACD,YAAIF,OAAOH,OAAX,EAAoB;AAClBxB,iBAAOC,IAAP,CAAY0B,OAAOH,OAAnB,EAA4BtB,OAA5B,CAAqCkC,MAAD,IAAY;AAC9ClB,gBAAIiB,GAAJ,CAAQC,MAAR,EAAgBT,OAAOH,OAAP,CAAeY,MAAf,CAAhB;AACD,WAFD;AAGD;AACDlB,YAAImB,IAAJ,CAASV,OAAOC,QAAhB;AACD,OA/BD,EA+BIU,CAAD,IAAO;AACRb,yBAAIM,KAAJ,CAAW,8BAA6B,mBAAQO,CAAR,CAAW,EAAnD,EAAsD,EAACP,OAAOO,CAAR,EAAtD;AACAnB,aAAKmB,CAAL;AACD,OAlCD;AAmCD,KA9CD,CA8CE,OAAOA,CAAP,EAAU;AACVb,uBAAIM,KAAJ,CAAW,2BAA0B,mBAAQO,CAAR,CAAW,EAAhD,EAAmD,EAACP,OAAOO,CAAR,EAAnD;AACAnB,WAAKmB,CAAL;AACD;AACF,GAnDD;AAoDD;;AAGD,SAASjB,gBAAT,CAA0B7B,GAA1B,EAA+B;AAC7B,MAAI+C,UAAU/C,IAAIgD,WAAJ,CAAgBC,QAAhB,EAAd;AACA,QAAMC,gBAAgBlD,IAAIL,MAAJ,KAAe,KAAf,IAAwBK,IAAIgD,WAAJ,CAAgBG,QAAhB,CAAyB,QAAzB,CAAxB,IACC,CAACnD,IAAIgD,WAAJ,CAAgBG,QAAhB,CAAyB,SAAzB,CADxB;AAEA,MAAID,aAAJ,EAAmB;AACjBH,cAAUd,iBAAIJ,gBAAJ,CAAqBkB,OAArB,CAAV;AACD;AACD,SAAOA,OAAP;AACD","file":"PromiseRouter.js","sourcesContent":["// A router that is based on promises rather than req/res/next.\n// This is intended to replace the use of express.Router to handle\n// subsections of the API surface.\n// This will make it easier to have methods like 'batch' that\n// themselves use our routing information, without disturbing express\n// components that external developers may be modifying.\n\nimport Parse     from 'parse/node';\nimport express   from 'express';\nimport log       from './logger';\nimport {inspect} from 'util';\nconst Layer = require('express/lib/router/layer');\n\nfunction validateParameter(key, value) {\n  if (key == 'className') {\n    if (value.match(/_?[A-Za-z][A-Za-z_0-9]*/)) {\n      return value;\n    }\n  } else if (key == 'objectId') {\n    if (value.match(/[A-Za-z0-9]+/)) {\n      return value;\n    }\n  } else {\n    return value;\n  }\n}\n\n\nexport default class PromiseRouter {\n  // Each entry should be an object with:\n  // path: the path to route, in express format\n  // method: the HTTP method that this route handles.\n  //   Must be one of: POST, GET, PUT, DELETE\n  // handler: a function that takes request, and returns a promise.\n  //   Successful handlers should resolve to an object with fields:\n  //     status: optional. the http status code. defaults to 200\n  //     response: a json object with the content of the response\n  //     location: optional. a location header\n  constructor(routes = [], appId) {\n    this.routes = routes;\n    this.appId = appId;\n    this.mountRoutes();\n  }\n\n  // Leave the opportunity to\n  // subclasses to mount their routes by overriding\n  mountRoutes() {}\n\n  // Merge the routes into this one\n  merge(router) {\n    for (var route of router.routes) {\n      this.routes.push(route);\n    }\n  }\n\n  route(method, path, ...handlers) {\n    switch(method) {\n    case 'POST':\n    case 'GET':\n    case 'PUT':\n    case 'DELETE':\n      break;\n    default:\n      throw 'cannot route method: ' + method;\n    }\n\n    let handler = handlers[0];\n\n    if (handlers.length > 1) {\n      handler = function(req) {\n        return handlers.reduce((promise, handler) => {\n          return promise.then(() => {\n            return handler(req);\n          });\n        }, Promise.resolve());\n      }\n    }\n\n    this.routes.push({\n      path: path,\n      method: method,\n      handler: handler,\n      layer: new Layer(path, null, handler)\n    });\n  }\n\n  // Returns an object with:\n  //   handler: the handler that should deal with this request\n  //   params: any :-params that got parsed from the path\n  // Returns undefined if there is no match.\n  match(method, path) {\n    for (var route of this.routes) {\n      if (route.method != method) {\n        continue;\n      }\n      const layer = route.layer || new Layer(route.path, null, route.handler);\n      const match = layer.match(path);\n      if (match) {\n        const params = layer.params;\n        Object.keys(params).forEach((key) => {\n          params[key] = validateParameter(key, params[key]);\n        });\n        return {params: params, handler: route.handler};\n      }\n    }\n  }\n\n  // Mount the routes on this router onto an express app (or express router)\n  mountOnto(expressApp) {\n    this.routes.forEach((route) => {\n      const method = route.method.toLowerCase();\n      const handler = makeExpressHandler(this.appId, route.handler);\n      expressApp[method].call(expressApp, route.path, handler);\n    });\n    return expressApp;\n  }\n\n  expressRouter() {\n    return this.mountOnto(express.Router());\n  }\n\n  tryRouteRequest(method, path, request) {\n    var match = this.match(method, path);\n    if (!match) {\n      throw new Parse.Error(\n        Parse.Error.INVALID_JSON,\n        'cannot route ' + method + ' ' + path);\n    }\n    request.params = match.params;\n    return new Promise((resolve, reject) => {\n      match.handler(request).then(resolve, reject);\n    });\n  }\n}\n\n// A helper function to make an express handler out of a a promise\n// handler.\n// Express handlers should never throw; if a promise handler throws we\n// just treat it like it resolved to an error.\nfunction makeExpressHandler(appId, promiseHandler) {\n  return function(req, res, next) {\n    try {\n      const url = maskSensitiveUrl(req);\n      const body = Object.assign({}, req.body);\n      const method = req.method;\n      const headers = req.headers;\n      log.logRequest({\n        method,\n        url,\n        headers,\n        body\n      });\n      promiseHandler(req).then((result) => {\n        if (!result.response && !result.location && !result.text) {\n          log.error('the handler did not include a \"response\" or a \"location\" field');\n          throw 'control should not get here';\n        }\n\n        log.logResponse({ method, url, result });\n\n        var status = result.status || 200;\n        res.status(status);\n\n        if (result.text) {\n          res.send(result.text);\n          return;\n        }\n\n        if (result.location) {\n          res.set('Location', result.location);\n          // Override the default expressjs response\n          // as it double encodes %encoded chars in URL\n          if (!result.response) {\n            res.send('Found. Redirecting to ' + result.location);\n            return;\n          }\n        }\n        if (result.headers) {\n          Object.keys(result.headers).forEach((header) => {\n            res.set(header, result.headers[header]);\n          })\n        }\n        res.json(result.response);\n      }, (e) => {\n        log.error(`Error generating response. ${inspect(e)}`, {error: e});\n        next(e);\n      });\n    } catch (e) {\n      log.error(`Error handling request: ${inspect(e)}`, {error: e});\n      next(e);\n    }\n  }\n}\n\n\nfunction maskSensitiveUrl(req) {\n  let maskUrl = req.originalUrl.toString();\n  const shouldMaskUrl = req.method === 'GET' && req.originalUrl.includes('/login')\n                      && !req.originalUrl.includes('classes');\n  if (shouldMaskUrl) {\n    maskUrl = log.maskSensitiveUrl(maskUrl);\n  }\n  return maskUrl;\n}\n"]}