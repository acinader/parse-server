{"version":3,"sources":["../../src/Controllers/DatabaseController.js"],"names":["SchemaController","addWriteACL","query","acl","newQuery","_","cloneDeep","_wperm","addReadACL","_rperm","transformObjectACL","ACL","result","entry","read","push","write","specialQuerykeys","isSpecialQueryKey","key","indexOf","validateQuery","Parse","Error","INVALID_QUERY","$or","Array","forEach","Object","keys","noCollisions","some","subq","hasOwnProperty","hasNears","subquery","$and","$nor","length","$regex","$options","match","INVALID_KEY_NAME","filterSensitiveData","isMaster","aclGroup","className","object","password","_hashed_password","sessionToken","_email_verify_token","_perishable_token","_perishable_token_expires_at","_tombstone","_email_verify_token_expires_at","_failed_login_count","_account_lockout_expires_at","_password_changed_at","_password_history","objectId","authData","specialKeysForUpdate","isSpecialUpdateKey","expandResultOnKeyPath","value","path","split","firstKey","nextPath","slice","join","sanitizeDatabaseResult","originalObject","response","Promise","resolve","keyUpdate","__op","joinTableName","flattenUpdateOperatorsForCreate","amount","INVALID_JSON","objects","COMMAND_UNAVAILABLE","transformAuthData","schema","provider","providerData","fieldName","fields","type","untransformObjectACL","output","getRootFieldName","relationSchema","relatedId","owningId","DatabaseController","constructor","adapter","schemaCache","schemaPromise","collectionExists","classExists","purgeCollection","loadSchema","then","schemaController","getOneSchema","deleteObjectsByQuery","validateClassName","classNameIsValid","reject","INVALID_CLASS_NAME","options","clearCache","load","redirectClassNameForKey","t","getExpectedType","targetClass","validateObject","undefined","s","canAddField","update","many","upsert","skipSanitization","originalQuery","originalUpdate","relationUpdates","validatePermission","collectRelationUpdates","addPointerPermissions","catch","error","rootFieldName","fieldNameIsValid","updateOperation","innerKey","includes","INVALID_NESTED_KEY","updateObjectsByQuery","upsertOneObject","findOneAndUpdate","OBJECT_NOT_FOUND","handleRelationUpdates","ops","deleteMe","process","op","x","pending","addRelation","removeRelation","all","fromClassName","fromId","toId","doc","code","destroy","parseFormatSchema","create","createdAt","iso","__type","updatedAt","enforceClassExists","reloadData","createObject","convertSchemaToAdapterSchema","classSchema","data","schemaFields","newKeys","filter","field","deleteEverything","dropDatabase","clear","relatedIds","queryOptions","skip","limit","sort","findOptions","canSortOnJoinTables","find","results","map","owningIds","reduceInRelation","ors","aQuery","index","promises","queries","constraintKey","isNegation","r","q","ids","addNotInObjectIdsIds","addInObjectIdsIds","reduceRelationKeys","relatedTo","idsFromString","idsFromEq","idsFromIn","allIds","list","totalLength","reduce","memo","idsIntersection","intersect","big","$in","$eq","idsFromNin","Set","$nin","count","distinct","pipeline","readPreference","isWrite","_created_at","_updated_at","aggregate","INTERNAL_SERVER_ERROR","deleteSchema","deleteClass","wasParseCollection","relationFieldNames","name","operation","testBaseCLP","perms","userACL","userId","userPointer","permFields","assign","performInitialization","requiredUserFields","defaultColumns","_Default","_User","requiredRoleFields","_Role","userClassPromise","roleClassPromise","usernameUniqueness","ensureUniqueness","logger","warn","emailUniqueness","roleUniqueness","indexPromise","updateSchemaWithIndexes","adapterInit","VolatileClassesSchemas","module","exports","_validateQuery"],"mappings":"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","file":"DatabaseController.js","sourcesContent":["﻿// @flow\n// A database adapter that works with data exported from the hosted\n// Parse database.\n\n// @flow-disable-next\nimport { Parse }              from 'parse/node';\n// @flow-disable-next\nimport _                      from 'lodash';\n// @flow-disable-next\nimport intersect              from 'intersect';\n// @flow-disable-next\nimport deepcopy               from 'deepcopy';\nimport logger                 from '../logger';\nimport * as SchemaController       from './SchemaController';\nimport { StorageAdapter }     from '../Adapters/Storage/StorageAdapter';\nimport type { QueryOptions,\n  FullQueryOptions }          from '../Adapters/Storage/StorageAdapter';\n\nfunction addWriteACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_wperm' query, we don't allow client queries on that, no need to $and\n  newQuery._wperm = { \"$in\" : [null, ...acl]};\n  return newQuery;\n}\n\nfunction addReadACL(query, acl) {\n  const newQuery = _.cloneDeep(query);\n  //Can't be any existing '_rperm' query, we don't allow client queries on that, no need to $and\n  newQuery._rperm = {\"$in\": [null, \"*\", ...acl]};\n  return newQuery;\n}\n\n// Transforms a REST API formatted ACL object to our two-field mongo format.\nconst transformObjectACL = ({ ACL, ...result }) => {\n  if (!ACL) {\n    return result;\n  }\n\n  result._wperm = [];\n  result._rperm = [];\n\n  for (const entry in ACL) {\n    if (ACL[entry].read) {\n      result._rperm.push(entry);\n    }\n    if (ACL[entry].write) {\n      result._wperm.push(entry);\n    }\n  }\n  return result;\n}\n\nconst specialQuerykeys = ['$and', '$or', '$nor', '_rperm', '_wperm', '_perishable_token', '_email_verify_token', '_email_verify_token_expires_at', '_account_lockout_expires_at', '_failed_login_count'];\n\nconst isSpecialQueryKey = key => {\n  return specialQuerykeys.indexOf(key) >= 0;\n}\n\nconst validateQuery = (query: any): void => {\n  if (query.ACL) {\n    throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Cannot query on ACL.');\n  }\n\n  if (query.$or) {\n    if (query.$or instanceof Array) {\n      query.$or.forEach(validateQuery);\n\n      /* In MongoDB, $or queries which are not alone at the top level of the\n       * query can not make efficient use of indexes due to a long standing\n       * bug known as SERVER-13732.\n       *\n       * This block restructures queries in which $or is not the sole top\n       * level element by moving all other top-level predicates inside every\n       * subdocument of the $or predicate, allowing MongoDB's query planner\n       * to make full use of the most relevant indexes.\n       *\n       * EG:      {$or: [{a: 1}, {a: 2}], b: 2}\n       * Becomes: {$or: [{a: 1, b: 2}, {a: 2, b: 2}]}\n       *\n       * The only exceptions are $near and $nearSphere operators, which are\n       * constrained to only 1 operator per query. As a result, these ops\n       * remain at the top level\n       *\n       * https://jira.mongodb.org/browse/SERVER-13732\n       * https://github.com/parse-community/parse-server/issues/3767\n       */\n      Object.keys(query).forEach(key => {\n        const noCollisions = !query.$or.some(subq => subq.hasOwnProperty(key))\n        let hasNears = false\n        if (query[key] != null && typeof query[key] == 'object') {\n          hasNears = ('$near' in query[key] || '$nearSphere' in query[key])\n        }\n        if (key != '$or' && noCollisions && !hasNears) {\n          query.$or.forEach(subquery => {\n            subquery[key] = query[key];\n          });\n          delete query[key];\n        }\n      });\n      query.$or.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $or format - use an array value.');\n    }\n  }\n\n  if (query.$and) {\n    if (query.$and instanceof Array) {\n      query.$and.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $and format - use an array value.');\n    }\n  }\n\n  if (query.$nor) {\n    if (query.$nor instanceof Array && query.$nor.length > 0) {\n      query.$nor.forEach(validateQuery);\n    } else {\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Bad $nor format - use an array of at least 1 value.');\n    }\n  }\n\n  Object.keys(query).forEach(key => {\n    if (query && query[key] && query[key].$regex) {\n      if (typeof query[key].$options === 'string') {\n        if (!query[key].$options.match(/^[imxs]+$/)) {\n          throw new Parse.Error(Parse.Error.INVALID_QUERY, `Bad $options value for query: ${query[key].$options}`);\n        }\n      }\n    }\n    if (!isSpecialQueryKey(key) && !key.match(/^[a-zA-Z][a-zA-Z0-9_\\.]*$/)) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Invalid key name: ${key}`);\n    }\n  });\n}\n\n// Filters out any data that shouldn't be on this REST-formatted object.\nconst filterSensitiveData = (isMaster, aclGroup, className, object) => {\n  if (className !== '_User') {\n    return object;\n  }\n\n  object.password = object._hashed_password;\n  delete object._hashed_password;\n\n  delete object.sessionToken;\n\n  if (isMaster) {\n    return object;\n  }\n  delete object._email_verify_token;\n  delete object._perishable_token;\n  delete object._perishable_token_expires_at;\n  delete object._tombstone;\n  delete object._email_verify_token_expires_at;\n  delete object._failed_login_count;\n  delete object._account_lockout_expires_at;\n  delete object._password_changed_at;\n  delete object._password_history;\n\n  if ((aclGroup.indexOf(object.objectId) > -1)) {\n    return object;\n  }\n  delete object.authData;\n  return object;\n};\n\nimport type { LoadSchemaOptions } from './types';\n\n// Runs an update on the database.\n// Returns a promise for an object with the new values for field\n// modifications that don't know their results ahead of time, like\n// 'increment'.\n// Options:\n//   acl:  a list of strings. If the object to be updated has an ACL,\n//         one of the provided strings must provide the caller with\n//         write permissions.\nconst specialKeysForUpdate = ['_hashed_password', '_perishable_token', '_email_verify_token', '_email_verify_token_expires_at', '_account_lockout_expires_at', '_failed_login_count', '_perishable_token_expires_at', '_password_changed_at', '_password_history'];\n\nconst isSpecialUpdateKey = key => {\n  return specialKeysForUpdate.indexOf(key) >= 0;\n}\n\nfunction expandResultOnKeyPath(object, key, value) {\n  if (key.indexOf('.') < 0) {\n    object[key] = value[key];\n    return object;\n  }\n  const path = key.split('.');\n  const firstKey = path[0];\n  const nextPath = path.slice(1).join('.');\n  object[firstKey] = expandResultOnKeyPath(object[firstKey] || {}, nextPath, value[firstKey]);\n  delete object[key];\n  return object;\n}\n\nfunction sanitizeDatabaseResult(originalObject, result): Promise<any> {\n  const response = {};\n  if (!result) {\n    return Promise.resolve(response);\n  }\n  Object.keys(originalObject).forEach(key => {\n    const keyUpdate = originalObject[key];\n    // determine if that was an op\n    if (keyUpdate && typeof keyUpdate === 'object' && keyUpdate.__op\n      && ['Add', 'AddUnique', 'Remove', 'Increment'].indexOf(keyUpdate.__op) > -1) {\n      // only valid ops that produce an actionable result\n      // the op may have happend on a keypath\n      expandResultOnKeyPath(response, key, result);\n    }\n  });\n  return Promise.resolve(response);\n}\n\nfunction joinTableName(className, key) {\n  return `_Join:${key}:${className}`;\n}\n\nconst flattenUpdateOperatorsForCreate = object => {\n  for (const key in object) {\n    if (object[key] && object[key].__op) {\n      switch (object[key].__op) {\n      case 'Increment':\n        if (typeof object[key].amount !== 'number') {\n          throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n        }\n        object[key] = object[key].amount;\n        break;\n      case 'Add':\n        if (!(object[key].objects instanceof Array)) {\n          throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n        }\n        object[key] = object[key].objects;\n        break;\n      case 'AddUnique':\n        if (!(object[key].objects instanceof Array)) {\n          throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n        }\n        object[key] = object[key].objects;\n        break;\n      case 'Remove':\n        if (!(object[key].objects instanceof Array)) {\n          throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n        }\n        object[key] = []\n        break;\n      case 'Delete':\n        delete object[key];\n        break;\n      default:\n        throw new Parse.Error(Parse.Error.COMMAND_UNAVAILABLE, `The ${object[key].__op} operator is not supported yet.`);\n      }\n    }\n  }\n}\n\nconst transformAuthData = (className, object, schema) => {\n  if (object.authData && className === '_User') {\n    Object.keys(object.authData).forEach(provider => {\n      const providerData = object.authData[provider];\n      const fieldName = `_auth_data_${provider}`;\n      if (providerData == null) {\n        object[fieldName] = {\n          __op: 'Delete'\n        }\n      } else {\n        object[fieldName] = providerData;\n        schema.fields[fieldName] = { type: 'Object' }\n      }\n    });\n    delete object.authData;\n  }\n}\n// Transforms a Database format ACL to a REST API format ACL\nconst untransformObjectACL = ({_rperm, _wperm, ...output}) => {\n  if (_rperm || _wperm) {\n    output.ACL = {};\n\n    (_rperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { read: true };\n      } else {\n        output.ACL[entry]['read'] = true;\n      }\n    });\n\n    (_wperm || []).forEach(entry => {\n      if (!output.ACL[entry]) {\n        output.ACL[entry] = { write: true };\n      } else {\n        output.ACL[entry]['write'] = true;\n      }\n    });\n  }\n  return output;\n}\n\n/**\n * When querying, the fieldName may be compound, extract the root fieldName\n *     `temperature.celsius` becomes `temperature`\n * @param {string} fieldName that may be a compound field name\n * @returns {string} the root name of the field\n */\nconst getRootFieldName = (fieldName: string): string => {\n  return fieldName.split('.')[0]\n}\n\nconst relationSchema = { fields: { relatedId: { type: 'String' }, owningId: { type: 'String' } } };\n\nclass DatabaseController {\n  adapter: StorageAdapter;\n  schemaCache: any;\n  schemaPromise: ?Promise<SchemaController.SchemaController>;\n\n  constructor(adapter: StorageAdapter, schemaCache: any) {\n    this.adapter = adapter;\n    this.schemaCache = schemaCache;\n    // We don't want a mutable this.schema, because then you could have\n    // one request that uses different schemas for different parts of\n    // it. Instead, use loadSchema to get a schema.\n    this.schemaPromise = null;\n  }\n\n  collectionExists(className: string): Promise<boolean> {\n    return this.adapter.classExists(className);\n  }\n\n  purgeCollection(className: string): Promise<void> {\n    return this.loadSchema()\n      .then(schemaController => schemaController.getOneSchema(className))\n      .then(schema => this.adapter.deleteObjectsByQuery(className, schema, {}));\n  }\n\n  validateClassName(className: string): Promise<void> {\n    if (!SchemaController.classNameIsValid(className)) {\n      return Promise.reject(new Parse.Error(Parse.Error.INVALID_CLASS_NAME, 'invalid className: ' + className));\n    }\n    return Promise.resolve();\n  }\n\n  // Returns a promise for a schemaController.\n  loadSchema(options: LoadSchemaOptions = {clearCache: false}): Promise<SchemaController.SchemaController> {\n    if (this.schemaPromise != null) {\n      return this.schemaPromise;\n    }\n    this.schemaPromise = SchemaController.load(this.adapter, this.schemaCache, options);\n    this.schemaPromise.then(() => delete this.schemaPromise,\n      () => delete this.schemaPromise);\n    return this.loadSchema(options);\n  }\n\n  // Returns a promise for the classname that is related to the given\n  // classname through the key.\n  // TODO: make this not in the DatabaseController interface\n  redirectClassNameForKey(className: string, key: string): Promise<?string> {\n    return this.loadSchema().then((schema) => {\n      var t  = schema.getExpectedType(className, key);\n      if (t != null && typeof t !== 'string' && t.type === 'Relation') {\n        return t.targetClass;\n      }\n      return className;\n    });\n  }\n\n  // Uses the schema to validate the object (REST API format).\n  // Returns a promise that resolves to the new schema.\n  // This does not update this.schema, because in a situation like a\n  // batch request, that could confuse other users of the schema.\n  validateObject(className: string, object: any, query: any, { acl }: QueryOptions): Promise<boolean> {\n    let schema;\n    const isMaster = acl === undefined;\n    var aclGroup: string[]  = acl || [];\n    return this.loadSchema().then(s => {\n      schema = s;\n      if (isMaster) {\n        return Promise.resolve();\n      }\n      return this.canAddField(schema, className, object, aclGroup);\n    }).then(() => {\n      return schema.validateObject(className, object, query);\n    });\n  }\n\n  update(className: string, query: any, update: any, {\n    acl,\n    many,\n    upsert,\n  }: FullQueryOptions = {}, skipSanitization: boolean = false): Promise<any> {\n    const originalQuery = query;\n    const originalUpdate = update;\n    // Make a copy of the object, so we don't mutate the incoming data.\n    update = deepcopy(update);\n    var relationUpdates = [];\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n    return this.loadSchema()\n      .then(schemaController => {\n        return (isMaster ? Promise.resolve() : schemaController.validatePermission(className, aclGroup, 'update'))\n          .then(() => {\n            relationUpdates = this.collectRelationUpdates(className, originalQuery.objectId, update);\n            if (!isMaster) {\n              query = this.addPointerPermissions(schemaController, className, 'update', query, aclGroup);\n            }\n            if (!query) {\n              return Promise.resolve();\n            }\n            if (acl) {\n              query = addWriteACL(query, acl);\n            }\n            validateQuery(query);\n            return schemaController.getOneSchema(className, true)\n              .catch(error => {\n                // If the schema doesn't exist, pretend it exists with no fields. This behavior\n                // will likely need revisiting.\n                if (error === undefined) {\n                  return { fields: {} };\n                }\n                throw error;\n              })\n              .then(schema => {\n                Object.keys(update).forEach(fieldName => {\n                  if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n                    throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Invalid field name for update: ${fieldName}`);\n                  }\n                  const rootFieldName = getRootFieldName(fieldName);\n                  if (!SchemaController.fieldNameIsValid(rootFieldName) && !isSpecialUpdateKey(rootFieldName)) {\n                    throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Invalid field name for update: ${fieldName}`);\n                  }\n                });\n                for (const updateOperation: any in update) {\n                  if (Object.keys(updateOperation).some(innerKey => innerKey.includes('$') || innerKey.includes('.'))) {\n                    throw new Parse.Error(Parse.Error.INVALID_NESTED_KEY, \"Nested keys should not contain the '$' or '.' characters\");\n                  }\n                }\n                update = transformObjectACL(update);\n                transformAuthData(className, update, schema);\n                if (many) {\n                  return this.adapter.updateObjectsByQuery(className, schema, query, update);\n                } else if (upsert) {\n                  return this.adapter.upsertOneObject(className, schema, query, update);\n                } else {\n                  return this.adapter.findOneAndUpdate(className, schema, query, update)\n                }\n              });\n          })\n          .then((result: any) => {\n            if (!result) {\n              throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n            }\n            return this.handleRelationUpdates(className, originalQuery.objectId, update, relationUpdates).then(() => {\n              return result;\n            });\n          }).then((result) => {\n            if (skipSanitization) {\n              return Promise.resolve(result);\n            }\n            return sanitizeDatabaseResult(originalUpdate, result);\n          });\n      });\n  }\n\n  // Collect all relation-updating operations from a REST-format update.\n  // Returns a list of all relation updates to perform\n  // This mutates update.\n  collectRelationUpdates(className: string, objectId: ?string, update: any) {\n    var ops = [];\n    var deleteMe = [];\n    objectId = update.objectId || objectId;\n\n    var process = (op, key) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        ops.push({key, op});\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        ops.push({key, op});\n        deleteMe.push(key);\n      }\n\n      if (op.__op == 'Batch') {\n        for (var x of op.ops) {\n          process(x, key);\n        }\n      }\n    };\n\n    for (const key in update) {\n      process(update[key], key);\n    }\n    for (const key of deleteMe) {\n      delete update[key];\n    }\n    return ops;\n  }\n\n  // Processes relation-updating operations from a REST-format update.\n  // Returns a promise that resolves when all updates have been performed\n  handleRelationUpdates(className: string, objectId: string, update: any, ops: any) {\n    var pending = [];\n    objectId = update.objectId || objectId;\n    ops.forEach(({key, op}) => {\n      if (!op) {\n        return;\n      }\n      if (op.__op == 'AddRelation') {\n        for (const object of op.objects) {\n          pending.push(this.addRelation(key, className,\n            objectId,\n            object.objectId));\n        }\n      }\n\n      if (op.__op == 'RemoveRelation') {\n        for (const object of op.objects) {\n          pending.push(this.removeRelation(key, className,\n            objectId,\n            object.objectId));\n        }\n      }\n    });\n\n    return Promise.all(pending);\n  }\n\n  // Adds a relation.\n  // Returns a promise that resolves successfully iff the add was successful.\n  addRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    const doc = {\n      relatedId: toId,\n      owningId: fromId\n    };\n    return this.adapter.upsertOneObject(`_Join:${key}:${fromClassName}`, relationSchema, doc, doc);\n  }\n\n  // Removes a relation.\n  // Returns a promise that resolves successfully iff the remove was\n  // successful.\n  removeRelation(key: string, fromClassName: string, fromId: string, toId: string) {\n    var doc = {\n      relatedId: toId,\n      owningId: fromId\n    };\n    return this.adapter.deleteObjectsByQuery(`_Join:${key}:${fromClassName}`, relationSchema, doc)\n      .catch(error => {\n        // We don't care if they try to delete a non-existent relation.\n        if (error.code == Parse.Error.OBJECT_NOT_FOUND) {\n          return;\n        }\n        throw error;\n      });\n  }\n\n  // Removes objects matches this query from the database.\n  // Returns a promise that resolves successfully iff the object was\n  // deleted.\n  // Options:\n  //   acl:  a list of strings. If the object to be updated has an ACL,\n  //         one of the provided strings must provide the caller with\n  //         write permissions.\n  destroy(className: string, query: any, { acl }: QueryOptions = {}): Promise<any> {\n    const isMaster = acl === undefined;\n    const aclGroup = acl || [];\n\n    return this.loadSchema()\n      .then(schemaController => {\n        return (isMaster ? Promise.resolve() : schemaController.validatePermission(className, aclGroup, 'delete'))\n          .then(() => {\n            if (!isMaster) {\n              query = this.addPointerPermissions(schemaController, className, 'delete', query, aclGroup);\n              if (!query) {\n                throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n              }\n            }\n            // delete by query\n            if (acl) {\n              query = addWriteACL(query, acl);\n            }\n            validateQuery(query);\n            return schemaController.getOneSchema(className)\n              .catch(error => {\n              // If the schema doesn't exist, pretend it exists with no fields. This behavior\n              // will likely need revisiting.\n                if (error === undefined) {\n                  return { fields: {} };\n                }\n                throw error;\n              })\n              .then(parseFormatSchema => this.adapter.deleteObjectsByQuery(className, parseFormatSchema, query))\n              .catch(error => {\n              // When deleting sessions while changing passwords, don't throw an error if they don't have any sessions.\n                if (className === \"_Session\" && error.code === Parse.Error.OBJECT_NOT_FOUND) {\n                  return Promise.resolve({});\n                }\n                throw error;\n              });\n          });\n      });\n  }\n\n  // Inserts an object into the database.\n  // Returns a promise that resolves successfully iff the object saved.\n  create(className: string, object: any, { acl }: QueryOptions = {}): Promise<any> {\n  // Make a copy of the object, so we don't mutate the incoming data.\n    const originalObject = object;\n    object = transformObjectACL(object);\n\n    object.createdAt = { iso: object.createdAt, __type: 'Date' };\n    object.updatedAt = { iso: object.updatedAt, __type: 'Date' };\n\n    var isMaster = acl === undefined;\n    var aclGroup = acl || [];\n    const relationUpdates = this.collectRelationUpdates(className, null, object);\n    return this.validateClassName(className)\n      .then(() => this.loadSchema())\n      .then(schemaController => {\n        return (isMaster ? Promise.resolve() : schemaController.validatePermission(className, aclGroup, 'create'))\n          .then(() => schemaController.enforceClassExists(className))\n          .then(() => schemaController.reloadData())\n          .then(() => schemaController.getOneSchema(className, true))\n          .then(schema => {\n            transformAuthData(className, object, schema);\n            flattenUpdateOperatorsForCreate(object);\n            return this.adapter.createObject(className, SchemaController.convertSchemaToAdapterSchema(schema), object);\n          })\n          .then(result => {\n            return this.handleRelationUpdates(className, object.objectId, object, relationUpdates).then(() => {\n              return sanitizeDatabaseResult(originalObject, result.ops[0])\n            });\n          });\n      })\n  }\n\n  canAddField(schema: SchemaController.SchemaController, className: string, object: any, aclGroup: string[]): Promise<void> {\n    const classSchema = schema.data[className];\n    if (!classSchema) {\n      return Promise.resolve();\n    }\n    const fields = Object.keys(object);\n    const schemaFields = Object.keys(classSchema);\n    const newKeys = fields.filter((field) => {\n      // Skip fields that are unset\n      if (object[field] && object[field].__op && object[field].__op === 'Delete') {\n        return false;\n      }\n      return schemaFields.indexOf(field) < 0;\n    });\n    if (newKeys.length > 0) {\n      return schema.validatePermission(className, aclGroup, 'addField');\n    }\n    return Promise.resolve();\n  }\n\n  // Won't delete collections in the system namespace\n  // Returns a promise.\n  deleteEverything() {\n    this.schemaPromise = null;\n    return Promise.all([\n      this.adapter.dropDatabase(),\n      this.schemaCache.clear()\n    ]);\n  }\n\n\n  // Returns a promise for a list of related ids given an owning id.\n  // className here is the owning className.\n  relatedIds(className: string, key: string, owningId: string, queryOptions: QueryOptions): Promise<Array<string>> {\n    const { skip, limit, sort } = queryOptions;\n    const findOptions = {};\n    if (sort && sort.createdAt && this.adapter.canSortOnJoinTables) {\n      findOptions.sort = { '_id' : sort.createdAt };\n      findOptions.limit = limit;\n      findOptions.skip = skip;\n      queryOptions.skip = 0;\n    }\n    return this.adapter.find(joinTableName(className, key), relationSchema, { owningId }, findOptions)\n      .then(results => results.map(result => result.relatedId));\n  }\n\n  // Returns a promise for a list of owning ids given some related ids.\n  // className here is the owning className.\n  owningIds(className: string, key: string, relatedIds: string[]): Promise<string[]> {\n    return this.adapter.find(joinTableName(className, key), relationSchema, { relatedId: { '$in': relatedIds } }, {})\n      .then(results => results.map(result => result.owningId));\n  }\n\n  // Modifies query so that it no longer has $in on relation fields, or\n  // equal-to-pointer constraints on relation fields.\n  // Returns a promise that resolves when query is mutated\n  reduceInRelation(className: string, query: any, schema: any): Promise<any> {\n  // Search for an in-relation or equal-to-relation\n  // Make it sequential for now, not sure of paralleization side effects\n    if (query['$or']) {\n      const ors = query['$or'];\n      return Promise.all(ors.map((aQuery, index) => {\n        return this.reduceInRelation(className, aQuery, schema).then((aQuery) => {\n          query['$or'][index] = aQuery;\n        });\n      })).then(() => {\n        return Promise.resolve(query);\n      });\n    }\n\n    const promises = Object.keys(query).map((key) => {\n      const t = schema.getExpectedType(className, key);\n      if (!t || t.type !== 'Relation') {\n        return Promise.resolve(query);\n      }\n      let queries: ?any[] = null;\n      if (query[key] && (query[key]['$in'] || query[key]['$ne'] || query[key]['$nin'] || query[key].__type == 'Pointer')) {\n      // Build the list of queries\n        queries = Object.keys(query[key]).map((constraintKey) => {\n          let relatedIds;\n          let isNegation = false;\n          if (constraintKey === 'objectId') {\n            relatedIds = [query[key].objectId];\n          } else if (constraintKey == '$in') {\n            relatedIds = query[key]['$in'].map(r => r.objectId);\n          } else if (constraintKey == '$nin') {\n            isNegation = true;\n            relatedIds = query[key]['$nin'].map(r => r.objectId);\n          } else if (constraintKey == '$ne') {\n            isNegation = true;\n            relatedIds = [query[key]['$ne'].objectId];\n          } else {\n            return;\n          }\n          return {\n            isNegation,\n            relatedIds\n          }\n        });\n      } else {\n        queries = [{isNegation: false, relatedIds: []}];\n      }\n\n      // remove the current queryKey as we don,t need it anymore\n      delete query[key];\n      // execute each query independently to build the list of\n      // $in / $nin\n      const promises = queries.map((q) => {\n        if (!q) {\n          return Promise.resolve();\n        }\n        return this.owningIds(className, key, q.relatedIds).then((ids) => {\n          if (q.isNegation) {\n            this.addNotInObjectIdsIds(ids, query);\n          } else {\n            this.addInObjectIdsIds(ids, query);\n          }\n          return Promise.resolve();\n        });\n      });\n\n      return Promise.all(promises).then(() => {\n        return Promise.resolve();\n      })\n\n    })\n\n    return Promise.all(promises).then(() => {\n      return Promise.resolve(query);\n    })\n  }\n\n  // Modifies query so that it no longer has $relatedTo\n  // Returns a promise that resolves when query is mutated\n  reduceRelationKeys(className: string, query: any, queryOptions: any): ?Promise<void> {\n\n    if (query['$or']) {\n      return Promise.all(query['$or'].map((aQuery) => {\n        return this.reduceRelationKeys(className, aQuery, queryOptions);\n      }));\n    }\n\n    var relatedTo = query['$relatedTo'];\n    if (relatedTo) {\n      return this.relatedIds(\n        relatedTo.object.className,\n        relatedTo.key,\n        relatedTo.object.objectId,\n        queryOptions)\n        .then((ids) => {\n          delete query['$relatedTo'];\n          this.addInObjectIdsIds(ids, query);\n          return this.reduceRelationKeys(className, query, queryOptions);\n        }).then(() => {});\n    }\n  }\n\n  addInObjectIdsIds(ids: ?Array<string> = null, query: any) {\n    const idsFromString: ?Array<string> = typeof query.objectId === 'string' ? [query.objectId] : null;\n    const idsFromEq: ?Array<string> = query.objectId && query.objectId['$eq'] ? [query.objectId['$eq']] : null;\n    const idsFromIn: ?Array<string> = query.objectId && query.objectId['$in'] ? query.objectId['$in'] : null;\n\n    // @flow-disable-next\n    const allIds: Array<Array<string>> = [idsFromString, idsFromEq, idsFromIn, ids].filter(list => list !== null);\n    const totalLength = allIds.reduce((memo, list) => memo + list.length, 0);\n\n    let idsIntersection = [];\n    if (totalLength > 125) {\n      idsIntersection = intersect.big(allIds);\n    } else {\n      idsIntersection = intersect(allIds);\n    }\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $in: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $in: undefined,\n        $eq: query.objectId\n      };\n    }\n    query.objectId['$in'] = idsIntersection;\n\n    return query;\n  }\n\n  addNotInObjectIdsIds(ids: string[] = [], query: any) {\n    const idsFromNin = query.objectId && query.objectId['$nin'] ? query.objectId['$nin'] : [];\n    let allIds = [...idsFromNin,...ids].filter(list => list !== null);\n\n    // make a set and spread to remove duplicates\n    allIds = [...new Set(allIds)];\n\n    // Need to make sure we don't clobber existing shorthand $eq constraints on objectId.\n    if (!('objectId' in query)) {\n      query.objectId = {\n        $nin: undefined,\n      };\n    } else if (typeof query.objectId === 'string') {\n      query.objectId = {\n        $nin: undefined,\n        $eq: query.objectId\n      };\n    }\n\n    query.objectId['$nin'] = allIds;\n    return query;\n  }\n\n  // Runs a query on the database.\n  // Returns a promise that resolves to a list of items.\n  // Options:\n  //   skip    number of results to skip.\n  //   limit   limit to this number of results.\n  //   sort    an object where keys are the fields to sort by.\n  //           the value is +1 for ascending, -1 for descending.\n  //   count   run a count instead of returning results.\n  //   acl     restrict this operation with an ACL for the provided array\n  //           of user objectIds and roles. acl: null means no user.\n  //           when this field is not present, don't do anything regarding ACLs.\n  // TODO: make userIds not needed here. The db adapter shouldn't know\n  // anything about users, ideally. Then, improve the format of the ACL\n  // arg to work like the others.\n  find(className: string, query: any, {\n    skip,\n    limit,\n    acl,\n    sort = {},\n    count,\n    keys,\n    op,\n    distinct,\n    pipeline,\n    readPreference,\n    isWrite,\n  }: any = {}): Promise<any> {\n    const isMaster = acl === undefined;\n    const aclGroup = acl || [];\n    op = op || (typeof query.objectId == 'string' && Object.keys(query).length === 1 ? 'get' : 'find');\n    // Count operation if counting\n    op = (count === true ? 'count' : op);\n\n    let classExists = true;\n    return this.loadSchema()\n      .then(schemaController => {\n        //Allow volatile classes if querying with Master (for _PushStatus)\n        //TODO: Move volatile classes concept into mongo adapter, postgres adapter shouldn't care\n        //that api.parse.com breaks when _PushStatus exists in mongo.\n        return schemaController.getOneSchema(className, isMaster)\n          .catch(error => {\n          // Behavior for non-existent classes is kinda weird on Parse.com. Probably doesn't matter too much.\n          // For now, pretend the class exists but has no objects,\n            if (error === undefined) {\n              classExists = false;\n              return { fields: {} };\n            }\n            throw error;\n          })\n          .then(schema => {\n          // Parse.com treats queries on _created_at and _updated_at as if they were queries on createdAt and updatedAt,\n          // so duplicate that behavior here. If both are specified, the correct behavior to match Parse.com is to\n          // use the one that appears first in the sort list.\n            if (sort._created_at) {\n              sort.createdAt = sort._created_at;\n              delete sort._created_at;\n            }\n            if (sort._updated_at) {\n              sort.updatedAt = sort._updated_at;\n              delete sort._updated_at;\n            }\n            const queryOptions = { skip, limit, sort, keys, readPreference };\n            Object.keys(sort).forEach(fieldName => {\n              if (fieldName.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n                throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Cannot sort by ${fieldName}`);\n              }\n              const rootFieldName = getRootFieldName(fieldName);\n              if (!SchemaController.fieldNameIsValid(rootFieldName)) {\n                throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Invalid field name: ${fieldName}.`);\n              }\n            });\n            return (isMaster ? Promise.resolve() : schemaController.validatePermission(className, aclGroup, op))\n              .then(() => this.reduceRelationKeys(className, query, queryOptions))\n              .then(() => this.reduceInRelation(className, query, schemaController))\n              .then(() => {\n                if (!isMaster) {\n                  query = this.addPointerPermissions(schemaController, className, op, query, aclGroup);\n                }\n                if (!query) {\n                  if (op == 'get') {\n                    throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n                  } else {\n                    return [];\n                  }\n                }\n                if (!isMaster) {\n                  if (isWrite) {\n                    query = addWriteACL(query, aclGroup);\n                  } else {\n                    query = addReadACL(query, aclGroup);\n                  }\n                }\n                validateQuery(query);\n                if (count) {\n                  if (!classExists) {\n                    return 0;\n                  } else {\n                    return this.adapter.count(className, schema, query, readPreference);\n                  }\n                }  else if (distinct) {\n                  if (!classExists) {\n                    return [];\n                  } else {\n                    return this.adapter.distinct(className, schema, query, distinct);\n                  }\n                }  else if (pipeline) {\n                  if (!classExists) {\n                    return [];\n                  } else {\n                    return this.adapter.aggregate(className, schema, pipeline, readPreference);\n                  }\n                } else {\n                  return this.adapter.find(className, schema, query, queryOptions)\n                    .then(objects => objects.map(object => {\n                      object = untransformObjectACL(object);\n                      return filterSensitiveData(isMaster, aclGroup, className, object)\n                    })).catch((error) => {\n                      throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, error);\n                    });\n                }\n              });\n          });\n      });\n  }\n\n  deleteSchema(className: string): Promise<void> {\n    return this.loadSchema({ clearCache: true })\n      .then(schemaController => schemaController.getOneSchema(className, true))\n      .catch(error => {\n        if (error === undefined) {\n          return { fields: {} };\n        } else {\n          throw error;\n        }\n      })\n      .then((schema: any) => {\n        return this.collectionExists(className)\n          .then(() => this.adapter.count(className, { fields: {} }))\n          .then(count => {\n            if (count > 0) {\n              throw new Parse.Error(255, `Class ${className} is not empty, contains ${count} objects, cannot drop schema.`);\n            }\n            return this.adapter.deleteClass(className);\n          })\n          .then(wasParseCollection => {\n            if (wasParseCollection) {\n              const relationFieldNames = Object.keys(schema.fields).filter(fieldName => schema.fields[fieldName].type === 'Relation');\n              return Promise.all(relationFieldNames.map(name => this.adapter.deleteClass(joinTableName(className, name)))).then(() => {\n                return;\n              });\n            } else {\n              return Promise.resolve();\n            }\n          });\n      })\n  }\n\n  addPointerPermissions(schema: any, className: string, operation: string, query: any, aclGroup: any[] = []) {\n  // Check if class has public permission for operation\n  // If the BaseCLP pass, let go through\n    if (schema.testBaseCLP(className, aclGroup, operation)) {\n      return query;\n    }\n    const perms = schema.perms[className];\n    const field = ['get', 'find'].indexOf(operation) > -1 ? 'readUserFields' : 'writeUserFields';\n    const userACL = aclGroup.filter((acl) => {\n      return acl.indexOf('role:') != 0 && acl != '*';\n    });\n    // the ACL should have exactly 1 user\n    if (perms && perms[field] && perms[field].length > 0) {\n    // No user set return undefined\n    // If the length is > 1, that means we didn't de-dupe users correctly\n      if (userACL.length != 1) {\n        return;\n      }\n      const userId = userACL[0];\n      const userPointer =  {\n        \"__type\": \"Pointer\",\n        \"className\": \"_User\",\n        \"objectId\": userId\n      };\n\n      const permFields = perms[field];\n      const ors = permFields.map((key) => {\n        const q = {\n          [key]: userPointer\n        };\n        // if we already have a constraint on the key, use the $and\n        if (query.hasOwnProperty(key)) {\n          return {'$and': [q, query]};\n        }\n        // otherwise just add the constaint\n        return Object.assign({}, query, {\n          [`${key}`]: userPointer,\n        })\n      });\n      if (ors.length > 1) {\n        return {'$or': ors};\n      }\n      return ors[0];\n    } else {\n      return query;\n    }\n  }\n\n  // TODO: create indexes on first creation of a _User object. Otherwise it's impossible to\n  // have a Parse app without it having a _User collection.\n  performInitialization() {\n    const requiredUserFields = { fields: { ...SchemaController.defaultColumns._Default, ...SchemaController.defaultColumns._User } };\n    const requiredRoleFields = { fields: { ...SchemaController.defaultColumns._Default, ...SchemaController.defaultColumns._Role } };\n\n    const userClassPromise = this.loadSchema()\n      .then(schema => schema.enforceClassExists('_User'))\n    const roleClassPromise = this.loadSchema()\n      .then(schema => schema.enforceClassExists('_Role'))\n\n    const usernameUniqueness = userClassPromise\n      .then(() => this.adapter.ensureUniqueness('_User', requiredUserFields, ['username']))\n      .catch(error => {\n        logger.warn('Unable to ensure uniqueness for usernames: ', error);\n        throw error;\n      });\n\n    const emailUniqueness = userClassPromise\n      .then(() => this.adapter.ensureUniqueness('_User', requiredUserFields, ['email']))\n      .catch(error => {\n        logger.warn('Unable to ensure uniqueness for user email addresses: ', error);\n        throw error;\n      });\n\n    const roleUniqueness = roleClassPromise\n      .then(() => this.adapter.ensureUniqueness('_Role', requiredRoleFields, ['name']))\n      .catch(error => {\n        logger.warn('Unable to ensure uniqueness for role name: ', error);\n        throw error;\n      });\n\n    const indexPromise = this.adapter.updateSchemaWithIndexes();\n\n    // Create tables for volatile classes\n    const adapterInit = this.adapter.performInitialization({ VolatileClassesSchemas: SchemaController.VolatileClassesSchemas });\n    return Promise.all([usernameUniqueness, emailUniqueness, roleUniqueness, adapterInit, indexPromise]);\n  }\n\n  static _validateQuery: ((any) => void)\n}\n\nmodule.exports = DatabaseController;\n// Expose validateQuery for tests\nmodule.exports._validateQuery = validateQuery;\n"]}