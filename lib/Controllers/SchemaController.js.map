{"version":3,"sources":["../../src/Controllers/SchemaController.js"],"names":["Parse","require","defaultColumns","Object","freeze","_Default","type","_User","_Installation","_Role","targetClass","_Session","_Product","_PushStatus","_JobStatus","_JobSchedule","_Hooks","_GlobalConfig","_Audience","requiredColumns","systemClasses","volatileClasses","userIdRegex","roleRegex","publicRegex","requireAuthenticationRegex","permissionKeyRegex","verifyPermissionKey","key","result","reduce","isGood","regEx","match","Error","INVALID_JSON","CLPValidKeys","validateCLP","perms","fields","keys","forEach","operation","indexOf","Array","isArray","perm","joinClassRegex","classAndFieldRegex","classNameIsValid","className","test","fieldNameIsValid","fieldName","fieldNameIsValidForClass","invalidClassNameMessage","invalidJsonError","validNonRelationOrPointerTypes","fieldTypeIsInvalid","INVALID_CLASS_NAME","undefined","INCORRECT_TYPE","convertSchemaToAdapterSchema","schema","injectDefaultSchema","ACL","_rperm","_wperm","password","_hashed_password","convertAdapterSchemaToParseSchema","authData","indexes","length","classLevelPermissions","defaultSchema","_HooksSchema","_GlobalConfigSchema","_PushStatusSchema","_JobStatusSchema","_JobScheduleSchema","_AudienceSchema","VolatileClassesSchemas","dbTypeMatchesObjectType","dbType","objectType","typeToString","SchemaController","constructor","databaseAdapter","schemaCache","_dbAdapter","_cache","data","reloadData","options","clearCache","promise","Promise","resolve","then","clear","reloadDataPromise","getAllClasses","allSchemas","err","allClasses","map","setAllClasses","getOneSchema","allowVolatileClasses","cached","getClass","setOneSchema","addClassIfNotExists","validationError","validateNewClass","reject","createClass","res","catch","error","code","DUPLICATE_VALUE","updateClass","submittedFields","database","existingFields","name","field","__op","newSchema","buildMergedSchemaObject","defaultFields","fullNewSchema","assign","validateSchemaData","deletedFields","insertedFields","push","deletePromise","deleteFields","promises","enforceFieldExists","all","setPermissions","setIndexesWithSchemaFormat","reloadedSchema","enforceClassExists","existingFieldNames","INVALID_KEY_NAME","message","geoPoints","filter","setClassLevelPermissions","split","expectedType","getExpectedType","addFieldIfNotExists","deleteField","fieldNames","schemaFields","adapter","deleteClass","validateObject","object","query","geocount","expected","getType","thenValidateRequiredColumns","validateRequiredColumns","columns","missingColumns","column","objectId","testBaseCLP","aclGroup","classPerms","some","acl","validatePermission","OBJECT_NOT_FOUND","permissionField","OPERATION_FORBIDDEN","hasClass","load","dbAdapter","putRequest","sysSchemaField","_id","oldField","fieldIsDeleted","newField","schemaPromise","obj","getObjectType","__type","iso","latitude","longitude","base64","coordinates","objects","ops"],"mappings":"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","file":"SchemaController.js","sourcesContent":["// @flow\n// This class handles schema validation, persistence, and modification.\n//\n// Each individual Schema object should be immutable. The helpers to\n// do things with the Schema just return a new schema when the schema\n// is changed.\n//\n// The canonical place to store this Schema is in the database itself,\n// in a _SCHEMA collection. This is not the right way to do it for an\n// open source framework, but it's backward compatible, so we're\n// keeping it this way for now.\n//\n// In API-handling code, you should only use the Schema class via the\n// DatabaseController. This will let us replace the schema logic for\n// different databases.\n// TODO: hide all schema logic inside the database adapter.\n// @flow-disable-next\nconst Parse = require('parse/node').Parse;\nimport { StorageAdapter }     from '../Adapters/Storage/StorageAdapter';\nimport DatabaseController     from './DatabaseController';\nimport type {\n  Schema,\n  SchemaFields,\n  ClassLevelPermissions,\n  SchemaField,\n  LoadSchemaOptions,\n} from './types';\n\nconst defaultColumns: {[string]: SchemaFields} = Object.freeze({\n  // Contain the default columns for every parse object type (except _Join collection)\n  _Default: {\n    \"objectId\":  {type:'String'},\n    \"createdAt\": {type:'Date'},\n    \"updatedAt\": {type:'Date'},\n    \"ACL\":       {type:'ACL'},\n  },\n  // The additional default columns for the _User collection (in addition to DefaultCols)\n  _User: {\n    \"username\":      {type:'String'},\n    \"password\":      {type:'String'},\n    \"email\":         {type:'String'},\n    \"emailVerified\": {type:'Boolean'},\n    \"authData\":      {type:'Object'}\n  },\n  // The additional default columns for the _Installation collection (in addition to DefaultCols)\n  _Installation: {\n    \"installationId\":   {type:'String'},\n    \"deviceToken\":      {type:'String'},\n    \"channels\":         {type:'Array'},\n    \"deviceType\":       {type:'String'},\n    \"pushType\":         {type:'String'},\n    \"GCMSenderId\":      {type:'String'},\n    \"timeZone\":         {type:'String'},\n    \"localeIdentifier\": {type:'String'},\n    \"badge\":            {type:'Number'},\n    \"appVersion\":       {type:'String'},\n    \"appName\":          {type:'String'},\n    \"appIdentifier\":    {type:'String'},\n    \"parseVersion\":     {type:'String'},\n  },\n  // The additional default columns for the _Role collection (in addition to DefaultCols)\n  _Role: {\n    \"name\":  {type:'String'},\n    \"users\": {type:'Relation', targetClass:'_User'},\n    \"roles\": {type:'Relation', targetClass:'_Role'}\n  },\n  // The additional default columns for the _Session collection (in addition to DefaultCols)\n  _Session: {\n    \"restricted\":     {type:'Boolean'},\n    \"user\":           {type:'Pointer', targetClass:'_User'},\n    \"installationId\": {type:'String'},\n    \"sessionToken\":   {type:'String'},\n    \"expiresAt\":      {type:'Date'},\n    \"createdWith\":    {type:'Object'}\n  },\n  _Product: {\n    \"productIdentifier\":  {type:'String'},\n    \"download\":           {type:'File'},\n    \"downloadName\":       {type:'String'},\n    \"icon\":               {type:'File'},\n    \"order\":              {type:'Number'},\n    \"title\":              {type:'String'},\n    \"subtitle\":           {type:'String'},\n  },\n  _PushStatus: {\n    \"pushTime\":            {type:'String'},\n    \"source\":              {type:'String'}, // rest or webui\n    \"query\":               {type:'String'}, // the stringified JSON query\n    \"payload\":             {type:'String'}, // the stringified JSON payload,\n    \"title\":               {type:'String'},\n    \"expiry\":              {type:'Number'},\n    \"expiration_interval\": {type:'Number'},\n    \"status\":              {type:'String'},\n    \"numSent\":             {type:'Number'},\n    \"numFailed\":           {type:'Number'},\n    \"pushHash\":            {type:'String'},\n    \"errorMessage\":        {type:'Object'},\n    \"sentPerType\":         {type:'Object'},\n    \"failedPerType\":       {type:'Object'},\n    \"sentPerUTCOffset\":    {type:'Object'},\n    \"failedPerUTCOffset\":  {type:'Object'},\n    \"count\":               {type:'Number'} // tracks # of batches queued and pending\n  },\n  _JobStatus: {\n    \"jobName\":    {type: 'String'},\n    \"source\":     {type: 'String'},\n    \"status\":     {type: 'String'},\n    \"message\":    {type: 'String'},\n    \"params\":     {type: 'Object'}, // params received when calling the job\n    \"finishedAt\": {type: 'Date'}\n  },\n  _JobSchedule: {\n    \"jobName\":      {type:'String'},\n    \"description\":  {type:'String'},\n    \"params\":       {type:'String'},\n    \"startAfter\":   {type:'String'},\n    \"daysOfWeek\":   {type:'Array'},\n    \"timeOfDay\":    {type:'String'},\n    \"lastRun\":      {type:'Number'},\n    \"repeatMinutes\":{type:'Number'}\n  },\n  _Hooks: {\n    \"functionName\": {type:'String'},\n    \"className\":    {type:'String'},\n    \"triggerName\":  {type:'String'},\n    \"url\":          {type:'String'}\n  },\n  _GlobalConfig: {\n    \"objectId\": {type: 'String'},\n    \"params\":   {type: 'Object'}\n  },\n  _Audience: {\n    \"objectId\":  {type:'String'},\n    \"name\":      {type:'String'},\n    \"query\":     {type:'String'}, //storing query as JSON string to prevent \"Nested keys should not contain the '$' or '.' characters\" error\n    \"lastUsed\":  {type:'Date'},\n    \"timesUsed\": {type:'Number'}\n  }\n});\n\nconst requiredColumns = Object.freeze({\n  _Product: [\"productIdentifier\", \"icon\", \"order\", \"title\", \"subtitle\"],\n  _Role: [\"name\", \"ACL\"]\n});\n\nconst systemClasses = Object.freeze(['_User', '_Installation', '_Role', '_Session', '_Product', '_PushStatus', '_JobStatus', '_JobSchedule', '_Audience']);\n\nconst volatileClasses = Object.freeze(['_JobStatus', '_PushStatus', '_Hooks', '_GlobalConfig', '_JobSchedule', '_Audience']);\n\n// 10 alpha numberic chars + uppercase\nconst userIdRegex = /^[a-zA-Z0-9]{10}$/;\n// Anything that start with role\nconst roleRegex = /^role:.*/;\n// * permission\nconst publicRegex = /^\\*$/\n\nconst requireAuthenticationRegex = /^requiresAuthentication$/\n\nconst permissionKeyRegex = Object.freeze([userIdRegex, roleRegex, publicRegex, requireAuthenticationRegex]);\n\nfunction verifyPermissionKey(key) {\n  const result = permissionKeyRegex.reduce((isGood, regEx) => {\n    isGood = isGood || key.match(regEx) != null;\n    return isGood;\n  }, false);\n  if (!result) {\n    throw new Parse.Error(Parse.Error.INVALID_JSON, `'${key}' is not a valid key for class level permissions`);\n  }\n}\n\nconst CLPValidKeys = Object.freeze(['find', 'count', 'get', 'create', 'update', 'delete', 'addField', 'readUserFields', 'writeUserFields']);\nfunction validateCLP(perms: ClassLevelPermissions, fields: SchemaFields) {\n  if (!perms) {\n    return;\n  }\n  Object.keys(perms).forEach((operation) => {\n    if (CLPValidKeys.indexOf(operation) == -1) {\n      throw new Parse.Error(Parse.Error.INVALID_JSON, `${operation} is not a valid operation for class level permissions`);\n    }\n    if (!perms[operation]) {\n      return;\n    }\n\n    if (operation === 'readUserFields' || operation === 'writeUserFields') {\n      if (!Array.isArray(perms[operation])) {\n        // @flow-disable-next\n        throw new Parse.Error(Parse.Error.INVALID_JSON, `'${perms[operation]}' is not a valid value for class level permissions ${operation}`);\n      } else {\n        perms[operation].forEach((key) => {\n          if (!fields[key] || fields[key].type != 'Pointer' || fields[key].targetClass != '_User') {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, `'${key}' is not a valid column for class level pointer permissions ${operation}`);\n          }\n        });\n      }\n      return;\n    }\n\n    // @flow-disable-next\n    Object.keys(perms[operation]).forEach((key) => {\n      verifyPermissionKey(key);\n      // @flow-disable-next\n      const perm = perms[operation][key];\n      if (perm !== true) {\n        // @flow-disable-next\n        throw new Parse.Error(Parse.Error.INVALID_JSON, `'${perm}' is not a valid value for class level permissions ${operation}:${key}:${perm}`);\n      }\n    });\n  });\n}\nconst joinClassRegex = /^_Join:[A-Za-z0-9_]+:[A-Za-z0-9_]+/;\nconst classAndFieldRegex = /^[A-Za-z][A-Za-z0-9_]*$/;\nfunction classNameIsValid(className: string): boolean {\n  // Valid classes must:\n  return (\n    // Be one of _User, _Installation, _Role, _Session OR\n    systemClasses.indexOf(className) > -1 ||\n    // Be a join table OR\n    joinClassRegex.test(className) ||\n    // Include only alpha-numeric and underscores, and not start with an underscore or number\n    fieldNameIsValid(className)\n  );\n}\n\n// Valid fields must be alpha-numeric, and not start with an underscore or number\nfunction fieldNameIsValid(fieldName: string): boolean {\n  return classAndFieldRegex.test(fieldName);\n}\n\n// Checks that it's not trying to clobber one of the default fields of the class.\nfunction fieldNameIsValidForClass(fieldName: string, className: string): boolean {\n  if (!fieldNameIsValid(fieldName)) {\n    return false;\n  }\n  if (defaultColumns._Default[fieldName]) {\n    return false;\n  }\n  if (defaultColumns[className] && defaultColumns[className][fieldName]) {\n    return false;\n  }\n  return true;\n}\n\nfunction invalidClassNameMessage(className: string): string {\n  return 'Invalid classname: ' + className + ', classnames can only have alphanumeric characters and _, and must start with an alpha character ';\n}\n\nconst invalidJsonError = new Parse.Error(Parse.Error.INVALID_JSON, \"invalid JSON\");\nconst validNonRelationOrPointerTypes = [\n  'Number',\n  'String',\n  'Boolean',\n  'Date',\n  'Object',\n  'Array',\n  'GeoPoint',\n  'File',\n  'Bytes',\n  'Polygon'\n];\n// Returns an error suitable for throwing if the type is invalid\nconst fieldTypeIsInvalid = ({ type, targetClass }) => {\n  if (['Pointer', 'Relation'].indexOf(type) >= 0) {\n    if (!targetClass) {\n      return new Parse.Error(135, `type ${type} needs a class name`);\n    } else if (typeof targetClass !== 'string') {\n      return invalidJsonError;\n    } else if (!classNameIsValid(targetClass)) {\n      return new Parse.Error(Parse.Error.INVALID_CLASS_NAME, invalidClassNameMessage(targetClass));\n    } else {\n      return undefined;\n    }\n  }\n  if (typeof type !== 'string') {\n    return invalidJsonError;\n  }\n  if (validNonRelationOrPointerTypes.indexOf(type) < 0) {\n    return new Parse.Error(Parse.Error.INCORRECT_TYPE, `invalid field type: ${type}`);\n  }\n  return undefined;\n}\n\nconst convertSchemaToAdapterSchema = (schema: any) => {\n  schema = injectDefaultSchema(schema);\n  delete schema.fields.ACL;\n  schema.fields._rperm = { type: 'Array' };\n  schema.fields._wperm = { type: 'Array' };\n\n  if (schema.className === '_User') {\n    delete schema.fields.password;\n    schema.fields._hashed_password = { type: 'String' };\n  }\n\n  return schema;\n}\n\nconst convertAdapterSchemaToParseSchema = ({...schema}) => {\n  delete schema.fields._rperm;\n  delete schema.fields._wperm;\n\n  schema.fields.ACL = { type: 'ACL' };\n\n  if (schema.className === '_User') {\n    delete schema.fields.authData; //Auth data is implicit\n    delete schema.fields._hashed_password;\n    schema.fields.password = { type: 'String' };\n  }\n\n  if (schema.indexes && Object.keys(schema.indexes).length === 0) {\n    delete schema.indexes;\n  }\n\n  return schema;\n}\n\nconst injectDefaultSchema = ({className, fields, classLevelPermissions, indexes}: Schema) => {\n  const defaultSchema: Schema = {\n    className,\n    fields: {\n      ...defaultColumns._Default,\n      ...(defaultColumns[className] || {}),\n      ...fields,\n    },\n    classLevelPermissions,\n  };\n  if (indexes && Object.keys(indexes).length !== 0) {\n    defaultSchema.indexes = indexes;\n  }\n  return defaultSchema;\n};\n\nconst _HooksSchema =  {className: \"_Hooks\", fields: defaultColumns._Hooks};\nconst _GlobalConfigSchema = { className: \"_GlobalConfig\", fields: defaultColumns._GlobalConfig }\nconst _PushStatusSchema = convertSchemaToAdapterSchema(injectDefaultSchema({\n  className: \"_PushStatus\",\n  fields: {},\n  classLevelPermissions: {}\n}));\nconst _JobStatusSchema = convertSchemaToAdapterSchema(injectDefaultSchema({\n  className: \"_JobStatus\",\n  fields: {},\n  classLevelPermissions: {}\n}));\nconst _JobScheduleSchema = convertSchemaToAdapterSchema(injectDefaultSchema({\n  className: \"_JobSchedule\",\n  fields: {},\n  classLevelPermissions: {}\n}));\nconst _AudienceSchema = convertSchemaToAdapterSchema(injectDefaultSchema({\n  className: \"_Audience\",\n  fields: defaultColumns._Audience,\n  classLevelPermissions: {}\n}));\nconst VolatileClassesSchemas = [_HooksSchema, _JobStatusSchema, _JobScheduleSchema, _PushStatusSchema, _GlobalConfigSchema, _AudienceSchema];\n\nconst dbTypeMatchesObjectType = (dbType: SchemaField | string, objectType: SchemaField) => {\n  if (dbType.type !== objectType.type) return false;\n  if (dbType.targetClass !== objectType.targetClass) return false;\n  if (dbType === objectType.type) return true;\n  if (dbType.type === objectType.type) return true;\n  return false;\n}\n\nconst typeToString = (type: SchemaField | string): string => {\n  if (typeof type === 'string') {\n    return type;\n  }\n  if (type.targetClass) {\n    return `${type.type}<${type.targetClass}>`;\n  }\n  return `${type.type}`;\n}\n\n// Stores the entire schema of the app in a weird hybrid format somewhere between\n// the mongo format and the Parse format. Soon, this will all be Parse format.\nexport default class SchemaController {\n  _dbAdapter: StorageAdapter;\n  data: any;\n  perms: any;\n  indexes: any;\n  _cache: any;\n  reloadDataPromise: Promise<any>;\n\n  constructor(databaseAdapter: StorageAdapter, schemaCache: any) {\n    this._dbAdapter = databaseAdapter;\n    this._cache = schemaCache;\n    // this.data[className][fieldName] tells you the type of that field, in mongo format\n    this.data = {};\n    // this.perms[className][operation] tells you the acl-style permissions\n    this.perms = {};\n    // this.indexes[className][operation] tells you the indexes\n    this.indexes = {};\n  }\n\n  reloadData(options: LoadSchemaOptions = {clearCache: false}): Promise<any> {\n    let promise = Promise.resolve();\n    if (options.clearCache) {\n      promise = promise.then(() => {\n        return this._cache.clear();\n      });\n    }\n    if (this.reloadDataPromise && !options.clearCache) {\n      return this.reloadDataPromise;\n    }\n    this.reloadDataPromise = promise.then(() => {\n      return this.getAllClasses(options).then((allSchemas) => {\n        const data = {};\n        const perms = {};\n        const indexes = {};\n        allSchemas.forEach(schema => {\n          data[schema.className] = injectDefaultSchema(schema).fields;\n          perms[schema.className] = schema.classLevelPermissions;\n          indexes[schema.className] = schema.indexes;\n        });\n\n        // Inject the in-memory classes\n        volatileClasses.forEach(className => {\n          const schema = injectDefaultSchema({ className, fields: {}, classLevelPermissions: {} });\n          data[className] = schema.fields;\n          perms[className] = schema.classLevelPermissions;\n          indexes[className] = schema.indexes;\n        });\n        this.data = data;\n        this.perms = perms;\n        this.indexes = indexes;\n        delete this.reloadDataPromise;\n      }, (err) => {\n        this.data = {};\n        this.perms = {};\n        this.indexes = {};\n        delete this.reloadDataPromise;\n        throw err;\n      })\n    }).then(() => {});\n    return this.reloadDataPromise;\n  }\n\n  getAllClasses(options: LoadSchemaOptions = {clearCache: false}): Promise<Array<Schema>> {\n    let promise = Promise.resolve();\n    if (options.clearCache) {\n      promise = this._cache.clear();\n    }\n    return promise.then(() => {\n      return this._cache.getAllClasses()\n    }).then((allClasses) => {\n      if (allClasses && allClasses.length && !options.clearCache) {\n        return Promise.resolve(allClasses);\n      }\n      return this._dbAdapter.getAllClasses()\n        .then(allSchemas => allSchemas.map(injectDefaultSchema))\n        .then(allSchemas => {\n          return this._cache.setAllClasses(allSchemas).then(() => {\n            return allSchemas;\n          });\n        })\n    });\n  }\n\n  getOneSchema(className: string, allowVolatileClasses: boolean = false, options: LoadSchemaOptions = {clearCache: false}): Promise<Schema> {\n    let promise = Promise.resolve();\n    if (options.clearCache) {\n      promise = this._cache.clear();\n    }\n    return promise.then(() => {\n      if (allowVolatileClasses && volatileClasses.indexOf(className) > -1) {\n        return Promise.resolve({\n          className,\n          fields: this.data[className],\n          classLevelPermissions: this.perms[className],\n          indexes: this.indexes[className]\n        });\n      }\n      return this._cache.getOneSchema(className).then((cached) => {\n        if (cached && !options.clearCache) {\n          return Promise.resolve(cached);\n        }\n        return this._dbAdapter.getClass(className)\n          .then(injectDefaultSchema)\n          .then((result) => {\n            return this._cache.setOneSchema(className, result).then(() => {\n              return result;\n            })\n          });\n      });\n    });\n  }\n\n  // Create a new class that includes the three default fields.\n  // ACL is an implicit column that does not get an entry in the\n  // _SCHEMAS database. Returns a promise that resolves with the\n  // created schema, in mongo format.\n  // on success, and rejects with an error on fail. Ensure you\n  // have authorization (master key, or client class creation\n  // enabled) before calling this function.\n  addClassIfNotExists(className: string, fields: SchemaFields = {}, classLevelPermissions: any, indexes: any = {}): Promise<void> {\n    var validationError = this.validateNewClass(className, fields, classLevelPermissions);\n    if (validationError) {\n      return Promise.reject(validationError);\n    }\n\n    return this._dbAdapter.createClass(className, convertSchemaToAdapterSchema({ fields, classLevelPermissions, indexes, className }))\n      .then(convertAdapterSchemaToParseSchema)\n      .then((res) => {\n        return this._cache.clear().then(() => {\n          return Promise.resolve(res);\n        });\n      })\n      .catch(error => {\n        if (error && error.code === Parse.Error.DUPLICATE_VALUE) {\n          throw new Parse.Error(Parse.Error.INVALID_CLASS_NAME, `Class ${className} already exists.`);\n        } else {\n          throw error;\n        }\n      });\n  }\n\n  updateClass(className: string, submittedFields: SchemaFields, classLevelPermissions: any, indexes: any, database: DatabaseController) {\n    return this.getOneSchema(className)\n      .then(schema => {\n        const existingFields = schema.fields;\n        Object.keys(submittedFields).forEach(name => {\n          const field = submittedFields[name];\n          if (existingFields[name] && field.__op !== 'Delete') {\n            throw new Parse.Error(255, `Field ${name} exists, cannot update.`);\n          }\n          if (!existingFields[name] && field.__op === 'Delete') {\n            throw new Parse.Error(255, `Field ${name} does not exist, cannot delete.`);\n          }\n        });\n\n        delete existingFields._rperm;\n        delete existingFields._wperm;\n        const newSchema = buildMergedSchemaObject(existingFields, submittedFields);\n        const defaultFields = defaultColumns[className] || defaultColumns._Default;\n        const fullNewSchema = Object.assign({}, newSchema, defaultFields);\n        const validationError = this.validateSchemaData(className, newSchema, classLevelPermissions, Object.keys(existingFields));\n        if (validationError) {\n          throw new Parse.Error(validationError.code, validationError.error);\n        }\n\n        // Finally we have checked to make sure the request is valid and we can start deleting fields.\n        // Do all deletions first, then a single save to _SCHEMA collection to handle all additions.\n        const deletedFields: string[] = [];\n        const insertedFields = [];\n        Object.keys(submittedFields).forEach(fieldName => {\n          if (submittedFields[fieldName].__op === 'Delete') {\n            deletedFields.push(fieldName);\n          } else {\n            insertedFields.push(fieldName);\n          }\n        });\n\n        let deletePromise = Promise.resolve();\n        if (deletedFields.length > 0) {\n          deletePromise = this.deleteFields(deletedFields, className, database);\n        }\n        return deletePromise // Delete Everything\n          .then(() => this.reloadData({ clearCache: true })) // Reload our Schema, so we have all the new values\n          .then(() => {\n            const promises = insertedFields.map(fieldName => {\n              const type = submittedFields[fieldName];\n              return this.enforceFieldExists(className, fieldName, type);\n            });\n            return Promise.all(promises);\n          })\n          .then(() => this.setPermissions(className, classLevelPermissions, newSchema))\n          .then(() => this._dbAdapter.setIndexesWithSchemaFormat(className, indexes, schema.indexes, fullNewSchema))\n          .then(() => this.reloadData({ clearCache: true }))\n        //TODO: Move this logic into the database adapter\n          .then(() => {\n            const reloadedSchema: Schema = {\n              className: className,\n              fields: this.data[className],\n              classLevelPermissions: this.perms[className],\n            };\n            if (this.indexes[className] && Object.keys(this.indexes[className]).length !== 0) {\n              reloadedSchema.indexes = this.indexes[className];\n            }\n            return reloadedSchema;\n          });\n      })\n      .catch(error => {\n        if (error === undefined) {\n          throw new Parse.Error(Parse.Error.INVALID_CLASS_NAME, `Class ${className} does not exist.`);\n        } else {\n          throw error;\n        }\n      })\n  }\n\n  // Returns a promise that resolves successfully to the new schema\n  // object or fails with a reason.\n  enforceClassExists(className: string): Promise<SchemaController> {\n    if (this.data[className]) {\n      return Promise.resolve(this);\n    }\n    // We don't have this class. Update the schema\n    return this.addClassIfNotExists(className)\n    // The schema update succeeded. Reload the schema\n      .then(() => this.reloadData({ clearCache: true }))\n      .catch(() => {\n      // The schema update failed. This can be okay - it might\n      // have failed because there's a race condition and a different\n      // client is making the exact same schema update that we want.\n      // So just reload the schema.\n        return this.reloadData({ clearCache: true });\n      })\n      .then(() => {\n      // Ensure that the schema now validates\n        if (this.data[className]) {\n          return this;\n        } else {\n          throw new Parse.Error(Parse.Error.INVALID_JSON, `Failed to add ${className}`);\n        }\n      })\n      .catch(() => {\n      // The schema still doesn't validate. Give up\n        throw new Parse.Error(Parse.Error.INVALID_JSON, 'schema class name does not revalidate');\n      });\n  }\n\n  validateNewClass(className: string, fields: SchemaFields = {}, classLevelPermissions: any): any {\n    if (this.data[className]) {\n      throw new Parse.Error(Parse.Error.INVALID_CLASS_NAME, `Class ${className} already exists.`);\n    }\n    if (!classNameIsValid(className)) {\n      return {\n        code: Parse.Error.INVALID_CLASS_NAME,\n        error: invalidClassNameMessage(className),\n      };\n    }\n    return this.validateSchemaData(className, fields, classLevelPermissions, []);\n  }\n\n  validateSchemaData(className: string, fields: SchemaFields, classLevelPermissions: ClassLevelPermissions, existingFieldNames: Array<string>) {\n    for (const fieldName in fields) {\n      if (existingFieldNames.indexOf(fieldName) < 0) {\n        if (!fieldNameIsValid(fieldName)) {\n          return {\n            code: Parse.Error.INVALID_KEY_NAME,\n            error: 'invalid field name: ' + fieldName,\n          };\n        }\n        if (!fieldNameIsValidForClass(fieldName, className)) {\n          return {\n            code: 136,\n            error: 'field ' + fieldName + ' cannot be added',\n          };\n        }\n        const error = fieldTypeIsInvalid(fields[fieldName]);\n        if (error) return { code: error.code, error: error.message };\n      }\n    }\n\n    for (const fieldName in defaultColumns[className]) {\n      fields[fieldName] = defaultColumns[className][fieldName];\n    }\n\n    const geoPoints = Object.keys(fields).filter(key => fields[key] && fields[key].type === 'GeoPoint');\n    if (geoPoints.length > 1) {\n      return {\n        code: Parse.Error.INCORRECT_TYPE,\n        error: 'currently, only one GeoPoint field may exist in an object. Adding ' + geoPoints[1] + ' when ' + geoPoints[0] + ' already exists.',\n      };\n    }\n    validateCLP(classLevelPermissions, fields);\n  }\n\n  // Sets the Class-level permissions for a given className, which must exist.\n  setPermissions(className: string, perms: any, newSchema: SchemaFields) {\n    if (typeof perms === 'undefined') {\n      return Promise.resolve();\n    }\n    validateCLP(perms, newSchema);\n    return this._dbAdapter.setClassLevelPermissions(className, perms);\n  }\n\n  // Returns a promise that resolves successfully to the new schema\n  // object if the provided className-fieldName-type tuple is valid.\n  // The className must already be validated.\n  // If 'freeze' is true, refuse to update the schema for this field.\n  enforceFieldExists(className: string, fieldName: string, type: string | SchemaField) {\n    if (fieldName.indexOf(\".\") > 0) {\n      // subdocument key (x.y) => ok if x is of type 'object'\n      fieldName = fieldName.split(\".\")[ 0 ];\n      type = 'Object';\n    }\n    if (!fieldNameIsValid(fieldName)) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `Invalid field name: ${fieldName}.`);\n    }\n\n    // If someone tries to create a new field with null/undefined as the value, return;\n    if (!type) {\n      return Promise.resolve(this);\n    }\n\n    return this.reloadData().then(() => {\n      const expectedType = this.getExpectedType(className, fieldName);\n      if (typeof type === 'string') {\n        type = { type };\n      }\n\n      if (expectedType) {\n        if (!dbTypeMatchesObjectType(expectedType, type)) {\n          throw new Parse.Error(\n            Parse.Error.INCORRECT_TYPE,\n            `schema mismatch for ${className}.${fieldName}; expected ${typeToString(expectedType)} but got ${typeToString(type)}`\n          );\n        }\n        return this;\n      }\n\n      return this._dbAdapter.addFieldIfNotExists(className, fieldName, type).then(() => {\n        // The update succeeded. Reload the schema\n        return this.reloadData({ clearCache: true });\n      }, (error) => {\n        if (error.code == Parse.Error.INCORRECT_TYPE) {\n          // Make sure that we throw errors when it is appropriate to do so.\n          throw error;\n        }\n        // The update failed. This can be okay - it might have been a race\n        // condition where another client updated the schema in the same\n        // way that we wanted to. So, just reload the schema\n        return this.reloadData({ clearCache: true });\n      }).then(() => {\n        // Ensure that the schema now validates\n        const expectedType = this.getExpectedType(className, fieldName);\n        if (typeof type === 'string') {\n          type = { type };\n        }\n        if (!expectedType || !dbTypeMatchesObjectType(expectedType, type)) {\n          throw new Parse.Error(Parse.Error.INVALID_JSON, `Could not add field ${fieldName}`);\n        }\n        // Remove the cached schema\n        this._cache.clear();\n        return this;\n      });\n    });\n  }\n\n  // maintain compatibility\n  deleteField(fieldName: string, className: string, database: DatabaseController) {\n    return this.deleteFields([fieldName], className, database);\n  }\n\n  // Delete fields, and remove that data from all objects. This is intended\n  // to remove unused fields, if other writers are writing objects that include\n  // this field, the field may reappear. Returns a Promise that resolves with\n  // no object on success, or rejects with { code, error } on failure.\n  // Passing the database and prefix is necessary in order to drop relation collections\n  // and remove fields from objects. Ideally the database would belong to\n  // a database adapter and this function would close over it or access it via member.\n  deleteFields(fieldNames: Array<string>, className: string, database: DatabaseController) {\n    if (!classNameIsValid(className)) {\n      throw new Parse.Error(Parse.Error.INVALID_CLASS_NAME, invalidClassNameMessage(className));\n    }\n\n    fieldNames.forEach(fieldName => {\n      if (!fieldNameIsValid(fieldName)) {\n        throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, `invalid field name: ${fieldName}`);\n      }\n      //Don't allow deleting the default fields.\n      if (!fieldNameIsValidForClass(fieldName, className)) {\n        throw new Parse.Error(136, `field ${fieldName} cannot be changed`);\n      }\n    });\n\n    return this.getOneSchema(className, false, {clearCache: true})\n      .catch(error => {\n        if (error === undefined) {\n          throw new Parse.Error(Parse.Error.INVALID_CLASS_NAME, `Class ${className} does not exist.`);\n        } else {\n          throw error;\n        }\n      })\n      .then(schema => {\n        fieldNames.forEach(fieldName => {\n          if (!schema.fields[fieldName]) {\n            throw new Parse.Error(255, `Field ${fieldName} does not exist, cannot delete.`);\n          }\n        });\n\n        const schemaFields = { ...schema.fields };\n        return database.adapter.deleteFields(className, schema, fieldNames)\n          .then(() => {\n            return Promise.all(fieldNames.map(fieldName => {\n              const field = schemaFields[fieldName];\n              if (field && field.type === 'Relation') {\n              //For relations, drop the _Join table\n                return database.adapter.deleteClass(`_Join:${fieldName}:${className}`);\n              }\n              return Promise.resolve();\n            }));\n          });\n      }).then(() => {\n        this._cache.clear();\n      });\n  }\n\n  // Validates an object provided in REST format.\n  // Returns a promise that resolves to the new schema if this object is\n  // valid.\n  validateObject(className: string, object: any, query: any) {\n    let geocount = 0;\n    let promise = this.enforceClassExists(className);\n    for (const fieldName in object) {\n      if (object[fieldName] === undefined) {\n        continue;\n      }\n      const expected = getType(object[fieldName]);\n      if (expected === 'GeoPoint') {\n        geocount++;\n      }\n      if (geocount > 1) {\n        // Make sure all field validation operations run before we return.\n        // If not - we are continuing to run logic, but already provided response from the server.\n        return promise.then(() => {\n          return Promise.reject(new Parse.Error(Parse.Error.INCORRECT_TYPE,\n            'there can only be one geopoint field in a class'));\n        });\n      }\n      if (!expected) {\n        continue;\n      }\n      if (fieldName === 'ACL') {\n        // Every object has ACL implicitly.\n        continue;\n      }\n\n      promise = promise.then(schema => schema.enforceFieldExists(className, fieldName, expected));\n    }\n    promise = thenValidateRequiredColumns(promise, className, object, query);\n    return promise;\n  }\n\n  // Validates that all the properties are set for the object\n  validateRequiredColumns(className: string, object: any, query: any) {\n    const columns = requiredColumns[className];\n    if (!columns || columns.length == 0) {\n      return Promise.resolve(this);\n    }\n\n    const missingColumns = columns.filter(function(column){\n      if (query && query.objectId) {\n        if (object[column] && typeof object[column] === \"object\") {\n          // Trying to delete a required column\n          return object[column].__op == 'Delete';\n        }\n        // Not trying to do anything there\n        return false;\n      }\n      return !object[column]\n    });\n\n    if (missingColumns.length > 0) {\n      throw new Parse.Error(\n        Parse.Error.INCORRECT_TYPE,\n        missingColumns[0] + ' is required.');\n    }\n    return Promise.resolve(this);\n  }\n\n  // Validates the base CLP for an operation\n  testBaseCLP(className: string, aclGroup: string[], operation: string) {\n    if (!this.perms[className] || !this.perms[className][operation]) {\n      return true;\n    }\n    const classPerms = this.perms[className];\n    const perms = classPerms[operation];\n    // Handle the public scenario quickly\n    if (perms['*']) {\n      return true;\n    }\n    // Check permissions against the aclGroup provided (array of userId/roles)\n    if (aclGroup.some(acl => { return perms[acl] === true })) {\n      return true;\n    }\n    return false;\n  }\n\n  // Validates an operation passes class-level-permissions set in the schema\n  validatePermission(className: string, aclGroup: string[], operation: string) {\n\n    if (this.testBaseCLP(className, aclGroup, operation)) {\n      return Promise.resolve();\n    }\n\n    if (!this.perms[className] || !this.perms[className][operation]) {\n      return true;\n    }\n    const classPerms = this.perms[className];\n    const perms = classPerms[operation];\n\n    // If only for authenticated users\n    // make sure we have an aclGroup\n    if (perms['requiresAuthentication']) {\n      // If aclGroup has * (public)\n      if (!aclGroup || aclGroup.length == 0) {\n        throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND,\n          'Permission denied, user needs to be authenticated.');\n      } else if (aclGroup.indexOf('*') > -1 && aclGroup.length == 1) {\n        throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND,\n          'Permission denied, user needs to be authenticated.');\n      }\n      // requiresAuthentication passed, just move forward\n      // probably would be wise at some point to rename to 'authenticatedUser'\n      return Promise.resolve();\n    }\n\n    // No matching CLP, let's check the Pointer permissions\n    // And handle those later\n    const permissionField = ['get', 'find', 'count'].indexOf(operation) > -1 ? 'readUserFields' : 'writeUserFields';\n\n    // Reject create when write lockdown\n    if (permissionField == 'writeUserFields' && operation == 'create') {\n      throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN,\n        `Permission denied for action ${operation} on class ${className}.`);\n    }\n\n    // Process the readUserFields later\n    if (Array.isArray(classPerms[permissionField]) && classPerms[permissionField].length > 0) {\n      return Promise.resolve();\n    }\n    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN,\n      `Permission denied for action ${operation} on class ${className}.`);\n  }\n\n  // Returns the expected type for a className+key combination\n  // or undefined if the schema is not set\n  getExpectedType(className: string, fieldName: string): ?(SchemaField | string) {\n    if (this.data && this.data[className]) {\n      const expectedType = this.data[className][fieldName]\n      return expectedType === 'map' ? 'Object' : expectedType;\n    }\n    return undefined;\n  }\n\n  // Checks if a given class is in the schema.\n  hasClass(className: string) {\n    return this.reloadData().then(() => !!(this.data[className]));\n  }\n}\n\n// Returns a promise for a new Schema.\nconst load = (dbAdapter: StorageAdapter, schemaCache: any, options: any): Promise<SchemaController> => {\n  const schema = new SchemaController(dbAdapter, schemaCache);\n  return schema.reloadData(options).then(() => schema);\n}\n\n// Builds a new schema (in schema API response format) out of an\n// existing mongo schema + a schemas API put request. This response\n// does not include the default fields, as it is intended to be passed\n// to mongoSchemaFromFieldsAndClassName. No validation is done here, it\n// is done in mongoSchemaFromFieldsAndClassName.\nfunction buildMergedSchemaObject(existingFields: SchemaFields, putRequest: any): SchemaFields {\n  const newSchema = {};\n  // @flow-disable-next\n  const sysSchemaField = Object.keys(defaultColumns).indexOf(existingFields._id) === -1 ? [] : Object.keys(defaultColumns[existingFields._id]);\n  for (const oldField in existingFields) {\n    if (oldField !== '_id' && oldField !== 'ACL' &&  oldField !== 'updatedAt' && oldField !== 'createdAt' && oldField !== 'objectId') {\n      if (sysSchemaField.length > 0 && sysSchemaField.indexOf(oldField) !== -1) {\n        continue;\n      }\n      const fieldIsDeleted = putRequest[oldField] && putRequest[oldField].__op === 'Delete'\n      if (!fieldIsDeleted) {\n        newSchema[oldField] = existingFields[oldField];\n      }\n    }\n  }\n  for (const newField in putRequest) {\n    if (newField !== 'objectId' && putRequest[newField].__op !== 'Delete') {\n      if (sysSchemaField.length > 0 && sysSchemaField.indexOf(newField) !== -1) {\n        continue;\n      }\n      newSchema[newField] = putRequest[newField];\n    }\n  }\n  return newSchema;\n}\n\n// Given a schema promise, construct another schema promise that\n// validates this field once the schema loads.\nfunction thenValidateRequiredColumns(schemaPromise, className, object, query) {\n  return schemaPromise.then((schema) => {\n    return schema.validateRequiredColumns(className, object, query);\n  });\n}\n\n// Gets the type from a REST API formatted object, where 'type' is\n// extended past javascript types to include the rest of the Parse\n// type system.\n// The output should be a valid schema value.\n// TODO: ensure that this is compatible with the format used in Open DB\nfunction getType(obj: any): ?(SchemaField | string) {\n  const type = typeof obj;\n  switch(type) {\n  case 'boolean':\n    return 'Boolean';\n  case 'string':\n    return 'String';\n  case 'number':\n    return 'Number';\n  case 'map':\n  case 'object':\n    if (!obj) {\n      return undefined;\n    }\n    return getObjectType(obj);\n  case 'function':\n  case 'symbol':\n  case 'undefined':\n  default:\n    throw 'bad obj: ' + obj;\n  }\n}\n\n// This gets the type for non-JSON types like pointers and files, but\n// also gets the appropriate type for $ operators.\n// Returns null if the type is unknown.\nfunction getObjectType(obj): ?(SchemaField | string) {\n  if (obj instanceof Array) {\n    return 'Array';\n  }\n  if (obj.__type){\n    switch(obj.__type) {\n    case 'Pointer' :\n      if(obj.className) {\n        return {\n          type: 'Pointer',\n          targetClass: obj.className\n        }\n      }\n      break;\n    case 'Relation' :\n      if(obj.className) {\n        return {\n          type: 'Relation',\n          targetClass: obj.className\n        }\n      }\n      break;\n    case 'File' :\n      if(obj.name) {\n        return 'File';\n      }\n      break;\n    case 'Date' :\n      if(obj.iso) {\n        return 'Date';\n      }\n      break;\n    case 'GeoPoint' :\n      if(obj.latitude != null && obj.longitude != null) {\n        return 'GeoPoint';\n      }\n      break;\n    case 'Bytes' :\n      if(obj.base64) {\n        return 'Bytes';\n      }\n      break;\n    case 'Polygon' :\n      if(obj.coordinates) {\n        return 'Polygon';\n      }\n      break;\n    }\n    throw new Parse.Error(Parse.Error.INCORRECT_TYPE, \"This is not a valid \" + obj.__type);\n  }\n  if (obj['$ne']) {\n    return getObjectType(obj['$ne']);\n  }\n  if (obj.__op) {\n    switch(obj.__op) {\n    case 'Increment':\n      return 'Number';\n    case 'Delete':\n      return null;\n    case 'Add':\n    case 'AddUnique':\n    case 'Remove':\n      return 'Array';\n    case 'AddRelation':\n    case 'RemoveRelation':\n      return {\n        type: 'Relation',\n        targetClass: obj.objects[0].className\n      }\n    case 'Batch':\n      return getObjectType(obj.ops[0]);\n    default:\n      throw 'unexpected op: ' + obj.__op;\n    }\n  }\n  return 'Object';\n}\n\nexport {\n  load,\n  classNameIsValid,\n  fieldNameIsValid,\n  invalidClassNameMessage,\n  buildMergedSchemaObject,\n  systemClasses,\n  defaultColumns,\n  convertSchemaToAdapterSchema,\n  VolatileClassesSchemas,\n  SchemaController,\n};\n"]}