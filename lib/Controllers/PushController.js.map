{"version":3,"sources":["../../src/Controllers/PushController.js"],"names":["PushController","sendPush","body","where","config","auth","onPushStatusSaved","now","Date","hasPushSupport","Parse","Error","PUSH_MISCONFIGURED","expiration_time","getExpirationTime","expiration_interval","getExpirationInterval","hasOwnProperty","ttlMs","valueOf","pushTime","getPushTime","date","formatPushTime","badgeUpdate","Promise","resolve","data","badge","restUpdate","toLowerCase","__op","amount","Number","updateWhere","restQuery","RestQuery","buildRestWhere","then","write","RestWrite","restWhere","runOptions","many","execute","pushStatus","setInitial","objectId","audience_id","audienceId","updateAudience","lastUsed","__type","iso","toISOString","timesUsed","hasPushScheduledSupport","pushControllerQueue","enqueue","catch","err","fail","hasExpirationTime","expirationTimeParam","expirationTime","isFinite","hasExpirationInterval","expirationIntervalParam","hasPushTime","pushTimeParam","isLocalTime","pushTimeHasTimezoneComponent","offsetPattern","indexOf","length","test","isoString","substring"],"mappings":"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","file":"PushController.js","sourcesContent":["import { Parse }              from 'parse/node';\nimport RestQuery              from '../RestQuery';\nimport RestWrite              from '../RestWrite';\nimport { master }             from '../Auth';\nimport { pushStatusHandler }  from '../StatusHandler';\nimport { applyDeviceTokenExists } from '../Push/utils';\n\nexport class PushController {\n\n  sendPush(body = {}, where = {}, config, auth, onPushStatusSaved = () => {}, now = new Date()) {\n    if (!config.hasPushSupport) {\n      throw new Parse.Error(Parse.Error.PUSH_MISCONFIGURED,\n        'Missing push configuration');\n    }\n\n    // Replace the expiration_time and push_time with a valid Unix epoch milliseconds time\n    body.expiration_time = PushController.getExpirationTime(body);\n    body.expiration_interval = PushController.getExpirationInterval(body);\n    if (body.expiration_time && body.expiration_interval) {\n      throw new Parse.Error(\n        Parse.Error.PUSH_MISCONFIGURED,\n        'Both expiration_time and expiration_interval cannot be set');\n    }\n\n    // Immediate push\n    if (body.expiration_interval && !body.hasOwnProperty('push_time')) {\n      const ttlMs = body.expiration_interval * 1000;\n      body.expiration_time = (new Date(now.valueOf() + ttlMs)).valueOf();\n    }\n\n    const pushTime = PushController.getPushTime(body);\n    if (pushTime && pushTime.date !== 'undefined') {\n      body['push_time'] = PushController.formatPushTime(pushTime);\n    }\n\n    // TODO: If the req can pass the checking, we return immediately instead of waiting\n    // pushes to be sent. We probably change this behaviour in the future.\n    let badgeUpdate = () => {\n      return Promise.resolve();\n    }\n\n    if (body.data && body.data.badge) {\n      const badge = body.data.badge;\n      let restUpdate = {};\n      if (typeof badge == 'string' && badge.toLowerCase() === 'increment') {\n        restUpdate = { badge: { __op: 'Increment', amount: 1 } }\n      } else if (Number(badge)) {\n        restUpdate = { badge: badge }\n      } else {\n        throw \"Invalid value for badge, expected number or 'Increment'\";\n      }\n\n      // Force filtering on only valid device tokens\n      const updateWhere = applyDeviceTokenExists(where);\n      badgeUpdate = () => {\n        // Build a real RestQuery so we can use it in RestWrite\n        const restQuery = new RestQuery(config, master(config), '_Installation', updateWhere);\n        return restQuery.buildRestWhere().then(() => {\n          const write = new RestWrite(config, master(config), '_Installation', restQuery.restWhere, restUpdate);\n          write.runOptions.many = true;\n          return write.execute();\n        });\n      }\n    }\n    const pushStatus = pushStatusHandler(config);\n    return Promise.resolve().then(() => {\n      return pushStatus.setInitial(body, where);\n    }).then(() => {\n      onPushStatusSaved(pushStatus.objectId);\n      return badgeUpdate();\n    }).then(() => {\n      // Update audience lastUsed and timesUsed\n      if (body.audience_id) {\n        const audienceId = body.audience_id;\n\n        var updateAudience = {\n          lastUsed: { __type: \"Date\", iso: new Date().toISOString() },\n          timesUsed: { __op: \"Increment\", \"amount\": 1 }\n        };\n        const write = new RestWrite(config, master(config), '_Audience', {objectId: audienceId}, updateAudience);\n        write.execute();\n      }\n      // Don't wait for the audience update promise to resolve.\n      return Promise.resolve();\n    }).then(() => {\n      if (body.hasOwnProperty('push_time') && config.hasPushScheduledSupport) {\n        return Promise.resolve();\n      }\n      return config.pushControllerQueue.enqueue(body, where, config, auth, pushStatus);\n    }).catch((err) => {\n      return pushStatus.fail(err).then(() => {\n        throw err;\n      });\n    });\n  }\n\n  /**\n   * Get expiration time from the request body.\n   * @param {Object} request A request object\n   * @returns {Number|undefined} The expiration time if it exists in the request\n   */\n  static getExpirationTime(body = {}) {\n    var hasExpirationTime = body.hasOwnProperty('expiration_time');\n    if (!hasExpirationTime) {\n      return;\n    }\n    var expirationTimeParam = body['expiration_time'];\n    var expirationTime;\n    if (typeof expirationTimeParam === 'number') {\n      expirationTime = new Date(expirationTimeParam * 1000);\n    } else if (typeof expirationTimeParam === 'string') {\n      expirationTime = new Date(expirationTimeParam);\n    } else {\n      throw new Parse.Error(Parse.Error.PUSH_MISCONFIGURED,\n        body['expiration_time'] + ' is not valid time.');\n    }\n    // Check expirationTime is valid or not, if it is not valid, expirationTime is NaN\n    if (!isFinite(expirationTime)) {\n      throw new Parse.Error(Parse.Error.PUSH_MISCONFIGURED,\n        body['expiration_time'] + ' is not valid time.');\n    }\n    return expirationTime.valueOf();\n  }\n\n  static getExpirationInterval(body = {}) {\n    const hasExpirationInterval = body.hasOwnProperty('expiration_interval');\n    if (!hasExpirationInterval) {\n      return;\n    }\n\n    var expirationIntervalParam = body['expiration_interval'];\n    if (typeof expirationIntervalParam !== 'number' || expirationIntervalParam <= 0) {\n      throw new Parse.Error(Parse.Error.PUSH_MISCONFIGURED,\n        `expiration_interval must be a number greater than 0`);\n    }\n    return expirationIntervalParam;\n  }\n\n  /**\n   * Get push time from the request body.\n   * @param {Object} request A request object\n   * @returns {Number|undefined} The push time if it exists in the request\n   */\n  static getPushTime(body = {}) {\n    var hasPushTime = body.hasOwnProperty('push_time');\n    if (!hasPushTime) {\n      return;\n    }\n    var pushTimeParam = body['push_time'];\n    var date;\n    var isLocalTime = true;\n\n    if (typeof pushTimeParam === 'number') {\n      date = new Date(pushTimeParam * 1000);\n    } else if (typeof pushTimeParam === 'string') {\n      isLocalTime = !PushController.pushTimeHasTimezoneComponent(pushTimeParam);\n      date = new Date(pushTimeParam);\n    } else {\n      throw new Parse.Error(Parse.Error.PUSH_MISCONFIGURED,\n        body['push_time'] + ' is not valid time.');\n    }\n    // Check pushTime is valid or not, if it is not valid, pushTime is NaN\n    if (!isFinite(date)) {\n      throw new Parse.Error(Parse.Error.PUSH_MISCONFIGURED,\n        body['push_time'] + ' is not valid time.');\n    }\n\n    return {\n      date,\n      isLocalTime,\n    };\n  }\n\n  /**\n   * Checks if a ISO8601 formatted date contains a timezone component\n   * @param pushTimeParam {string}\n   * @returns {boolean}\n   */\n  static pushTimeHasTimezoneComponent(pushTimeParam: string): boolean {\n    const offsetPattern = /(.+)([+-])\\d\\d:\\d\\d$/;\n    return pushTimeParam.indexOf('Z') === pushTimeParam.length - 1 // 2007-04-05T12:30Z\n      || offsetPattern.test(pushTimeParam); // 2007-04-05T12:30.000+02:00, 2007-04-05T12:30.000-02:00\n  }\n\n  /**\n   * Converts a date to ISO format in UTC time and strips the timezone if `isLocalTime` is true\n   * @param date {Date}\n   * @param isLocalTime {boolean}\n   * @returns {string}\n   */\n  static formatPushTime({ date, isLocalTime }: { date: Date, isLocalTime: boolean }) {\n    if (isLocalTime) { // Strip 'Z'\n      const isoString = date.toISOString();\n      return isoString.substring(0, isoString.indexOf('Z'));\n    }\n    return date.toISOString();\n  }\n}\n\nexport default PushController;\n"]}