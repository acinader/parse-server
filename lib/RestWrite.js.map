{"version":3,"sources":["../src/RestWrite.js"],"names":["SchemaController","require","deepcopy","Auth","cryptoUtils","passwordCrypto","Parse","triggers","ClientSDK","RestWrite","config","auth","className","query","data","originalData","clientSDK","isReadOnly","Error","OPERATION_FORBIDDEN","storage","runOptions","objectId","INVALID_KEY_NAME","response","updatedAt","_encode","Date","iso","prototype","execute","Promise","resolve","then","getUserAndRoleACL","validateClientClassCreation","handleInstallation","handleSession","validateAuthData","runBeforeTrigger","validateSchema","setRequiredFieldsIfNeeded","transformUser","expandFilesForExistingObjects","destroyDuplicatedSessions","runDatabaseOperation","createSessionTokenIfNeeded","handleFollowup","runAfterTrigger","cleanUserAuthData","isMaster","acl","user","getUserRoles","roles","concat","id","allowClientClassCreation","systemClasses","indexOf","database","loadSchema","schemaController","hasClass","validateObject","triggerExists","Types","beforeSave","applicationId","extraData","originalObject","updatedObject","buildUpdatedObject","inflate","maybeRunTrigger","object","fieldsChangedByTrigger","_","reduce","result","value","key","isEqual","push","createdAt","newObjectId","objectIdSize","authData","username","isEmpty","USERNAME_MISSING","password","PASSWORD_MISSING","Object","keys","length","providers","canHandleAuthData","canHandle","provider","providerAuthData","hasToken","handleAuthData","UNSUPPORTED_SERVICE","handleAuthDataValidation","validations","map","authDataManager","getValidatorForProvider","all","findUsersWithAuthData","memo","queryKey","filter","q","findPromise","find","results","r","ACL","ACCOUNT_ALREADY_LINKED","join","userResult","mutatedAuthData","forEach","providerData","userAuthData","hasMutatedAuthData","userId","location","update","promise","error","RestQuery","master","__type","session","cacheController","del","sessionToken","undefined","_validatePasswordPolicy","hash","hashedPassword","_hashed_password","_validateUserName","_validateEmail","randomString","responseShouldHaveUsername","limit","USERNAME_TAKEN","email","__op","match","reject","INVALID_EMAIL_ADDRESS","EMAIL_TAKEN","userController","setEmailVerifyToken","passwordPolicy","_validatePasswordRequirements","_validatePasswordHistory","policyError","patternValidator","validatorCallback","VALIDATION_ERROR","doNotAllowUsername","maxPasswordHistory","oldPasswords","_password_history","take","newPassword","promises","compare","catch","err","preventLoginWithUnverifiedEmail","verifyUserEmails","createSessionToken","installationId","sessionData","createSession","createdWith","destroy","revokeSessionOnPasswordReset","sessionQuery","bind","sendVerificationEmail","INVALID_SESSION_TOKEN","additionalSessionData","action","INTERNAL_SERVER_ERROR","status","deviceToken","toLowerCase","deviceType","idMatch","objectIdMatch","installationIdMatch","deviceTokenMatches","orQueries","OBJECT_NOT_FOUND","delQuery","appIdentifier","code","objId","filesController","expandFilesInObject","role","clear","isUnauthenticated","SESSION_MISSING","download","downloadName","name","INVALID_ACL","read","write","maxPasswordAge","_password_changed_at","defer","shift","_updateResponseWithData","create","DUPLICATE_VALUE","userInfo","duplicated_field","hasAfterSaveHook","afterSave","hasLiveQuery","liveQueryController","_handleSaveResponse","onAfterSave","logger","warn","middle","mount","sanitizedData","test","_decode","splittedKey","split","parentProp","parentVal","get","set","clientSupportsDelete","supportsForwardDelete","fieldName","dataValue","hasOwnProperty","module","exports"],"mappings":"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","file":"RestWrite.js","sourcesContent":["// A RestWrite encapsulates everything we need to run an operation\n// that writes to the database.\n// This could be either a \"create\" or an \"update\".\n\nvar SchemaController = require('./Controllers/SchemaController');\nvar deepcopy = require('deepcopy');\n\nconst Auth = require('./Auth');\nvar cryptoUtils = require('./cryptoUtils');\nvar passwordCrypto = require('./password');\nvar Parse = require('parse/node');\nvar triggers = require('./triggers');\nvar ClientSDK = require('./ClientSDK');\nimport RestQuery from './RestQuery';\nimport _         from 'lodash';\nimport logger    from './logger';\n\n// query and data are both provided in REST API format. So data\n// types are encoded by plain old objects.\n// If query is null, this is a \"create\" and the data in data should be\n// created.\n// Otherwise this is an \"update\" - the object matching the query\n// should get updated with data.\n// RestWrite will handle objectId, createdAt, and updatedAt for\n// everything. It also knows to use triggers and special modifications\n// for the _User class.\nfunction RestWrite(config, auth, className, query, data, originalData, clientSDK) {\n  if (auth.isReadOnly) {\n    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, 'Cannot perform a write operation when using readOnlyMasterKey');\n  }\n  this.config = config;\n  this.auth = auth;\n  this.className = className;\n  this.clientSDK = clientSDK;\n  this.storage = {};\n  this.runOptions = {};\n  if (!query && data.objectId) {\n    throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'objectId is an invalid field name.');\n  }\n\n  // When the operation is complete, this.response may have several\n  // fields.\n  // response: the actual data to be returned\n  // status: the http status code. if not present, treated like a 200\n  // location: the location header. if not present, no location header\n  this.response = null;\n\n  // Processing this operation may mutate our data, so we operate on a\n  // copy\n  this.query = deepcopy(query);\n  this.data = deepcopy(data);\n  // We never change originalData, so we do not need a deep copy\n  this.originalData = originalData;\n\n  // The timestamp we'll use for this whole operation\n  this.updatedAt = Parse._encode(new Date()).iso;\n}\n\n// A convenient method to perform all the steps of processing the\n// write, in order.\n// Returns a promise for a {response, status, location} object.\n// status and location are optional.\nRestWrite.prototype.execute = function() {\n  return Promise.resolve().then(() => {\n    return this.getUserAndRoleACL();\n  }).then(() => {\n    return this.validateClientClassCreation();\n  }).then(() => {\n    return this.handleInstallation();\n  }).then(() => {\n    return this.handleSession();\n  }).then(() => {\n    return this.validateAuthData();\n  }).then(() => {\n    return this.runBeforeTrigger();\n  }).then(() => {\n    return this.validateSchema();\n  }).then(() => {\n    return this.setRequiredFieldsIfNeeded();\n  }).then(() => {\n    return this.transformUser();\n  }).then(() => {\n    return this.expandFilesForExistingObjects();\n  }).then(() => {\n    return this.destroyDuplicatedSessions();\n  }).then(() => {\n    return this.runDatabaseOperation();\n  }).then(() => {\n    return this.createSessionTokenIfNeeded();\n  }).then(() => {\n    return this.handleFollowup();\n  }).then(() => {\n    return this.runAfterTrigger();\n  }).then(() => {\n    return this.cleanUserAuthData();\n  }).then(() => {\n    return this.response;\n  })\n};\n\n// Uses the Auth object to get the list of roles, adds the user id\nRestWrite.prototype.getUserAndRoleACL = function() {\n  if (this.auth.isMaster) {\n    return Promise.resolve();\n  }\n\n  this.runOptions.acl = ['*'];\n\n  if (this.auth.user) {\n    return this.auth.getUserRoles().then((roles) => {\n      this.runOptions.acl = this.runOptions.acl.concat(roles, [this.auth.user.id]);\n      return;\n    });\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Validates this operation against the allowClientClassCreation config.\nRestWrite.prototype.validateClientClassCreation = function() {\n  if (this.config.allowClientClassCreation === false && !this.auth.isMaster\n      && SchemaController.systemClasses.indexOf(this.className) === -1) {\n    return this.config.database.loadSchema()\n      .then(schemaController => schemaController.hasClass(this.className))\n      .then(hasClass => {\n        if (hasClass !== true) {\n          throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN,\n            'This user is not allowed to access ' +\n                                'non-existent class: ' + this.className);\n        }\n      });\n  } else {\n    return Promise.resolve();\n  }\n};\n\n// Validates this operation against the schema.\nRestWrite.prototype.validateSchema = function() {\n  return this.config.database.validateObject(this.className, this.data, this.query, this.runOptions);\n};\n\n// Runs any beforeSave triggers against this operation.\n// Any change leads to our data being mutated.\nRestWrite.prototype.runBeforeTrigger = function() {\n  if (this.response) {\n    return;\n  }\n\n  // Avoid doing any setup for triggers if there is no 'beforeSave' trigger for this class.\n  if (!triggers.triggerExists(this.className, triggers.Types.beforeSave, this.config.applicationId)) {\n    return Promise.resolve();\n  }\n\n  // Cloud code gets a bit of extra data for its objects\n  var extraData = {className: this.className};\n  if (this.query && this.query.objectId) {\n    extraData.objectId = this.query.objectId;\n  }\n\n  let originalObject = null;\n  const updatedObject = this.buildUpdatedObject(extraData);\n  if (this.query && this.query.objectId) {\n    // This is an update for existing object.\n    originalObject = triggers.inflate(extraData, this.originalData);\n  }\n\n  return Promise.resolve().then(() => {\n    return triggers.maybeRunTrigger(triggers.Types.beforeSave, this.auth, updatedObject, originalObject, this.config);\n  }).then((response) => {\n    if (response && response.object) {\n      this.storage.fieldsChangedByTrigger = _.reduce(response.object, (result, value, key) => {\n        if (!_.isEqual(this.data[key], value)) {\n          result.push(key);\n        }\n        return result;\n      }, []);\n      this.data = response.object;\n      // We should delete the objectId for an update write\n      if (this.query && this.query.objectId) {\n        delete this.data.objectId\n      }\n    }\n  });\n};\n\nRestWrite.prototype.setRequiredFieldsIfNeeded = function() {\n  if (this.data) {\n    // Add default fields\n    this.data.updatedAt = this.updatedAt;\n    if (!this.query) {\n      this.data.createdAt = this.updatedAt;\n\n      // Only assign new objectId if we are creating new object\n      if (!this.data.objectId) {\n        this.data.objectId = cryptoUtils.newObjectId(this.config.objectIdSize);\n      }\n    }\n  }\n  return Promise.resolve();\n};\n\n// Transforms auth data for a user object.\n// Does nothing if this isn't a user object.\n// Returns a promise for when we're done if it can't finish this tick.\nRestWrite.prototype.validateAuthData = function() {\n  if (this.className !== '_User') {\n    return;\n  }\n\n  if (!this.query && !this.data.authData) {\n    if (typeof this.data.username !== 'string' || _.isEmpty(this.data.username)) {\n      throw new Parse.Error(Parse.Error.USERNAME_MISSING,\n        'bad or missing username');\n    }\n    if (typeof this.data.password !== 'string' || _.isEmpty(this.data.password)) {\n      throw new Parse.Error(Parse.Error.PASSWORD_MISSING,\n        'password is required');\n    }\n  }\n\n  if (!this.data.authData || !Object.keys(this.data.authData).length) {\n    return;\n  }\n\n  var authData = this.data.authData;\n  var providers = Object.keys(authData);\n  if (providers.length > 0) {\n    const canHandleAuthData = providers.reduce((canHandle, provider) => {\n      var providerAuthData = authData[provider];\n      var hasToken = (providerAuthData && providerAuthData.id);\n      return canHandle && (hasToken || providerAuthData == null);\n    }, true);\n    if (canHandleAuthData) {\n      return this.handleAuthData(authData);\n    }\n  }\n  throw new Parse.Error(Parse.Error.UNSUPPORTED_SERVICE,\n    'This authentication method is unsupported.');\n};\n\nRestWrite.prototype.handleAuthDataValidation = function(authData) {\n  const validations = Object.keys(authData).map((provider) => {\n    if (authData[provider] === null) {\n      return Promise.resolve();\n    }\n    const validateAuthData = this.config.authDataManager.getValidatorForProvider(provider);\n    if (!validateAuthData) {\n      throw new Parse.Error(Parse.Error.UNSUPPORTED_SERVICE,\n        'This authentication method is unsupported.');\n    }\n    return validateAuthData(authData[provider]);\n  });\n  return Promise.all(validations);\n}\n\nRestWrite.prototype.findUsersWithAuthData = function(authData) {\n  const providers = Object.keys(authData);\n  const query = providers.reduce((memo, provider) => {\n    if (!authData[provider]) {\n      return memo;\n    }\n    const queryKey = `authData.${provider}.id`;\n    const query = {};\n    query[queryKey] = authData[provider].id;\n    memo.push(query);\n    return memo;\n  }, []).filter((q) => {\n    return typeof q !== 'undefined';\n  });\n\n  let findPromise = Promise.resolve([]);\n  if (query.length > 0) {\n    findPromise = this.config.database.find(\n      this.className,\n      {'$or': query}, {})\n  }\n\n  return findPromise;\n}\n\n\nRestWrite.prototype.handleAuthData = function(authData) {\n  let results;\n  return this.findUsersWithAuthData(authData).then((r) => {\n    results = r.filter((user) => {\n      return !this.auth.isMaster && user.ACL && Object.keys(user.ACL).length > 0;\n    });\n    if (results.length > 1) {\n      // More than 1 user with the passed id's\n      throw new Parse.Error(Parse.Error.ACCOUNT_ALREADY_LINKED,\n        'this auth is already used');\n    }\n\n    this.storage['authProvider'] = Object.keys(authData).join(',');\n\n    if (results.length > 0) {\n      const userResult = results[0];\n      const mutatedAuthData = {};\n      Object.keys(authData).forEach((provider) => {\n        const providerData = authData[provider];\n        const userAuthData = userResult.authData[provider];\n        if (!_.isEqual(providerData, userAuthData)) {\n          mutatedAuthData[provider] = providerData;\n        }\n      });\n      const hasMutatedAuthData = Object.keys(mutatedAuthData).length !== 0;\n      let userId;\n      if (this.query && this.query.objectId) {\n        userId = this.query.objectId;\n      } else if (this.auth && this.auth.user && this.auth.user.id) {\n        userId = this.auth.user.id;\n      }\n      if (!userId || userId === userResult.objectId) { // no user making the call\n        // OR the user making the call is the right one\n        // Login with auth data\n        delete results[0].password;\n\n        // need to set the objectId first otherwise location has trailing undefined\n        this.data.objectId = userResult.objectId;\n\n        if (!this.query || !this.query.objectId) { // this a login call, no userId passed\n          this.response = {\n            response: userResult,\n            location: this.location()\n          };\n        }\n        // If we didn't change the auth data, just keep going\n        if (!hasMutatedAuthData) {\n          return;\n        }\n        // We have authData that is updated on login\n        // that can happen when token are refreshed,\n        // We should update the token and let the user in\n        // We should only check the mutated keys\n        return this.handleAuthDataValidation(mutatedAuthData).then(() => {\n          // IF we have a response, we'll skip the database operation / beforeSave / afterSave etc...\n          // we need to set it up there.\n          // We are supposed to have a response only on LOGIN with authData, so we skip those\n          // If we're not logging in, but just updating the current user, we can safely skip that part\n          if (this.response) {\n            // Assign the new authData in the response\n            Object.keys(mutatedAuthData).forEach((provider) => {\n              this.response.response.authData[provider] = mutatedAuthData[provider];\n            });\n            // Run the DB update directly, as 'master'\n            // Just update the authData part\n            // Then we're good for the user, early exit of sorts\n            return this.config.database.update(this.className, {objectId: this.data.objectId}, {authData: mutatedAuthData}, {});\n          }\n        });\n      } else if (userId) {\n        // Trying to update auth data but users\n        // are different\n        if (userResult.objectId !== userId) {\n          throw new Parse.Error(Parse.Error.ACCOUNT_ALREADY_LINKED,\n            'this auth is already used');\n        }\n        // No auth data was mutated, just keep going\n        if (!hasMutatedAuthData) {\n          return;\n        }\n      }\n    }\n    return this.handleAuthDataValidation(authData);\n  });\n}\n\n\n// The non-third-party parts of User transformation\nRestWrite.prototype.transformUser = function() {\n  var promise = Promise.resolve();\n\n  if (this.className !== '_User') {\n    return promise;\n  }\n\n  if (!this.auth.isMaster && \"emailVerified\" in this.data) {\n    const error = `Clients aren't allowed to manually update email verification.`\n    throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, error);\n  }\n\n  // Do not cleanup session if objectId is not set\n  if (this.query && this.objectId()) {\n    // If we're updating a _User object, we need to clear out the cache for that user. Find all their\n    // session tokens, and remove them from the cache.\n    promise = new RestQuery(this.config, Auth.master(this.config), '_Session', {\n      user: {\n        __type: \"Pointer\",\n        className: \"_User\",\n        objectId: this.objectId(),\n      }\n    }).execute()\n      .then(results => {\n        results.results.forEach(session => this.config.cacheController.user.del(session.sessionToken));\n      });\n  }\n\n  return promise.then(() => {\n    // Transform the password\n    if (this.data.password === undefined) { // ignore only if undefined. should proceed if empty ('')\n      return Promise.resolve();\n    }\n\n    if (this.query) {\n      this.storage['clearSessions'] = true;\n      // Generate a new session only if the user requested\n      if (!this.auth.isMaster) {\n        this.storage['generateNewSession'] = true;\n      }\n    }\n\n    return this._validatePasswordPolicy().then(() => {\n      return passwordCrypto.hash(this.data.password).then((hashedPassword) => {\n        this.data._hashed_password = hashedPassword;\n        delete this.data.password;\n      });\n    });\n\n  }).then(() => {\n    return this._validateUserName();\n  }).then(() => {\n    return this._validateEmail();\n  });\n};\n\nRestWrite.prototype._validateUserName = function () {\n  // Check for username uniqueness\n  if (!this.data.username) {\n    if (!this.query) {\n      this.data.username = cryptoUtils.randomString(25);\n      this.responseShouldHaveUsername = true;\n    }\n    return Promise.resolve();\n  }\n  // We need to a find to check for duplicate username in case they are missing the unique index on usernames\n  // TODO: Check if there is a unique index, and if so, skip this query.\n  return this.config.database.find(\n    this.className,\n    {username: this.data.username, objectId: {'$ne': this.objectId()}},\n    {limit: 1}\n  ).then(results => {\n    if (results.length > 0) {\n      throw new Parse.Error(Parse.Error.USERNAME_TAKEN, 'Account already exists for this username.');\n    }\n    return;\n  });\n};\n\nRestWrite.prototype._validateEmail = function() {\n  if (!this.data.email || this.data.email.__op === 'Delete') {\n    return Promise.resolve();\n  }\n  // Validate basic email address format\n  if (!this.data.email.match(/^.+@.+$/)) {\n    return Promise.reject(new Parse.Error(Parse.Error.INVALID_EMAIL_ADDRESS, 'Email address format is invalid.'));\n  }\n  // Same problem for email as above for username\n  return this.config.database.find(\n    this.className,\n    {email: this.data.email, objectId: {'$ne': this.objectId()}},\n    {limit: 1}\n  ).then(results => {\n    if (results.length > 0) {\n      throw new Parse.Error(Parse.Error.EMAIL_TAKEN, 'Account already exists for this email address.');\n    }\n    if (\n      !this.data.authData ||\n      !Object.keys(this.data.authData).length ||\n      Object.keys(this.data.authData).length === 1 && Object.keys(this.data.authData)[0] === 'anonymous'\n    ) {\n      // We updated the email, send a new validation\n      this.storage['sendVerificationEmail'] = true;\n      this.config.userController.setEmailVerifyToken(this.data);\n    }\n  });\n};\n\nRestWrite.prototype._validatePasswordPolicy = function() {\n  if (!this.config.passwordPolicy)\n    return Promise.resolve();\n  return this._validatePasswordRequirements().then(() => {\n    return this._validatePasswordHistory();\n  });\n};\n\n\nRestWrite.prototype._validatePasswordRequirements = function() {\n  // check if the password conforms to the defined password policy if configured\n  const policyError = 'Password does not meet the Password Policy requirements.';\n\n  // check whether the password meets the password strength requirements\n  if (this.config.passwordPolicy.patternValidator && !this.config.passwordPolicy.patternValidator(this.data.password) ||\n    this.config.passwordPolicy.validatorCallback && !this.config.passwordPolicy.validatorCallback(this.data.password)) {\n    return Promise.reject(new Parse.Error(Parse.Error.VALIDATION_ERROR, policyError));\n  }\n\n  // check whether password contain username\n  if (this.config.passwordPolicy.doNotAllowUsername === true) {\n    if (this.data.username) { // username is not passed during password reset\n      if (this.data.password.indexOf(this.data.username) >= 0)\n        return Promise.reject(new Parse.Error(Parse.Error.VALIDATION_ERROR, policyError));\n    } else { // retrieve the User object using objectId during password reset\n      return this.config.database.find('_User', {objectId: this.objectId()})\n        .then(results => {\n          if (results.length != 1) {\n            throw undefined;\n          }\n          if (this.data.password.indexOf(results[0].username) >= 0)\n            return Promise.reject(new Parse.Error(Parse.Error.VALIDATION_ERROR, policyError));\n          return Promise.resolve();\n        });\n    }\n  }\n  return Promise.resolve();\n};\n\nRestWrite.prototype._validatePasswordHistory = function() {\n  // check whether password is repeating from specified history\n  if (this.query && this.config.passwordPolicy.maxPasswordHistory) {\n    return this.config.database.find('_User', {objectId: this.objectId()}, {keys: [\"_password_history\", \"_hashed_password\"]})\n      .then(results => {\n        if (results.length != 1) {\n          throw undefined;\n        }\n        const user = results[0];\n        let oldPasswords = [];\n        if (user._password_history)\n          oldPasswords = _.take(user._password_history, this.config.passwordPolicy.maxPasswordHistory - 1);\n        oldPasswords.push(user.password);\n        const newPassword = this.data.password;\n        // compare the new password hash with all old password hashes\n        const promises = oldPasswords.map(function (hash) {\n          return passwordCrypto.compare(newPassword, hash).then((result) => {\n            if (result) // reject if there is a match\n              return Promise.reject(\"REPEAT_PASSWORD\");\n            return Promise.resolve();\n          })\n        });\n        // wait for all comparisons to complete\n        return Promise.all(promises).then(() => {\n          return Promise.resolve();\n        }).catch(err => {\n          if (err === \"REPEAT_PASSWORD\") // a match was found\n            return Promise.reject(new Parse.Error(Parse.Error.VALIDATION_ERROR, `New password should not be the same as last ${this.config.passwordPolicy.maxPasswordHistory} passwords.`));\n          throw err;\n        });\n      });\n  }\n  return Promise.resolve();\n};\n\nRestWrite.prototype.createSessionTokenIfNeeded = function() {\n  if (this.className !== '_User') {\n    return;\n  }\n  if (this.query) {\n    return;\n  }\n  if (!this.storage['authProvider'] // signup call, with\n      && this.config.preventLoginWithUnverifiedEmail // no login without verification\n      && this.config.verifyUserEmails) { // verification is on\n    return; // do not create the session token in that case!\n  }\n  return this.createSessionToken();\n}\n\nRestWrite.prototype.createSessionToken = function() {\n  // cloud installationId from Cloud Code,\n  // never create session tokens from there.\n  if (this.auth.installationId && this.auth.installationId === 'cloud') {\n    return;\n  }\n\n  const {\n    sessionData,\n    createSession,\n  } = Auth.createSession(this.config, {\n    userId: this.objectId(),\n    createdWith: {\n      'action': this.storage['authProvider'] ? 'login' : 'signup',\n      'authProvider': this.storage['authProvider'] || 'password'\n    },\n    installationId: this.auth.installationId,\n  });\n\n  if (this.response && this.response.response) {\n    this.response.response.sessionToken = sessionData.sessionToken;\n  }\n\n  return createSession();\n}\n\nRestWrite.prototype.destroyDuplicatedSessions = function() {\n  // Only for _Session, and at creation time\n  if (this.className != '_Session' || this.query) {\n    return;\n  }\n  // Destroy the sessions in 'Background'\n  const {\n    user,\n    installationId,\n    sessionToken,\n  } = this.data;\n  if (!user || !installationId)  {\n    return;\n  }\n  if (!user.objectId) {\n    return;\n  }\n  this.config.database.destroy('_Session', {\n    user,\n    installationId,\n    sessionToken: { '$ne': sessionToken },\n  });\n}\n\n// Handles any followup logic\nRestWrite.prototype.handleFollowup = function() {\n  if (this.storage && this.storage['clearSessions'] && this.config.revokeSessionOnPasswordReset) {\n    var sessionQuery = {\n      user: {\n        __type: 'Pointer',\n        className: '_User',\n        objectId: this.objectId()\n      }\n    };\n    delete this.storage['clearSessions'];\n    return this.config.database.destroy('_Session', sessionQuery)\n      .then(this.handleFollowup.bind(this));\n  }\n\n  if (this.storage && this.storage['generateNewSession']) {\n    delete this.storage['generateNewSession'];\n    return this.createSessionToken()\n      .then(this.handleFollowup.bind(this));\n  }\n\n  if (this.storage && this.storage['sendVerificationEmail']) {\n    delete this.storage['sendVerificationEmail'];\n    // Fire and forget!\n    this.config.userController.sendVerificationEmail(this.data);\n    return this.handleFollowup.bind(this);\n  }\n};\n\n// Handles the _Session class specialness.\n// Does nothing if this isn't an _Session object.\nRestWrite.prototype.handleSession = function() {\n  if (this.response || this.className !== '_Session') {\n    return;\n  }\n\n  if (!this.auth.user && !this.auth.isMaster) {\n    throw new Parse.Error(Parse.Error.INVALID_SESSION_TOKEN,\n      'Session token required.');\n  }\n\n  // TODO: Verify proper error to throw\n  if (this.data.ACL) {\n    throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'Cannot set ' +\n                          'ACL on a Session.');\n  }\n\n  if (this.query) {\n    if (this.data.user && !this.auth.isMaster && this.data.user.objectId != this.auth.user.id) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n    } else if (this.data.installationId) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n    } else if (this.data.sessionToken) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME);\n    }\n  }\n\n  if (!this.query && !this.auth.isMaster) {\n    const additionalSessionData = {};\n    for (var key in this.data) {\n      if (key === 'objectId' || key === 'user') {\n        continue;\n      }\n      additionalSessionData[key] = this.data[key];\n    }\n\n    const { sessionData, createSession } = Auth.createSession(this.config, {\n      userId: this.auth.user.id,\n      createdWith: {\n        action: 'create',\n      },\n      additionalSessionData\n    });\n\n    return createSession().then((results) => {\n      if (!results.response) {\n        throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR,\n          'Error creating session.');\n      }\n      sessionData['objectId'] = results.response['objectId'];\n      this.response = {\n        status: 201,\n        location: results.location,\n        response: sessionData\n      };\n    });\n  }\n};\n\n// Handles the _Installation class specialness.\n// Does nothing if this isn't an installation object.\n// If an installation is found, this can mutate this.query and turn a create\n// into an update.\n// Returns a promise for when we're done if it can't finish this tick.\nRestWrite.prototype.handleInstallation = function() {\n  if (this.response || this.className !== '_Installation') {\n    return;\n  }\n\n  if (!this.query && !this.data.deviceToken && !this.data.installationId && !this.auth.installationId) {\n    throw new Parse.Error(135,\n      'at least one ID field (deviceToken, installationId) ' +\n                          'must be specified in this operation');\n  }\n\n  // If the device token is 64 characters long, we assume it is for iOS\n  // and lowercase it.\n  if (this.data.deviceToken && this.data.deviceToken.length == 64) {\n    this.data.deviceToken = this.data.deviceToken.toLowerCase();\n  }\n\n  // We lowercase the installationId if present\n  if (this.data.installationId) {\n    this.data.installationId = this.data.installationId.toLowerCase();\n  }\n\n  let installationId = this.data.installationId;\n\n  // If data.installationId is not set and we're not master, we can lookup in auth\n  if (!installationId && !this.auth.isMaster) {\n    installationId = this.auth.installationId;\n  }\n\n  if (installationId) {\n    installationId = installationId.toLowerCase();\n  }\n\n  // Updating _Installation but not updating anything critical\n  if (this.query && !this.data.deviceToken\n                  && !installationId && !this.data.deviceType) {\n    return;\n  }\n\n  var promise = Promise.resolve();\n\n  var idMatch; // Will be a match on either objectId or installationId\n  var objectIdMatch;\n  var installationIdMatch;\n  var deviceTokenMatches = [];\n\n  // Instead of issuing 3 reads, let's do it with one OR.\n  const orQueries = [];\n  if (this.query && this.query.objectId) {\n    orQueries.push({\n      objectId: this.query.objectId\n    });\n  }\n  if (installationId) {\n    orQueries.push({\n      'installationId': installationId\n    });\n  }\n  if (this.data.deviceToken) {\n    orQueries.push({'deviceToken': this.data.deviceToken});\n  }\n\n  if (orQueries.length == 0) {\n    return;\n  }\n\n  promise = promise.then(() => {\n    return this.config.database.find('_Installation', {\n      '$or': orQueries\n    }, {});\n  }).then((results) => {\n    results.forEach((result) => {\n      if (this.query && this.query.objectId && result.objectId == this.query.objectId) {\n        objectIdMatch = result;\n      }\n      if (result.installationId == installationId) {\n        installationIdMatch = result;\n      }\n      if (result.deviceToken == this.data.deviceToken) {\n        deviceTokenMatches.push(result);\n      }\n    });\n\n    // Sanity checks when running a query\n    if (this.query && this.query.objectId) {\n      if (!objectIdMatch) {\n        throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND,\n          'Object not found for update.');\n      }\n      if (this.data.installationId && objectIdMatch.installationId &&\n          this.data.installationId !== objectIdMatch.installationId) {\n        throw new Parse.Error(136,\n          'installationId may not be changed in this ' +\n                                'operation');\n      }\n      if (this.data.deviceToken && objectIdMatch.deviceToken &&\n          this.data.deviceToken !== objectIdMatch.deviceToken &&\n          !this.data.installationId && !objectIdMatch.installationId) {\n        throw new Parse.Error(136,\n          'deviceToken may not be changed in this ' +\n                                'operation');\n      }\n      if (this.data.deviceType && this.data.deviceType &&\n          this.data.deviceType !== objectIdMatch.deviceType) {\n        throw new Parse.Error(136,\n          'deviceType may not be changed in this ' +\n                                'operation');\n      }\n    }\n\n    if (this.query && this.query.objectId && objectIdMatch) {\n      idMatch = objectIdMatch;\n    }\n\n    if (installationId && installationIdMatch) {\n      idMatch = installationIdMatch;\n    }\n    // need to specify deviceType only if it's new\n    if (!this.query && !this.data.deviceType && !idMatch) {\n      throw new Parse.Error(135,\n        'deviceType must be specified in this operation');\n    }\n\n  }).then(() => {\n    if (!idMatch) {\n      if (!deviceTokenMatches.length) {\n        return;\n      } else if (deviceTokenMatches.length == 1 &&\n        (!deviceTokenMatches[0]['installationId'] || !installationId)\n      ) {\n        // Single match on device token but none on installationId, and either\n        // the passed object or the match is missing an installationId, so we\n        // can just return the match.\n        return deviceTokenMatches[0]['objectId'];\n      } else if (!this.data.installationId) {\n        throw new Parse.Error(132,\n          'Must specify installationId when deviceToken ' +\n                              'matches multiple Installation objects');\n      } else {\n        // Multiple device token matches and we specified an installation ID,\n        // or a single match where both the passed and matching objects have\n        // an installation ID. Try cleaning out old installations that match\n        // the deviceToken, and return nil to signal that a new object should\n        // be created.\n        var delQuery = {\n          'deviceToken': this.data.deviceToken,\n          'installationId': {\n            '$ne': installationId\n          }\n        };\n        if (this.data.appIdentifier) {\n          delQuery['appIdentifier'] = this.data.appIdentifier;\n        }\n        this.config.database.destroy('_Installation', delQuery)\n          .catch(err => {\n            if (err.code == Parse.Error.OBJECT_NOT_FOUND) {\n              // no deletions were made. Can be ignored.\n              return;\n            }\n            // rethrow the error\n            throw err;\n          });\n        return;\n      }\n    } else {\n      if (deviceTokenMatches.length == 1 &&\n        !deviceTokenMatches[0]['installationId']) {\n        // Exactly one device token match and it doesn't have an installation\n        // ID. This is the one case where we want to merge with the existing\n        // object.\n        const delQuery = {objectId: idMatch.objectId};\n        return this.config.database.destroy('_Installation', delQuery)\n          .then(() => {\n            return deviceTokenMatches[0]['objectId'];\n          })\n          .catch(err => {\n            if (err.code == Parse.Error.OBJECT_NOT_FOUND) {\n              // no deletions were made. Can be ignored\n              return;\n            }\n            // rethrow the error\n            throw err;\n          });\n      } else {\n        if (this.data.deviceToken &&\n          idMatch.deviceToken != this.data.deviceToken) {\n          // We're setting the device token on an existing installation, so\n          // we should try cleaning out old installations that match this\n          // device token.\n          const delQuery = {\n            'deviceToken': this.data.deviceToken,\n          };\n          // We have a unique install Id, use that to preserve\n          // the interesting installation\n          if (this.data.installationId) {\n            delQuery['installationId'] = {\n              '$ne': this.data.installationId\n            }\n          } else if (idMatch.objectId && this.data.objectId\n                    && idMatch.objectId == this.data.objectId) {\n            // we passed an objectId, preserve that instalation\n            delQuery['objectId'] = {\n              '$ne': idMatch.objectId\n            }\n          } else {\n            // What to do here? can't really clean up everything...\n            return idMatch.objectId;\n          }\n          if (this.data.appIdentifier) {\n            delQuery['appIdentifier'] = this.data.appIdentifier;\n          }\n          this.config.database.destroy('_Installation', delQuery)\n            .catch(err => {\n              if (err.code == Parse.Error.OBJECT_NOT_FOUND) {\n                // no deletions were made. Can be ignored.\n                return;\n              }\n              // rethrow the error\n              throw err;\n            });\n        }\n        // In non-merge scenarios, just return the installation match id\n        return idMatch.objectId;\n      }\n    }\n  }).then((objId) => {\n    if (objId) {\n      this.query = {objectId: objId};\n      delete this.data.objectId;\n      delete this.data.createdAt;\n    }\n    // TODO: Validate ops (add/remove on channels, $inc on badge, etc.)\n  });\n  return promise;\n};\n\n// If we short-circuted the object response - then we need to make sure we expand all the files,\n// since this might not have a query, meaning it won't return the full result back.\n// TODO: (nlutsenko) This should die when we move to per-class based controllers on _Session/_User\nRestWrite.prototype.expandFilesForExistingObjects = function() {\n  // Check whether we have a short-circuited response - only then run expansion.\n  if (this.response && this.response.response) {\n    this.config.filesController.expandFilesInObject(this.config, this.response.response);\n  }\n};\n\nRestWrite.prototype.runDatabaseOperation = function() {\n  if (this.response) {\n    return;\n  }\n\n  if (this.className === '_Role') {\n    this.config.cacheController.role.clear();\n  }\n\n  if (this.className === '_User' &&\n      this.query &&\n      this.auth.isUnauthenticated()) {\n    throw new Parse.Error(Parse.Error.SESSION_MISSING, `Cannot modify user ${this.query.objectId}.`);\n  }\n\n  if (this.className === '_Product' && this.data.download) {\n    this.data.downloadName = this.data.download.name;\n  }\n\n  // TODO: Add better detection for ACL, ensuring a user can't be locked from\n  //       their own user record.\n  if (this.data.ACL && this.data.ACL['*unresolved']) {\n    throw new Parse.Error(Parse.Error.INVALID_ACL, 'Invalid ACL.');\n  }\n\n  if (this.query) {\n    // Force the user to not lockout\n    // Matched with parse.com\n    if (this.className === '_User' && this.data.ACL && this.auth.isMaster !== true) {\n      this.data.ACL[this.query.objectId] = { read: true, write: true };\n    }\n    // update password timestamp if user password is being changed\n    if (this.className === '_User' && this.data._hashed_password && this.config.passwordPolicy && this.config.passwordPolicy.maxPasswordAge) {\n      this.data._password_changed_at = Parse._encode(new Date());\n    }\n    // Ignore createdAt when update\n    delete this.data.createdAt;\n\n    let defer = Promise.resolve();\n    // if password history is enabled then save the current password to history\n    if (this.className === '_User' && this.data._hashed_password && this.config.passwordPolicy && this.config.passwordPolicy.maxPasswordHistory) {\n      defer = this.config.database.find('_User', {objectId: this.objectId()}, {keys: [\"_password_history\", \"_hashed_password\"]}).then(results => {\n        if (results.length != 1) {\n          throw undefined;\n        }\n        const user = results[0];\n        let oldPasswords = [];\n        if (user._password_history) {\n          oldPasswords = _.take(user._password_history, this.config.passwordPolicy.maxPasswordHistory);\n        }\n        //n-1 passwords go into history including last password\n        while (oldPasswords.length > this.config.passwordPolicy.maxPasswordHistory - 2) {\n          oldPasswords.shift();\n        }\n        oldPasswords.push(user.password);\n        this.data._password_history = oldPasswords;\n      });\n    }\n\n    return defer.then(() => {\n      // Run an update\n      return this.config.database.update(this.className, this.query, this.data, this.runOptions)\n        .then(response => {\n          response.updatedAt = this.updatedAt;\n          this._updateResponseWithData(response, this.data);\n          this.response = { response };\n        });\n    });\n  } else {\n    // Set the default ACL and password timestamp for the new _User\n    if (this.className === '_User') {\n      var ACL = this.data.ACL;\n      // default public r/w ACL\n      if (!ACL) {\n        ACL = {};\n        ACL['*'] = { read: true, write: false };\n      }\n      // make sure the user is not locked down\n      ACL[this.data.objectId] = { read: true, write: true };\n      this.data.ACL = ACL;\n      // password timestamp to be used when password expiry policy is enforced\n      if (this.config.passwordPolicy && this.config.passwordPolicy.maxPasswordAge) {\n        this.data._password_changed_at = Parse._encode(new Date());\n      }\n    }\n\n    // Run a create\n    return this.config.database.create(this.className, this.data, this.runOptions)\n      .catch(error => {\n        if (this.className !== '_User' || error.code !== Parse.Error.DUPLICATE_VALUE) {\n          throw error;\n        }\n\n        // Quick check, if we were able to infer the duplicated field name\n        if (error && error.userInfo && error.userInfo.duplicated_field === 'username') {\n          throw new Parse.Error(Parse.Error.USERNAME_TAKEN, 'Account already exists for this username.');\n        }\n\n        if (error && error.userInfo && error.userInfo.duplicated_field === 'email') {\n          throw new Parse.Error(Parse.Error.EMAIL_TAKEN, 'Account already exists for this email address.');\n        }\n\n        // If this was a failed user creation due to username or email already taken, we need to\n        // check whether it was username or email and return the appropriate error.\n        // Fallback to the original method\n        // TODO: See if we can later do this without additional queries by using named indexes.\n        return this.config.database.find(\n          this.className,\n          { username: this.data.username, objectId: {'$ne': this.objectId()} },\n          { limit: 1 }\n        )\n          .then(results => {\n            if (results.length > 0) {\n              throw new Parse.Error(Parse.Error.USERNAME_TAKEN, 'Account already exists for this username.');\n            }\n            return this.config.database.find(\n              this.className,\n              { email: this.data.email, objectId: {'$ne': this.objectId()} },\n              { limit: 1 }\n            );\n          })\n          .then(results => {\n            if (results.length > 0) {\n              throw new Parse.Error(Parse.Error.EMAIL_TAKEN, 'Account already exists for this email address.');\n            }\n            throw new Parse.Error(Parse.Error.DUPLICATE_VALUE, 'A duplicate value for a field with unique values was provided');\n          });\n      })\n      .then(response => {\n        response.objectId = this.data.objectId;\n        response.createdAt = this.data.createdAt;\n\n        if (this.responseShouldHaveUsername) {\n          response.username = this.data.username;\n        }\n        this._updateResponseWithData(response, this.data);\n        this.response = {\n          status: 201,\n          response,\n          location: this.location()\n        };\n      });\n  }\n};\n\n// Returns nothing - doesn't wait for the trigger.\nRestWrite.prototype.runAfterTrigger = function() {\n  if (!this.response || !this.response.response) {\n    return;\n  }\n\n  // Avoid doing any setup for triggers if there is no 'afterSave' trigger for this class.\n  const hasAfterSaveHook = triggers.triggerExists(this.className, triggers.Types.afterSave, this.config.applicationId);\n  const hasLiveQuery = this.config.liveQueryController.hasLiveQuery(this.className);\n  if (!hasAfterSaveHook && !hasLiveQuery) {\n    return Promise.resolve();\n  }\n\n  var extraData = {className: this.className};\n  if (this.query && this.query.objectId) {\n    extraData.objectId = this.query.objectId;\n  }\n\n  // Build the original object, we only do this for a update write.\n  let originalObject;\n  if (this.query && this.query.objectId) {\n    originalObject = triggers.inflate(extraData, this.originalData);\n  }\n\n  // Build the inflated object, different from beforeSave, originalData is not empty\n  // since developers can change data in the beforeSave.\n  const updatedObject = this.buildUpdatedObject(extraData);\n  updatedObject._handleSaveResponse(this.response.response, this.response.status || 200);\n\n  // Notifiy LiveQueryServer if possible\n  this.config.liveQueryController.onAfterSave(updatedObject.className, updatedObject, originalObject);\n\n  // Run afterSave trigger\n  return triggers.maybeRunTrigger(triggers.Types.afterSave, this.auth, updatedObject, originalObject, this.config)\n    .catch(function(err) {\n      logger.warn('afterSave caught an error', err);\n    })\n};\n\n// A helper to figure out what location this operation happens at.\nRestWrite.prototype.location = function() {\n  var middle = (this.className === '_User' ? '/users/' :\n    '/classes/' + this.className + '/');\n  return this.config.mount + middle + this.data.objectId;\n};\n\n// A helper to get the object id for this operation.\n// Because it could be either on the query or on the data\nRestWrite.prototype.objectId = function() {\n  return this.data.objectId || this.query.objectId;\n};\n\n// Returns a copy of the data and delete bad keys (_auth_data, _hashed_password...)\nRestWrite.prototype.sanitizedData = function() {\n  const data = Object.keys(this.data).reduce((data, key) => {\n    // Regexp comes from Parse.Object.prototype.validate\n    if (!(/^[A-Za-z][0-9A-Za-z_]*$/).test(key)) {\n      delete data[key];\n    }\n    return data;\n  }, deepcopy(this.data));\n  return Parse._decode(undefined, data);\n}\n\n// Returns an updated copy of the object\nRestWrite.prototype.buildUpdatedObject = function (extraData) {\n  const updatedObject = triggers.inflate(extraData, this.originalData);\n  Object.keys(this.data).reduce(function (data, key) {\n    if (key.indexOf(\".\") > 0) {\n      // subdocument key with dot notation ('x.y':v => 'x':{'y':v})\n      const splittedKey = key.split(\".\");\n      const parentProp = splittedKey[0];\n      let parentVal = updatedObject.get(parentProp);\n      if(typeof parentVal !== 'object') {\n        parentVal = {};\n      }\n      parentVal[splittedKey[1]] = data[key];\n      updatedObject.set(parentProp, parentVal);\n      delete data[key];\n    }\n    return data;\n  }, deepcopy(this.data));\n\n  updatedObject.set(this.sanitizedData());\n  return updatedObject;\n};\n\nRestWrite.prototype.cleanUserAuthData = function() {\n  if (this.response && this.response.response && this.className === '_User') {\n    const user = this.response.response;\n    if (user.authData) {\n      Object.keys(user.authData).forEach((provider) => {\n        if (user.authData[provider] === null) {\n          delete user.authData[provider];\n        }\n      });\n      if (Object.keys(user.authData).length == 0) {\n        delete user.authData;\n      }\n    }\n  }\n};\n\nRestWrite.prototype._updateResponseWithData = function(response, data) {\n  if (_.isEmpty(this.storage.fieldsChangedByTrigger)) {\n    return response;\n  }\n  const clientSupportsDelete = ClientSDK.supportsForwardDelete(this.clientSDK);\n  this.storage.fieldsChangedByTrigger.forEach(fieldName => {\n    const dataValue = data[fieldName];\n\n    if(!response.hasOwnProperty(fieldName)) {\n      response[fieldName] = dataValue;\n    }\n\n    // Strips operations from responses\n    if (response[fieldName] && response[fieldName].__op) {\n      delete response[fieldName];\n      if (clientSupportsDelete && dataValue.__op == 'Delete') {\n        response[fieldName] = dataValue;\n      }\n    }\n  });\n  return response;\n}\n\nexport default RestWrite;\nmodule.exports = RestWrite;\n"]}