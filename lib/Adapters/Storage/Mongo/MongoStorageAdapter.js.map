{"version":3,"sources":["../../../../src/Adapters/Storage/Mongo/MongoStorageAdapter.js"],"names":["mongodb","require","MongoClient","ReadPreference","MongoSchemaCollectionName","storageAdapterAllCollections","mongoAdapter","connect","then","database","collections","filter","collection","namespace","match","collectionName","indexOf","_collectionPrefix","convertParseSchemaToMongoSchema","schema","fields","_rperm","_wperm","className","_hashed_password","mongoSchemaFromFieldsAndClassNameAndCLP","classLevelPermissions","indexes","mongoObject","_id","objectId","updatedAt","createdAt","_metadata","undefined","fieldName","MongoSchemaCollection","parseFieldTypeToMongoFieldType","class_permissions","Object","keys","length","MongoStorageAdapter","constructor","uri","defaults","DefaultMongoURI","collectionPrefix","mongoOptions","_uri","_mongoOptions","_maxTimeMS","maxTimeMS","canSortOnJoinTables","connectionPromise","encodedUri","client","options","s","db","dbName","on","catch","err","Promise","reject","handleError","error","code","logger","handleShutdown","close","_adaptiveCollection","name","rawCollection","MongoCollection","_schemaCollection","classExists","listCollections","toArray","setClassLevelPermissions","CLPs","schemaCollection","updateSchema","$set","setIndexesWithSchemaFormat","submittedIndexes","existingIndexes","resolve","_id_","deletePromises","insertedIndexes","forEach","field","__op","Parse","Error","INVALID_QUERY","promise","dropIndex","push","key","hasOwnProperty","insertPromise","createIndexes","all","setIndexesFromMongo","getIndexes","reduce","obj","index","_fts","_ftsx","weights","createClass","insertSchema","addFieldIfNotExists","type","createIndexesIfNeeded","deleteClass","drop","message","findAndDeleteSchema","dropDatabase","deleteFields","fieldNames","mongoFormatNames","map","collectionUpdate","schemaUpdate","updateMany","getAllClasses","schemasCollection","_fetchAllSchemasFrom_SCHEMA","getClass","_fetchOneSchemaFrom_SCHEMA","createObject","object","insertOne","DUPLICATE_VALUE","underlyingError","matches","Array","isArray","userInfo","duplicated_field","deleteObjectsByQuery","query","mongoWhere","deleteMany","result","n","OBJECT_NOT_FOUND","INTERNAL_SERVER_ERROR","updateObjectsByQuery","update","mongoUpdate","findOneAndUpdate","_mongoCollection","findAndModify","new","value","upsertOneObject","upsertOne","find","skip","limit","sort","readPreference","mongoSort","_","mapKeys","mongoKeys","memo","_parseReadPreference","createTextIndexesIfNeeded","objects","ensureUniqueness","indexCreationRequest","mongoFieldNames","_ensureSparseUniqueIndexInBackground","_rawFind","count","distinct","isPointerField","substring","aggregate","pipeline","stage","$group","_parseAggregateGroupArgs","$match","_parseAggregateArgs","$project","_parseAggregateProjectArgs","results","split","isEmpty","returnValue","targetClass","_convertToDate","Date","PRIMARY","PRIMARY_PREFERRED","SECONDARY","SECONDARY_PREFERRED","NEAREST","performInitialization","createIndex","$text","indexName","textIndex","dropAllIndexes","dropIndexes","updateSchemaWithIndexes","classes","promises"],"mappings":"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","file":"MongoStorageAdapter.js","sourcesContent":["// @flow\nimport MongoCollection       from './MongoCollection';\nimport MongoSchemaCollection from './MongoSchemaCollection';\nimport { StorageAdapter }    from '../StorageAdapter';\nimport type { SchemaType,\n  QueryType,\n  StorageClass,\n  QueryOptions } from '../StorageAdapter';\nimport {\n  parse as parseUrl,\n  format as formatUrl,\n} from '../../../vendor/mongodbUrl';\nimport {\n  parseObjectToMongoObjectForCreate,\n  mongoObjectToParseObject,\n  transformKey,\n  transformWhere,\n  transformUpdate,\n  transformPointerString,\n} from './MongoTransform';\n// @flow-disable-next\nimport Parse                 from 'parse/node';\n// @flow-disable-next\nimport _                     from 'lodash';\nimport defaults              from '../../../defaults';\nimport logger                from '../../../logger';\n\n// @flow-disable-next\nconst mongodb = require('mongodb');\nconst MongoClient = mongodb.MongoClient;\nconst ReadPreference = mongodb.ReadPreference;\n\nconst MongoSchemaCollectionName = '_SCHEMA';\n\nconst storageAdapterAllCollections = mongoAdapter => {\n  return mongoAdapter.connect()\n    .then(() => mongoAdapter.database.collections())\n    .then(collections => {\n      return collections.filter(collection => {\n        if (collection.namespace.match(/\\.system\\./)) {\n          return false;\n        }\n        // TODO: If you have one app with a collection prefix that happens to be a prefix of another\n        // apps prefix, this will go very very badly. We should fix that somehow.\n        return (collection.collectionName.indexOf(mongoAdapter._collectionPrefix) == 0);\n      });\n    });\n}\n\nconst convertParseSchemaToMongoSchema = ({...schema}) => {\n  delete schema.fields._rperm;\n  delete schema.fields._wperm;\n\n  if (schema.className === '_User') {\n    // Legacy mongo adapter knows about the difference between password and _hashed_password.\n    // Future database adapters will only know about _hashed_password.\n    // Note: Parse Server will bring back password with injectDefaultSchema, so we don't need\n    // to add _hashed_password back ever.\n    delete schema.fields._hashed_password;\n  }\n\n  return schema;\n}\n\n// Returns { code, error } if invalid, or { result }, an object\n// suitable for inserting into _SCHEMA collection, otherwise.\nconst mongoSchemaFromFieldsAndClassNameAndCLP = (fields, className, classLevelPermissions, indexes) => {\n  const mongoObject = {\n    _id: className,\n    objectId: 'string',\n    updatedAt: 'string',\n    createdAt: 'string',\n    _metadata: undefined,\n  };\n\n  for (const fieldName in fields) {\n    mongoObject[fieldName] = MongoSchemaCollection.parseFieldTypeToMongoFieldType(fields[fieldName]);\n  }\n\n  if (typeof classLevelPermissions !== 'undefined') {\n    mongoObject._metadata = mongoObject._metadata || {};\n    if (!classLevelPermissions) {\n      delete mongoObject._metadata.class_permissions;\n    } else {\n      mongoObject._metadata.class_permissions = classLevelPermissions;\n    }\n  }\n\n  if (indexes && typeof indexes === 'object' && Object.keys(indexes).length > 0) {\n    mongoObject._metadata = mongoObject._metadata || {};\n    mongoObject._metadata.indexes = indexes;\n  }\n\n  if (!mongoObject._metadata) { // cleanup the unused _metadata\n    delete mongoObject._metadata;\n  }\n\n  return mongoObject;\n}\n\n\nexport class MongoStorageAdapter implements StorageAdapter {\n  // Private\n  _uri: string;\n  _collectionPrefix: string;\n  _mongoOptions: Object;\n  // Public\n  connectionPromise: Promise<any>;\n  database: any;\n  client: MongoClient;\n  _maxTimeMS: ?number;\n  canSortOnJoinTables: boolean;\n\n  constructor({\n    uri = defaults.DefaultMongoURI,\n    collectionPrefix = '',\n    mongoOptions = {},\n  }: any) {\n    this._uri = uri;\n    this._collectionPrefix = collectionPrefix;\n    this._mongoOptions = mongoOptions;\n\n    // MaxTimeMS is not a global MongoDB client option, it is applied per operation.\n    this._maxTimeMS = mongoOptions.maxTimeMS;\n    this.canSortOnJoinTables = true;\n    delete mongoOptions.maxTimeMS;\n  }\n\n  connect() {\n    if (this.connectionPromise) {\n      return this.connectionPromise;\n    }\n\n    // parsing and re-formatting causes the auth value (if there) to get URI\n    // encoded\n    const encodedUri = formatUrl(parseUrl(this._uri));\n\n    this.connectionPromise = MongoClient.connect(encodedUri, this._mongoOptions).then(client => {\n      // Starting mongoDB 3.0, the MongoClient.connect don't return a DB anymore but a client\n      // Fortunately, we can get back the options and use them to select the proper DB.\n      // https://github.com/mongodb/node-mongodb-native/blob/2c35d76f08574225b8db02d7bef687123e6bb018/lib/mongo_client.js#L885\n      const options = client.s.options;\n      const database = client.db(options.dbName);\n      if (!database) {\n        delete this.connectionPromise;\n        return;\n      }\n      database.on('error', () => {\n        delete this.connectionPromise;\n      });\n      database.on('close', () => {\n        delete this.connectionPromise;\n      });\n      this.client = client;\n      this.database = database;\n    }).catch((err) => {\n      delete this.connectionPromise;\n      return Promise.reject(err);\n    });\n\n    return this.connectionPromise;\n  }\n\n  handleError<T>(error: ?(Error | Parse.Error)): Promise<T> {\n    if (error && error.code === 13) { // Unauthorized error\n      delete this.client;\n      delete this.database;\n      delete this.connectionPromise;\n      logger.error('Received unauthorized error', { error: error });\n    }\n    throw error;\n  }\n\n  handleShutdown() {\n    if (!this.client) {\n      return;\n    }\n    this.client.close(false);\n  }\n\n  _adaptiveCollection(name: string) {\n    return this.connect()\n      .then(() => this.database.collection(this._collectionPrefix + name))\n      .then(rawCollection => new MongoCollection(rawCollection))\n      .catch(err => this.handleError(err));\n  }\n\n  _schemaCollection(): Promise<MongoSchemaCollection> {\n    return this.connect()\n      .then(() => this._adaptiveCollection(MongoSchemaCollectionName))\n      .then(collection => new MongoSchemaCollection(collection));\n  }\n\n  classExists(name: string) {\n    return this.connect().then(() => {\n      return this.database.listCollections({ name: this._collectionPrefix + name }).toArray();\n    }).then(collections => {\n      return collections.length > 0;\n    }).catch(err => this.handleError(err));\n  }\n\n  setClassLevelPermissions(className: string, CLPs: any): Promise<void> {\n    return this._schemaCollection()\n      .then(schemaCollection => schemaCollection.updateSchema(className, {\n        $set: { '_metadata.class_permissions': CLPs }\n      })).catch(err => this.handleError(err));\n  }\n\n  setIndexesWithSchemaFormat(className: string, submittedIndexes: any, existingIndexes: any = {}, fields: any): Promise<void> {\n    if (submittedIndexes === undefined) {\n      return Promise.resolve();\n    }\n    if (Object.keys(existingIndexes).length === 0) {\n      existingIndexes = { _id_: { _id: 1} };\n    }\n    const deletePromises = [];\n    const insertedIndexes = [];\n    Object.keys(submittedIndexes).forEach(name => {\n      const field = submittedIndexes[name];\n      if (existingIndexes[name] && field.__op !== 'Delete') {\n        throw new Parse.Error(Parse.Error.INVALID_QUERY, `Index ${name} exists, cannot update.`);\n      }\n      if (!existingIndexes[name] && field.__op === 'Delete') {\n        throw new Parse.Error(Parse.Error.INVALID_QUERY, `Index ${name} does not exist, cannot delete.`);\n      }\n      if (field.__op === 'Delete') {\n        const promise = this.dropIndex(className, name);\n        deletePromises.push(promise);\n        delete existingIndexes[name];\n      } else {\n        Object.keys(field).forEach(key => {\n          if (!fields.hasOwnProperty(key)) {\n            throw new Parse.Error(Parse.Error.INVALID_QUERY, `Field ${key} does not exist, cannot add index.`);\n          }\n        });\n        existingIndexes[name] = field;\n        insertedIndexes.push({\n          key: field,\n          name,\n        });\n      }\n    });\n    let insertPromise = Promise.resolve();\n    if (insertedIndexes.length > 0) {\n      insertPromise = this.createIndexes(className, insertedIndexes);\n    }\n    return Promise.all(deletePromises)\n      .then(() => insertPromise)\n      .then(() => this._schemaCollection())\n      .then(schemaCollection => schemaCollection.updateSchema(className, {\n        $set: { '_metadata.indexes':  existingIndexes }\n      }))\n      .catch(err => this.handleError(err));\n  }\n\n  setIndexesFromMongo(className: string) {\n    return this.getIndexes(className).then((indexes) => {\n      indexes = indexes.reduce((obj, index) => {\n        if (index.key._fts) {\n          delete index.key._fts;\n          delete index.key._ftsx;\n          for (const field in index.weights) {\n            index.key[field] = 'text';\n          }\n        }\n        obj[index.name] = index.key;\n        return obj;\n      }, {});\n      return this._schemaCollection()\n        .then(schemaCollection => schemaCollection.updateSchema(className, {\n          $set: { '_metadata.indexes': indexes }\n        }));\n    })\n      .catch(err => this.handleError(err))\n      .catch(() => {\n        // Ignore if collection not found\n        return Promise.resolve();\n      });\n  }\n\n  createClass(className: string, schema: SchemaType): Promise<void> {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoObject = mongoSchemaFromFieldsAndClassNameAndCLP(schema.fields, className, schema.classLevelPermissions, schema.indexes);\n    mongoObject._id = className;\n    return this.setIndexesWithSchemaFormat(className, schema.indexes, {}, schema.fields)\n      .then(() => this._schemaCollection())\n      .then(schemaCollection => schemaCollection.insertSchema(mongoObject))\n      .catch(err => this.handleError(err));\n  }\n\n  addFieldIfNotExists(className: string, fieldName: string, type: any): Promise<void> {\n    return this._schemaCollection()\n      .then(schemaCollection => schemaCollection.addFieldIfNotExists(className, fieldName, type))\n      .then(() => this.createIndexesIfNeeded(className, fieldName, type))\n      .catch(err => this.handleError(err));\n  }\n\n  // Drops a collection. Resolves with true if it was a Parse Schema (eg. _User, Custom, etc.)\n  // and resolves with false if it wasn't (eg. a join table). Rejects if deletion was impossible.\n  deleteClass(className: string) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection.drop())\n      .catch(error => {\n      // 'ns not found' means collection was already gone. Ignore deletion attempt.\n        if (error.message == 'ns not found') {\n          return;\n        }\n        throw error;\n      })\n    // We've dropped the collection, now remove the _SCHEMA document\n      .then(() => this._schemaCollection())\n      .then(schemaCollection => schemaCollection.findAndDeleteSchema(className))\n      .catch(err => this.handleError(err));\n  }\n\n  dropDatabase() {\n    if (!this.database) { return Promise.resolve(); }\n    return this.database.dropDatabase();\n  }\n\n  // Remove the column and all the data. For Relations, the _Join collection is handled\n  // specially, this function does not delete _Join columns. It should, however, indicate\n  // that the relation fields does not exist anymore. In mongo, this means removing it from\n  // the _SCHEMA collection.  There should be no actual data in the collection under the same name\n  // as the relation column, so it's fine to attempt to delete it. If the fields listed to be\n  // deleted do not exist, this function should return successfully anyways. Checking for\n  // attempts to delete non-existent fields is the responsibility of Parse Server.\n\n  // Pointer field names are passed for legacy reasons: the original mongo\n  // format stored pointer field names differently in the database, and therefore\n  // needed to know the type of the field before it could delete it. Future database\n  // adapters should ignore the pointerFieldNames argument. All the field names are in\n  // fieldNames, they show up additionally in the pointerFieldNames database for use\n  // by the mongo adapter, which deals with the legacy mongo format.\n\n  // This function is not obligated to delete fields atomically. It is given the field\n  // names in a list so that databases that are capable of deleting fields atomically\n  // may do so.\n\n  // Returns a Promise.\n  deleteFields(className: string, schema: SchemaType, fieldNames: string[]) {\n    const mongoFormatNames = fieldNames.map(fieldName => {\n      if (schema.fields[fieldName].type === 'Pointer') {\n        return `_p_${fieldName}`\n      } else {\n        return fieldName;\n      }\n    });\n    const collectionUpdate = { '$unset' : {} };\n    mongoFormatNames.forEach(name => {\n      collectionUpdate['$unset'][name] = null;\n    });\n\n    const schemaUpdate = { '$unset' : {} };\n    fieldNames.forEach(name => {\n      schemaUpdate['$unset'][name] = null;\n    });\n\n    return this._adaptiveCollection(className)\n      .then(collection => collection.updateMany({}, collectionUpdate))\n      .then(() => this._schemaCollection())\n      .then(schemaCollection => schemaCollection.updateSchema(className, schemaUpdate))\n      .catch(err => this.handleError(err));\n  }\n\n  // Return a promise for all schemas known to this adapter, in Parse format. In case the\n  // schemas cannot be retrieved, returns a promise that rejects. Requirements for the\n  // rejection reason are TBD.\n  getAllClasses(): Promise<StorageClass[]> {\n    return this._schemaCollection().then(schemasCollection => schemasCollection._fetchAllSchemasFrom_SCHEMA())\n      .catch(err => this.handleError(err));\n  }\n\n  // Return a promise for the schema with the given name, in Parse format. If\n  // this adapter doesn't know about the schema, return a promise that rejects with\n  // undefined as the reason.\n  getClass(className: string): Promise<StorageClass> {\n    return this._schemaCollection()\n      .then(schemasCollection => schemasCollection._fetchOneSchemaFrom_SCHEMA(className))\n      .catch(err => this.handleError(err));\n  }\n\n  // TODO: As yet not particularly well specified. Creates an object. Maybe shouldn't even need the schema,\n  // and should infer from the type. Or maybe does need the schema for validations. Or maybe needs\n  // the schema only for the legacy mongo format. We'll figure that out later.\n  createObject(className: string, schema: SchemaType, object: any) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoObject = parseObjectToMongoObjectForCreate(className, object, schema);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.insertOne(mongoObject))\n      .catch(error => {\n        if (error.code === 11000) { // Duplicate value\n          const err = new Parse.Error(Parse.Error.DUPLICATE_VALUE, 'A duplicate value for a field with unique values was provided');\n          err.underlyingError = error;\n          if (error.message) {\n            const matches = error.message.match(/index:[\\sa-zA-Z0-9_\\-\\.]+\\$?([a-zA-Z_-]+)_1/);\n            if (matches && Array.isArray(matches)) {\n              err.userInfo = { duplicated_field: matches[1] };\n            }\n          }\n          throw err;\n        }\n        throw error;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  // Remove all objects that match the given Parse Query.\n  // If no objects match, reject with OBJECT_NOT_FOUND. If objects are found and deleted, resolve with undefined.\n  // If there is some other error, reject with INTERNAL_SERVER_ERROR.\n  deleteObjectsByQuery(className: string, schema: SchemaType, query: QueryType) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    return this._adaptiveCollection(className)\n      .then(collection => {\n        const mongoWhere = transformWhere(className, query, schema);\n        return collection.deleteMany(mongoWhere)\n      })\n      .catch(err => this.handleError(err))\n      .then(({ result }) => {\n        if (result.n === 0) {\n          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n        }\n        return Promise.resolve();\n      }, () => {\n        throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, 'Database adapter error');\n      });\n  }\n\n  // Apply the update to all objects that match the given Parse Query.\n  updateObjectsByQuery(className: string, schema: SchemaType, query: QueryType, update: any) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoUpdate = transformUpdate(className, update, schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.updateMany(mongoWhere, mongoUpdate))\n      .catch(err => this.handleError(err));\n  }\n\n  // Atomically finds and updates an object based on query.\n  // Return value not currently well specified.\n  findOneAndUpdate(className: string, schema: SchemaType, query: QueryType, update: any) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoUpdate = transformUpdate(className, update, schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.findAndModify(mongoWhere, [], mongoUpdate, { new: true }))\n      .then(result => mongoObjectToParseObject(className, result.value, schema))\n      .catch(error => {\n        if (error.code === 11000) {\n          throw new Parse.Error(Parse.Error.DUPLICATE_VALUE, 'A duplicate value for a field with unique values was provided');\n        }\n        throw error;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  // Hopefully we can get rid of this. It's only used for config and hooks.\n  upsertOneObject(className: string, schema: SchemaType, query: QueryType, update: any) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoUpdate = transformUpdate(className, update, schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.upsertOne(mongoWhere, mongoUpdate))\n      .catch(err => this.handleError(err));\n  }\n\n  // Executes a find. Accepts: className, query in Parse format, and { skip, limit, sort }.\n  find(className: string, schema: SchemaType, query: QueryType, { skip, limit, sort, keys, readPreference }: QueryOptions): Promise<any> {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const mongoWhere = transformWhere(className, query, schema);\n    const mongoSort = _.mapKeys(sort, (value, fieldName) => transformKey(className, fieldName, schema));\n    const mongoKeys = _.reduce(keys, (memo, key) => {\n      memo[transformKey(className, key, schema)] = 1;\n      return memo;\n    }, {});\n\n    readPreference = this._parseReadPreference(readPreference);\n    return this.createTextIndexesIfNeeded(className, query, schema)\n      .then(() => this._adaptiveCollection(className))\n      .then(collection => collection.find(mongoWhere, {\n        skip,\n        limit,\n        sort: mongoSort,\n        keys: mongoKeys,\n        maxTimeMS: this._maxTimeMS,\n        readPreference,\n      }))\n      .then(objects => objects.map(object => mongoObjectToParseObject(className, object, schema)))\n      .catch(err => this.handleError(err));\n  }\n\n  // Create a unique index. Unique indexes on nullable fields are not allowed. Since we don't\n  // currently know which fields are nullable and which aren't, we ignore that criteria.\n  // As such, we shouldn't expose this function to users of parse until we have an out-of-band\n  // Way of determining if a field is nullable. Undefined doesn't count against uniqueness,\n  // which is why we use sparse indexes.\n  ensureUniqueness(className: string, schema: SchemaType, fieldNames: string[]) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const indexCreationRequest = {};\n    const mongoFieldNames = fieldNames.map(fieldName => transformKey(className, fieldName, schema));\n    mongoFieldNames.forEach(fieldName => {\n      indexCreationRequest[fieldName] = 1;\n    });\n    return this._adaptiveCollection(className)\n      .then(collection => collection._ensureSparseUniqueIndexInBackground(indexCreationRequest))\n      .catch(error => {\n        if (error.code === 11000) {\n          throw new Parse.Error(Parse.Error.DUPLICATE_VALUE, 'Tried to ensure field uniqueness for a class that already has duplicates.');\n        }\n        throw error;\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  // Used in tests\n  _rawFind(className: string, query: QueryType) {\n    return this._adaptiveCollection(className).then(collection => collection.find(query, {\n      maxTimeMS: this._maxTimeMS,\n    })).catch(err => this.handleError(err));\n  }\n\n  // Executes a count.\n  count(className: string, schema: SchemaType, query: QueryType, readPreference: ?string) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    readPreference = this._parseReadPreference(readPreference);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.count(transformWhere(className, query, schema), {\n        maxTimeMS: this._maxTimeMS,\n        readPreference,\n      }))\n      .catch(err => this.handleError(err));\n  }\n\n  distinct(className: string, schema: SchemaType, query: QueryType, fieldName: string) {\n    schema = convertParseSchemaToMongoSchema(schema);\n    const isPointerField = schema.fields[fieldName] && schema.fields[fieldName].type === 'Pointer';\n    if (isPointerField) {\n      fieldName = `_p_${fieldName}`\n    }\n    return this._adaptiveCollection(className)\n      .then(collection => collection.distinct(fieldName, transformWhere(className, query, schema)))\n      .then(objects => {\n        objects = objects.filter((obj) => obj != null);\n        return objects.map(object => {\n          if (isPointerField) {\n            const field = fieldName.substring(3);\n            return transformPointerString(schema, field, object);\n          }\n          return mongoObjectToParseObject(className, object, schema);\n        });\n      })\n      .catch(err => this.handleError(err));\n  }\n\n  aggregate(className: string, schema: any, pipeline: any, readPreference: ?string) {\n    let isPointerField = false;\n    pipeline = pipeline.map((stage) => {\n      if (stage.$group) {\n        stage.$group = this._parseAggregateGroupArgs(schema, stage.$group);\n        if (stage.$group._id && (typeof stage.$group._id === 'string') && stage.$group._id.indexOf('$_p_') >= 0) {\n          isPointerField = true;\n        }\n      }\n      if (stage.$match) {\n        stage.$match = this._parseAggregateArgs(schema, stage.$match);\n      }\n      if (stage.$project) {\n        stage.$project = this._parseAggregateProjectArgs(schema, stage.$project);\n      }\n      return stage;\n    });\n    readPreference = this._parseReadPreference(readPreference);\n    return this._adaptiveCollection(className)\n      .then(collection => collection.aggregate(pipeline, { readPreference, maxTimeMS: this._maxTimeMS }))\n      .catch(error => {\n        if (error.code === 16006) {\n          throw new Parse.Error(Parse.Error.INVALID_QUERY, error.message);\n        }\n        throw error;\n      })\n      .then(results => {\n        results.forEach(result => {\n          if (result.hasOwnProperty('_id')) {\n            if (isPointerField && result._id) {\n              result._id = result._id.split('$')[1];\n            }\n            if (result._id == null || _.isEmpty(result._id)) {\n              result._id = null;\n            }\n            result.objectId = result._id;\n            delete result._id;\n          }\n        });\n        return results;\n      })\n      .then(objects => objects.map(object => mongoObjectToParseObject(className, object, schema)))\n      .catch(err => this.handleError(err));\n  }\n\n  // This function will recursively traverse the pipeline and convert any Pointer or Date columns.\n  // If we detect a pointer column we will rename the column being queried for to match the column\n  // in the database. We also modify the value to what we expect the value to be in the database\n  // as well.\n  // For dates, the driver expects a Date object, but we have a string coming in. So we'll convert\n  // the string to a Date so the driver can perform the necessary comparison.\n  //\n  // The goal of this method is to look for the \"leaves\" of the pipeline and determine if it needs\n  // to be converted. The pipeline can have a few different forms. For more details, see:\n  //     https://docs.mongodb.com/manual/reference/operator/aggregation/\n  //\n  // If the pipeline is an array, it means we are probably parsing an '$and' or '$or' operator. In\n  // that case we need to loop through all of it's children to find the columns being operated on.\n  // If the pipeline is an object, then we'll loop through the keys checking to see if the key name\n  // matches one of the schema columns. If it does match a column and the column is a Pointer or\n  // a Date, then we'll convert the value as described above.\n  //\n  // As much as I hate recursion...this seemed like a good fit for it. We're essentially traversing\n  // down a tree to find a \"leaf node\" and checking to see if it needs to be converted.\n  _parseAggregateArgs(schema: any, pipeline: any): any {\n    if (Array.isArray(pipeline)) {\n      return pipeline.map((value) => this._parseAggregateArgs(schema, value));\n    } else if (typeof pipeline === 'object') {\n      const returnValue = {};\n      for (const field in pipeline) {\n        if (schema.fields[field] && schema.fields[field].type === 'Pointer') {\n          if (typeof pipeline[field] === 'object') {\n            // Pass objects down to MongoDB...this is more than likely an $exists operator.\n            returnValue[`_p_${field}`] = pipeline[field];\n          } else {\n            returnValue[`_p_${field}`] = `${schema.fields[field].targetClass}$${pipeline[field]}`;\n          }\n        } else if (schema.fields[field] && schema.fields[field].type === 'Date') {\n          returnValue[field] = this._convertToDate(pipeline[field]);\n        } else {\n          returnValue[field] = this._parseAggregateArgs(schema, pipeline[field]);\n        }\n\n        if (field === 'objectId') {\n          returnValue['_id'] = returnValue[field];\n          delete returnValue[field];\n        } else if (field === 'createdAt') {\n          returnValue['_created_at'] = returnValue[field];\n          delete returnValue[field];\n        } else if (field === 'updatedAt') {\n          returnValue['_updated_at'] = returnValue[field];\n          delete returnValue[field];\n        }\n      }\n      return returnValue;\n    }\n    return pipeline;\n  }\n\n  // This function is slightly different than the one above. Rather than trying to combine these\n  // two functions and making the code even harder to understand, I decided to split it up. The\n  // difference with this function is we are not transforming the values, only the keys of the\n  // pipeline.\n  _parseAggregateProjectArgs(schema: any, pipeline: any): any {\n    const returnValue = {};\n    for (const field in pipeline) {\n      if (schema.fields[field] && schema.fields[field].type === 'Pointer') {\n        returnValue[`_p_${field}`] = pipeline[field];\n      } else {\n        returnValue[field] = this._parseAggregateArgs(schema, pipeline[field]);\n      }\n\n      if (field === 'objectId') {\n        returnValue['_id'] = returnValue[field];\n        delete returnValue[field];\n      } else if (field === 'createdAt') {\n        returnValue['_created_at'] = returnValue[field];\n        delete returnValue[field];\n      } else if (field === 'updatedAt') {\n        returnValue['_updated_at'] = returnValue[field];\n        delete returnValue[field];\n      }\n    }\n    return returnValue;\n  }\n\n  // This function is slightly different than the two above. MongoDB $group aggregate looks like:\n  //     { $group: { _id: <expression>, <field1>: { <accumulator1> : <expression1> }, ... } }\n  // The <expression> could be a column name, prefixed with the '$' character. We'll look for\n  // these <expression> and check to see if it is a 'Pointer' or if it's one of createdAt,\n  // updatedAt or objectId and change it accordingly.\n  _parseAggregateGroupArgs(schema: any, pipeline: any): any {\n    if (Array.isArray(pipeline)) {\n      return pipeline.map((value) => this._parseAggregateGroupArgs(schema, value));\n    } else if (typeof pipeline === 'object') {\n      const returnValue = {};\n      for (const field in pipeline) {\n        returnValue[field] = this._parseAggregateGroupArgs(schema, pipeline[field]);\n      }\n      return returnValue;\n    } else if (typeof pipeline === 'string') {\n      const field = pipeline.substring(1);\n      if (schema.fields[field] && schema.fields[field].type === 'Pointer') {\n        return `$_p_${field}`;\n      } else if (field == 'createdAt') {\n        return '$_created_at';\n      } else if (field == 'updatedAt') {\n        return '$_updated_at';\n      }\n    }\n    return pipeline;\n  }\n\n  // This function will attempt to convert the provided value to a Date object. Since this is part\n  // of an aggregation pipeline, the value can either be a string or it can be another object with\n  // an operator in it (like $gt, $lt, etc). Because of this I felt it was easier to make this a\n  // recursive method to traverse down to the \"leaf node\" which is going to be the string.\n  _convertToDate(value: any): any {\n    if (typeof value === 'string') {\n      return new Date(value);\n    }\n\n    const returnValue = {}\n    for (const field in value) {\n      returnValue[field] = this._convertToDate(value[field])\n    }\n    return returnValue;\n  }\n\n  _parseReadPreference(readPreference: ?string): ?string {\n    switch (readPreference) {\n    case 'PRIMARY':\n      readPreference = ReadPreference.PRIMARY;\n      break;\n    case 'PRIMARY_PREFERRED':\n      readPreference = ReadPreference.PRIMARY_PREFERRED;\n      break;\n    case 'SECONDARY':\n      readPreference = ReadPreference.SECONDARY;\n      break;\n    case 'SECONDARY_PREFERRED':\n      readPreference = ReadPreference.SECONDARY_PREFERRED;\n      break;\n    case 'NEAREST':\n      readPreference = ReadPreference.NEAREST;\n      break;\n    case undefined:\n      break;\n    default:\n      throw new Parse.Error(Parse.Error.INVALID_QUERY, 'Not supported read preference.');\n    }\n    return readPreference;\n  }\n\n  performInitialization(): Promise<void> {\n    return Promise.resolve();\n  }\n\n  createIndex(className: string, index: any) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.createIndex(index))\n      .catch(err => this.handleError(err));\n  }\n\n  createIndexes(className: string, indexes: any) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.createIndexes(indexes))\n      .catch(err => this.handleError(err));\n  }\n\n  createIndexesIfNeeded(className: string, fieldName: string, type: any) {\n    if (type && type.type === 'Polygon') {\n      const index = {\n        [fieldName]: '2dsphere'\n      };\n      return this.createIndex(className, index);\n    }\n    return Promise.resolve();\n  }\n\n  createTextIndexesIfNeeded(className: string, query: QueryType, schema: any): Promise<void> {\n    for(const fieldName in query) {\n      if (!query[fieldName] || !query[fieldName].$text) {\n        continue;\n      }\n      const existingIndexes = schema.indexes;\n      for (const key in existingIndexes) {\n        const index = existingIndexes[key];\n        if (index.hasOwnProperty(fieldName)) {\n          return Promise.resolve();\n        }\n      }\n      const indexName = `${fieldName}_text`;\n      const textIndex = {\n        [indexName]: { [fieldName]: 'text' }\n      };\n      return this.setIndexesWithSchemaFormat(className, textIndex, existingIndexes, schema.fields)\n        .catch((error) => {\n          if (error.code === 85) { // Index exist with different options\n            return this.setIndexesFromMongo(className);\n          }\n          throw error;\n        });\n    }\n    return Promise.resolve();\n  }\n\n  getIndexes(className: string) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.indexes())\n      .catch(err => this.handleError(err));\n  }\n\n  dropIndex(className: string, index: any) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.dropIndex(index))\n      .catch(err => this.handleError(err));\n  }\n\n  dropAllIndexes(className: string) {\n    return this._adaptiveCollection(className)\n      .then(collection => collection._mongoCollection.dropIndexes())\n      .catch(err => this.handleError(err));\n  }\n\n  updateSchemaWithIndexes(): Promise<any> {\n    return this.getAllClasses()\n      .then((classes) => {\n        const promises = classes.map((schema) => {\n          return this.setIndexesFromMongo(schema.className);\n        });\n        return Promise.all(promises);\n      })\n      .catch(err => this.handleError(err));\n  }\n}\n\nexport default MongoStorageAdapter;\n"]}