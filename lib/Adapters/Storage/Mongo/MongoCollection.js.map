{"version":3,"sources":["../../../../src/Adapters/Storage/Mongo/MongoCollection.js"],"names":["mongodb","require","Collection","MongoCollection","constructor","mongoCollection","_mongoCollection","find","query","skip","limit","sort","keys","maxTimeMS","readPreference","$score","score","$meta","_rawFind","catch","error","code","message","match","key","index","createIndex","then","findOperation","project","toArray","count","countOperation","distinct","field","aggregate","pipeline","insertOne","object","upsertOne","update","upsert","updateOne","updateMany","deleteMany","_ensureSparseUniqueIndexInBackground","indexRequest","Promise","resolve","reject","ensureIndex","unique","background","sparse","drop"],"mappings":"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","file":"MongoCollection.js","sourcesContent":["const mongodb = require('mongodb');\nconst Collection = mongodb.Collection;\n\nexport default class MongoCollection {\n  _mongoCollection:Collection;\n\n  constructor(mongoCollection:Collection) {\n    this._mongoCollection = mongoCollection;\n  }\n\n  // Does a find with \"smart indexing\".\n  // Currently this just means, if it needs a geoindex and there is\n  // none, then build the geoindex.\n  // This could be improved a lot but it's not clear if that's a good\n  // idea. Or even if this behavior is a good idea.\n  find(query, { skip, limit, sort, keys, maxTimeMS, readPreference } = {}) {\n    // Support for Full Text Search - $text\n    if(keys && keys.$score) {\n      delete keys.$score;\n      keys.score = {$meta: 'textScore'};\n    }\n    return this._rawFind(query, { skip, limit, sort, keys, maxTimeMS, readPreference })\n      .catch(error => {\n        // Check for \"no geoindex\" error\n        if (error.code != 17007 && !error.message.match(/unable to find index for .geoNear/)) {\n          throw error;\n        }\n        // Figure out what key needs an index\n        const key = error.message.match(/field=([A-Za-z_0-9]+) /)[1];\n        if (!key) {\n          throw error;\n        }\n\n        var index = {};\n        index[key] = '2d';\n        return this._mongoCollection.createIndex(index)\n          // Retry, but just once.\n          .then(() => this._rawFind(query, { skip, limit, sort, keys, maxTimeMS, readPreference }));\n      });\n  }\n\n  _rawFind(query, { skip, limit, sort, keys, maxTimeMS, readPreference } = {}) {\n    let findOperation = this._mongoCollection\n      .find(query, { skip, limit, sort, readPreference })\n\n    if (keys) {\n      findOperation = findOperation.project(keys);\n    }\n\n    if (maxTimeMS) {\n      findOperation = findOperation.maxTimeMS(maxTimeMS);\n    }\n\n    return findOperation.toArray();\n  }\n\n  count(query, { skip, limit, sort, maxTimeMS, readPreference } = {}) {\n    const countOperation = this._mongoCollection.count(query, { skip, limit, sort, maxTimeMS, readPreference });\n\n    return countOperation;\n  }\n\n  distinct(field, query) {\n    return this._mongoCollection.distinct(field, query);\n  }\n\n  aggregate(pipeline, { maxTimeMS, readPreference } = {}) {\n    return this._mongoCollection.aggregate(pipeline, { maxTimeMS, readPreference }).toArray();\n  }\n\n  insertOne(object) {\n    return this._mongoCollection.insertOne(object);\n  }\n\n  // Atomically updates data in the database for a single (first) object that matched the query\n  // If there is nothing that matches the query - does insert\n  // Postgres Note: `INSERT ... ON CONFLICT UPDATE` that is available since 9.5.\n  upsertOne(query, update) {\n    return this._mongoCollection.update(query, update, { upsert: true })\n  }\n\n  updateOne(query, update) {\n    return this._mongoCollection.updateOne(query, update);\n  }\n\n  updateMany(query, update) {\n    return this._mongoCollection.updateMany(query, update);\n  }\n\n  deleteMany(query) {\n    return this._mongoCollection.deleteMany(query);\n  }\n\n  _ensureSparseUniqueIndexInBackground(indexRequest) {\n    return new Promise((resolve, reject) => {\n      this._mongoCollection.ensureIndex(indexRequest, { unique: true, background: true, sparse: true }, (error) => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  drop() {\n    return this._mongoCollection.drop();\n  }\n}\n"]}