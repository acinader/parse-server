{"version":3,"sources":["../../../../src/Adapters/Storage/Mongo/MongoSchemaCollection.js"],"names":["mongoFieldToParseSchemaField","type","targetClass","slice","startsWith","length","nonFieldSchemaKeys","mongoSchemaFieldsToParseSchemaFields","schema","fieldNames","Object","keys","filter","key","indexOf","response","reduce","obj","fieldName","ACL","createdAt","updatedAt","objectId","emptyCLPS","freeze","find","get","create","update","delete","addField","defaultCLPS","mongoSchemaToParseSchema","mongoSchema","clps","indexes","_metadata","class_permissions","className","_id","fields","classLevelPermissions","_mongoSchemaQueryFromNameQuery","name","query","object","forEach","parseFieldTypeToMongoFieldType","MongoSchemaCollection","constructor","collection","_collection","_fetchAllSchemasFrom_SCHEMA","_rawFind","then","schemas","map","_fetchOneSchemaFrom_SCHEMA","limit","results","undefined","findAndDeleteSchema","_mongoCollection","findAndRemove","insertSchema","insertOne","result","ops","catch","error","code","Parse","Error","DUPLICATE_VALUE","updateSchema","updateOne","upsertSchema","upsertOne","addFieldIfNotExists","some","existingField","INCORRECT_TYPE","_TESTmongoSchemaToParseSchema"],"mappings":"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","file":"MongoSchemaCollection.js","sourcesContent":["import MongoCollection from './MongoCollection';\nimport Parse           from 'parse/node';\n\nfunction mongoFieldToParseSchemaField(type) {\n  if (type[0] === '*') {\n    return {\n      type: 'Pointer',\n      targetClass: type.slice(1),\n    };\n  }\n  if (type.startsWith('relation<')) {\n    return {\n      type: 'Relation',\n      targetClass: type.slice('relation<'.length, type.length - 1),\n    };\n  }\n  switch (type) {\n  case 'number':   return {type: 'Number'};\n  case 'string':   return {type: 'String'};\n  case 'boolean':  return {type: 'Boolean'};\n  case 'date':     return {type: 'Date'};\n  case 'map':\n  case 'object':   return {type: 'Object'};\n  case 'array':    return {type: 'Array'};\n  case 'geopoint': return {type: 'GeoPoint'};\n  case 'file':     return {type: 'File'};\n  case 'bytes':    return {type: 'Bytes'};\n  case 'polygon':  return {type: 'Polygon'};\n  }\n}\n\nconst nonFieldSchemaKeys = ['_id', '_metadata', '_client_permissions'];\nfunction mongoSchemaFieldsToParseSchemaFields(schema) {\n  var fieldNames = Object.keys(schema).filter(key => nonFieldSchemaKeys.indexOf(key) === -1);\n  var response = fieldNames.reduce((obj, fieldName) => {\n    obj[fieldName] = mongoFieldToParseSchemaField(schema[fieldName])\n    return obj;\n  }, {});\n  response.ACL = {type: 'ACL'};\n  response.createdAt = {type: 'Date'};\n  response.updatedAt = {type: 'Date'};\n  response.objectId = {type: 'String'};\n  return response;\n}\n\nconst emptyCLPS = Object.freeze({\n  find: {},\n  get: {},\n  create: {},\n  update: {},\n  delete: {},\n  addField: {},\n});\n\nconst defaultCLPS = Object.freeze({\n  find: {'*': true},\n  get: {'*': true},\n  create: {'*': true},\n  update: {'*': true},\n  delete: {'*': true},\n  addField: {'*': true},\n});\n\nfunction mongoSchemaToParseSchema(mongoSchema) {\n  let clps = defaultCLPS;\n  let indexes = {}\n  if (mongoSchema._metadata) {\n    if (mongoSchema._metadata.class_permissions) {\n      clps = {...emptyCLPS, ...mongoSchema._metadata.class_permissions};\n    }\n    if (mongoSchema._metadata.indexes) {\n      indexes = {...mongoSchema._metadata.indexes};\n    }\n  }\n  return {\n    className: mongoSchema._id,\n    fields: mongoSchemaFieldsToParseSchemaFields(mongoSchema),\n    classLevelPermissions: clps,\n    indexes: indexes,\n  };\n}\n\nfunction _mongoSchemaQueryFromNameQuery(name: string, query) {\n  const object = { _id: name };\n  if (query) {\n    Object.keys(query).forEach(key => {\n      object[key] = query[key];\n    });\n  }\n  return object;\n}\n\n\n// Returns a type suitable for inserting into mongo _SCHEMA collection.\n// Does no validation. That is expected to be done in Parse Server.\nfunction parseFieldTypeToMongoFieldType({ type, targetClass }) {\n  switch (type) {\n  case 'Pointer':  return `*${targetClass}`;\n  case 'Relation': return `relation<${targetClass}>`;\n  case 'Number':   return 'number';\n  case 'String':   return 'string';\n  case 'Boolean':  return 'boolean';\n  case 'Date':     return 'date';\n  case 'Object':   return 'object';\n  case 'Array':    return 'array';\n  case 'GeoPoint': return 'geopoint';\n  case 'File':     return 'file';\n  case 'Bytes':    return 'bytes';\n  case 'Polygon':  return 'polygon';\n  }\n}\n\nclass MongoSchemaCollection {\n  _collection: MongoCollection;\n\n  constructor(collection: MongoCollection) {\n    this._collection = collection;\n  }\n\n  _fetchAllSchemasFrom_SCHEMA() {\n    return this._collection._rawFind({})\n      .then(schemas => schemas.map(mongoSchemaToParseSchema));\n  }\n\n  _fetchOneSchemaFrom_SCHEMA(name: string) {\n    return this._collection._rawFind(_mongoSchemaQueryFromNameQuery(name), { limit: 1 }).then(results => {\n      if (results.length === 1) {\n        return mongoSchemaToParseSchema(results[0]);\n      } else {\n        throw undefined;\n      }\n    });\n  }\n\n  // Atomically find and delete an object based on query.\n  findAndDeleteSchema(name: string) {\n    return this._collection._mongoCollection.findAndRemove(_mongoSchemaQueryFromNameQuery(name), []);\n  }\n\n  insertSchema(schema: any) {\n    return this._collection.insertOne(schema)\n      .then(result => mongoSchemaToParseSchema(result.ops[0]))\n      .catch(error => {\n        if (error.code === 11000) { //Mongo's duplicate key error\n          throw new Parse.Error(Parse.Error.DUPLICATE_VALUE, 'Class already exists.');\n        } else {\n          throw error;\n        }\n      })\n  }\n\n  updateSchema(name: string, update) {\n    return this._collection.updateOne(_mongoSchemaQueryFromNameQuery(name), update);\n  }\n\n  upsertSchema(name: string, query: string, update) {\n    return this._collection.upsertOne(_mongoSchemaQueryFromNameQuery(name, query), update);\n  }\n\n  // Add a field to the schema. If database does not support the field\n  // type (e.g. mongo doesn't support more than one GeoPoint in a class) reject with an \"Incorrect Type\"\n  // Parse error with a desciptive message. If the field already exists, this function must\n  // not modify the schema, and must reject with DUPLICATE_VALUE error.\n  // If this is called for a class that doesn't exist, this function must create that class.\n\n  // TODO: throw an error if an unsupported field type is passed. Deciding whether a type is supported\n  // should be the job of the adapter. Some adapters may not support GeoPoint at all. Others may\n  // Support additional types that Mongo doesn't, like Money, or something.\n\n  // TODO: don't spend an extra query on finding the schema if the type we are trying to add isn't a GeoPoint.\n  addFieldIfNotExists(className: string, fieldName: string, type: string) {\n    return this._fetchOneSchemaFrom_SCHEMA(className)\n      .then(schema => {\n        // If a field with this name already exists, it will be handled elsewhere.\n        if (schema.fields[fieldName] != undefined) {\n          return;\n        }\n        // The schema exists. Check for existing GeoPoints.\n        if (type.type === 'GeoPoint') {\n        // Make sure there are not other geopoint fields\n          if (Object.keys(schema.fields).some(existingField => schema.fields[existingField].type === 'GeoPoint')) {\n            throw new Parse.Error(Parse.Error.INCORRECT_TYPE, 'MongoDB only supports one GeoPoint field in a class.');\n          }\n        }\n        return;\n      }, error => {\n      // If error is undefined, the schema doesn't exist, and we can create the schema with the field.\n      // If some other error, reject with it.\n        if (error === undefined) {\n          return;\n        }\n        throw error;\n      })\n      .then(() => {\n      // We use $exists and $set to avoid overwriting the field type if it\n      // already exists. (it could have added inbetween the last query and the update)\n        return this.upsertSchema(\n          className,\n          { [fieldName]: { '$exists': false } },\n          { '$set' : { [fieldName]: parseFieldTypeToMongoFieldType(type) } }\n        );\n      });\n  }\n}\n\n// Exported for testing reasons and because we haven't moved all mongo schema format\n// related logic into the database adapter yet.\nMongoSchemaCollection._TESTmongoSchemaToParseSchema = mongoSchemaToParseSchema\nMongoSchemaCollection.parseFieldTypeToMongoFieldType = parseFieldTypeToMongoFieldType\n\nexport default MongoSchemaCollection\n"]}