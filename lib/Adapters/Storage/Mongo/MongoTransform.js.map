{"version":3,"sources":["../../../../src/Adapters/Storage/Mongo/MongoTransform.js"],"names":["mongodb","require","Parse","transformKey","className","fieldName","schema","fields","__type","type","transformKeyValueForUpdate","restKey","restValue","parseFormatSchema","key","timeField","value","parseInt","transformTopLevelAtom","CannotTransform","Date","indexOf","Array","map","transformInteriorValue","transformUpdateOperator","mapValues","isRegex","RegExp","isStartsWithRegex","matches","toString","match","isAllValuesRegexOrNone","values","isArray","length","firstValuesIsRegex","i","isAnyValueRegex","some","Object","keys","includes","Error","INVALID_NESTED_KEY","transformInteriorAtom","valueAsDate","transformQueryKeyValue","subQuery","transformWhere","authDataMatch","provider","expectedTypeIsArray","expectedTypeIsPointer","field","transformedConstraint","transformConstraint","$text","$elemMatch","INVALID_JSON","restWhere","mongoWhere","out","parseObjectKeyValueToMongoObjectKeyValue","transformedValue","coercedToDate","INVALID_KEY_NAME","parseObjectToMongoObjectForCreate","restCreate","addLegacyACL","mongoCreate","undefined","createdAt","_created_at","iso","updatedAt","_updated_at","transformUpdate","restUpdate","mongoUpdate","acl","_rperm","_wperm","_acl","$set","__op","arg","restObject","restObjectCopy","forEach","entry","w","r","atom","objectId","DateCoder","isValidJSON","JSONToDatabase","BytesCoder","$regex","targetClass","GeoPointCoder","PolygonCoder","FileCoder","INTERNAL_SERVER_ERROR","relativeTimeToDate","text","now","toLowerCase","parts","split","filter","part","future","past","status","info","slice","pairs","push","shift","seconds","num","interval","val","Number","isInteger","milliseconds","result","valueOf","constraint","inArray","transformFunction","transformer","JSON","stringify","sort","reverse","answer","$relativeTime","parserResult","log","arr","_","flatMap","s","$nin","search","$search","$term","$language","$caseSensitive","$diacriticSensitive","point","longitude","latitude","COMMAND_UNAVAILABLE","box","polygon","centerSphere","points","coordinates","GeoPoint","_validate","distance","isNaN","$geometry","amount","objects","flatten","toAdd","mongoOp","Add","AddUnique","toRemove","object","iterator","nestedMongoObjectToNestedParseObject","mongoObject","_encode","Long","toNumber","Double","isValidDatabaseObject","databaseToJSON","hasOwnProperty","toJSON","transformPointerString","pointerString","objData","mongoObjectToParseObject","_hashed_password","newKey","substring","relationFieldNames","relationFields","relationFieldName","json","base64Pattern","isBase64Value","test","buffer","base64","Binary","Buffer","coords","coord","parseFloat","unique","item","index","ar","foundIndex","pt","name","module","exports"],"mappings":"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","file":"MongoTransform.js","sourcesContent":["import log from '../../../logger';\nimport _   from 'lodash';\nvar mongodb = require('mongodb');\nvar Parse = require('parse/node').Parse;\n\nconst transformKey = (className, fieldName, schema) => {\n  // Check if the schema is known since it's a built-in field.\n  switch(fieldName) {\n  case 'objectId': return '_id';\n  case 'createdAt': return '_created_at';\n  case 'updatedAt': return '_updated_at';\n  case 'sessionToken': return '_session_token';\n  case 'lastUsed': return '_last_used';\n  case 'timesUsed': return 'times_used';\n  }\n\n  if (schema.fields[fieldName] && schema.fields[fieldName].__type == 'Pointer') {\n    fieldName = '_p_' + fieldName;\n  } else if (schema.fields[fieldName] && schema.fields[fieldName].type == 'Pointer') {\n    fieldName = '_p_' + fieldName;\n  }\n\n  return fieldName;\n}\n\nconst transformKeyValueForUpdate = (className, restKey, restValue, parseFormatSchema) => {\n  // Check if the schema is known since it's a built-in field.\n  var key = restKey;\n  var timeField = false;\n  switch(key) {\n  case 'objectId':\n  case '_id':\n    if (className === '_GlobalConfig') {\n      return {\n        key: key,\n        value: parseInt(restValue)\n      }\n    }\n    key = '_id';\n    break;\n  case 'createdAt':\n  case '_created_at':\n    key = '_created_at';\n    timeField = true;\n    break;\n  case 'updatedAt':\n  case '_updated_at':\n    key = '_updated_at';\n    timeField = true;\n    break;\n  case 'sessionToken':\n  case '_session_token':\n    key = '_session_token';\n    break;\n  case 'expiresAt':\n  case '_expiresAt':\n    key = 'expiresAt';\n    timeField = true;\n    break;\n  case '_email_verify_token_expires_at':\n    key = '_email_verify_token_expires_at';\n    timeField = true;\n    break;\n  case '_account_lockout_expires_at':\n    key = '_account_lockout_expires_at';\n    timeField = true;\n    break;\n  case '_failed_login_count':\n    key = '_failed_login_count';\n    break;\n  case '_perishable_token_expires_at':\n    key = '_perishable_token_expires_at';\n    timeField = true;\n    break;\n  case '_password_changed_at':\n    key = '_password_changed_at';\n    timeField = true;\n    break;\n  case '_rperm':\n  case '_wperm':\n    return {key: key, value: restValue};\n  case 'lastUsed':\n  case '_last_used':\n    key = '_last_used';\n    timeField = true;\n    break;\n  case 'timesUsed':\n  case 'times_used':\n    key = 'times_used';\n    timeField = true;\n    break;\n  }\n\n  if ((parseFormatSchema.fields[key] && parseFormatSchema.fields[key].type === 'Pointer') || (!parseFormatSchema.fields[key] && restValue && restValue.__type == 'Pointer')) {\n    key = '_p_' + key;\n  }\n\n  // Handle atomic values\n  var value = transformTopLevelAtom(restValue);\n  if (value !== CannotTransform) {\n    if (timeField && (typeof value === 'string')) {\n      value = new Date(value);\n    }\n    if (restKey.indexOf('.') > 0) {\n      return {key, value: restValue}\n    }\n    return {key, value};\n  }\n\n  // Handle arrays\n  if (restValue instanceof Array) {\n    value = restValue.map(transformInteriorValue);\n    return {key, value};\n  }\n\n  // Handle update operators\n  if (typeof restValue === 'object' && '__op' in restValue) {\n    return {key, value: transformUpdateOperator(restValue, false)};\n  }\n\n  // Handle normal objects by recursing\n  value = mapValues(restValue, transformInteriorValue);\n  return {key, value};\n}\n\nconst isRegex = value => {\n  return value && (value instanceof RegExp)\n}\n\nconst isStartsWithRegex = value => {\n  if (!isRegex(value)) {\n    return false;\n  }\n\n  const matches = value.toString().match(/\\/\\^\\\\Q.*\\\\E\\//);\n  return !!matches;\n}\n\nconst isAllValuesRegexOrNone = values => {\n  if (!values || !Array.isArray(values) || values.length === 0) {\n    return true;\n  }\n\n  const firstValuesIsRegex = isStartsWithRegex(values[0]);\n  if (values.length === 1) {\n    return firstValuesIsRegex;\n  }\n\n  for (let i = 1, length = values.length; i < length; ++i) {\n    if (firstValuesIsRegex !== isStartsWithRegex(values[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nconst isAnyValueRegex = values => {\n  return values.some(function (value) {\n    return isRegex(value);\n  });\n}\n\nconst transformInteriorValue = restValue => {\n  if (restValue !== null && typeof restValue === 'object' && Object.keys(restValue).some(key => key.includes('$') || key.includes('.'))) {\n    throw new Parse.Error(Parse.Error.INVALID_NESTED_KEY, \"Nested keys should not contain the '$' or '.' characters\");\n  }\n  // Handle atomic values\n  var value = transformInteriorAtom(restValue);\n  if (value !== CannotTransform) {\n    return value;\n  }\n\n  // Handle arrays\n  if (restValue instanceof Array) {\n    return restValue.map(transformInteriorValue);\n  }\n\n  // Handle update operators\n  if (typeof restValue === 'object' && '__op' in restValue) {\n    return transformUpdateOperator(restValue, true);\n  }\n\n  // Handle normal objects by recursing\n  return mapValues(restValue, transformInteriorValue);\n}\n\nconst valueAsDate = value => {\n  if (typeof value === 'string') {\n    return new Date(value);\n  } else if (value instanceof Date) {\n    return value;\n  }\n  return false;\n}\n\nfunction transformQueryKeyValue(className, key, value, schema) {\n  switch(key) {\n  case 'createdAt':\n    if (valueAsDate(value)) {\n      return {key: '_created_at', value: valueAsDate(value)}\n    }\n    key = '_created_at';\n    break;\n  case 'updatedAt':\n    if (valueAsDate(value)) {\n      return {key: '_updated_at', value: valueAsDate(value)}\n    }\n    key = '_updated_at';\n    break;\n  case 'expiresAt':\n    if (valueAsDate(value)) {\n      return {key: 'expiresAt', value: valueAsDate(value)}\n    }\n    break;\n  case '_email_verify_token_expires_at':\n    if (valueAsDate(value)) {\n      return {key: '_email_verify_token_expires_at', value: valueAsDate(value)}\n    }\n    break;\n  case 'objectId': {\n    if (className === '_GlobalConfig') {\n      value = parseInt(value);\n    }\n    return {key: '_id', value}\n  }\n  case '_account_lockout_expires_at':\n    if (valueAsDate(value)) {\n      return {key: '_account_lockout_expires_at', value: valueAsDate(value)}\n    }\n    break;\n  case '_failed_login_count':\n    return {key, value};\n  case 'sessionToken': return {key: '_session_token', value}\n  case '_perishable_token_expires_at':\n    if (valueAsDate(value)) {\n      return { key: '_perishable_token_expires_at', value: valueAsDate(value) }\n    }\n    break;\n  case '_password_changed_at':\n    if (valueAsDate(value)) {\n      return { key: '_password_changed_at', value: valueAsDate(value) }\n    }\n    break;\n  case '_rperm':\n  case '_wperm':\n  case '_perishable_token':\n  case '_email_verify_token': return {key, value}\n  case '$or':\n  case '$and':\n  case '$nor':\n    return {key: key, value: value.map(subQuery => transformWhere(className, subQuery, schema))};\n  case 'lastUsed':\n    if (valueAsDate(value)) {\n      return {key: '_last_used', value: valueAsDate(value)}\n    }\n    key = '_last_used';\n    break;\n  case 'timesUsed':\n    return {key: 'times_used', value: value};\n  default: {\n    // Other auth data\n    const authDataMatch = key.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/);\n    if (authDataMatch) {\n      const provider = authDataMatch[1];\n      // Special-case auth data.\n      return {key: `_auth_data_${provider}.id`, value};\n    }\n  }\n  }\n\n  const expectedTypeIsArray =\n    schema &&\n    schema.fields[key] &&\n    schema.fields[key].type === 'Array';\n\n  const expectedTypeIsPointer =\n    schema &&\n    schema.fields[key] &&\n    schema.fields[key].type === 'Pointer';\n\n  const field = schema && schema.fields[key];\n  if (expectedTypeIsPointer || !schema && value && value.__type === 'Pointer') {\n    key = '_p_' + key;\n  }\n\n  // Handle query constraints\n  const transformedConstraint = transformConstraint(value, field);\n  if (transformedConstraint !== CannotTransform) {\n    if (transformedConstraint.$text) {\n      return {key: '$text', value: transformedConstraint.$text};\n    }\n    if (transformedConstraint.$elemMatch) {\n      return { key: '$nor', value: [{ [key]: transformedConstraint }] };\n    }\n    return {key, value: transformedConstraint};\n  }\n\n  if (expectedTypeIsArray && !(value instanceof Array)) {\n    return {key, value: { '$all' : [transformInteriorAtom(value)] }};\n  }\n\n  // Handle atomic values\n  if (transformTopLevelAtom(value) !== CannotTransform) {\n    return {key, value: transformTopLevelAtom(value)};\n  } else {\n    throw new Parse.Error(Parse.Error.INVALID_JSON, `You cannot use ${value} as a query parameter.`);\n  }\n}\n\n// Main exposed method to help run queries.\n// restWhere is the \"where\" clause in REST API form.\n// Returns the mongo form of the query.\nfunction transformWhere(className, restWhere, schema) {\n  const mongoWhere = {};\n  for (const restKey in restWhere) {\n    const out = transformQueryKeyValue(className, restKey, restWhere[restKey], schema);\n    mongoWhere[out.key] = out.value;\n  }\n  return mongoWhere;\n}\n\nconst parseObjectKeyValueToMongoObjectKeyValue = (restKey, restValue, schema) => {\n  // Check if the schema is known since it's a built-in field.\n  let transformedValue;\n  let coercedToDate;\n  switch(restKey) {\n  case 'objectId': return {key: '_id', value: restValue};\n  case 'expiresAt':\n    transformedValue = transformTopLevelAtom(restValue);\n    coercedToDate = typeof transformedValue === 'string' ? new Date(transformedValue) : transformedValue\n    return {key: 'expiresAt', value: coercedToDate};\n  case '_email_verify_token_expires_at':\n    transformedValue = transformTopLevelAtom(restValue);\n    coercedToDate = typeof transformedValue === 'string' ? new Date(transformedValue) : transformedValue\n    return {key: '_email_verify_token_expires_at', value: coercedToDate};\n  case '_account_lockout_expires_at':\n    transformedValue = transformTopLevelAtom(restValue);\n    coercedToDate = typeof transformedValue === 'string' ? new Date(transformedValue) : transformedValue\n    return {key: '_account_lockout_expires_at', value: coercedToDate};\n  case '_perishable_token_expires_at':\n    transformedValue = transformTopLevelAtom(restValue);\n    coercedToDate = typeof transformedValue === 'string' ? new Date(transformedValue) : transformedValue\n    return { key: '_perishable_token_expires_at', value: coercedToDate };\n  case '_password_changed_at':\n    transformedValue = transformTopLevelAtom(restValue);\n    coercedToDate = typeof transformedValue === 'string' ? new Date(transformedValue) : transformedValue\n    return { key: '_password_changed_at', value: coercedToDate };\n  case '_failed_login_count':\n  case '_rperm':\n  case '_wperm':\n  case '_email_verify_token':\n  case '_hashed_password':\n  case '_perishable_token': return {key: restKey, value: restValue};\n  case 'sessionToken': return {key: '_session_token', value: restValue};\n  default:\n    // Auth data should have been transformed already\n    if (restKey.match(/^authData\\.([a-zA-Z0-9_]+)\\.id$/)) {\n      throw new Parse.Error(Parse.Error.INVALID_KEY_NAME, 'can only query on ' + restKey);\n    }\n    // Trust that the auth data has been transformed and save it directly\n    if (restKey.match(/^_auth_data_[a-zA-Z0-9_]+$/)) {\n      return {key: restKey, value: restValue};\n    }\n  }\n  //skip straight to transformTopLevelAtom for Bytes, they don't show up in the schema for some reason\n  if (restValue && restValue.__type !== 'Bytes') {\n    //Note: We may not know the type of a field here, as the user could be saving (null) to a field\n    //That never existed before, meaning we can't infer the type.\n    if (schema.fields[restKey] && schema.fields[restKey].type == 'Pointer' || restValue.__type == 'Pointer') {\n      restKey = '_p_' + restKey;\n    }\n  }\n\n  // Handle atomic values\n  var value = transformTopLevelAtom(restValue);\n  if (value !== CannotTransform) {\n    return {key: restKey, value: value};\n  }\n\n  // ACLs are handled before this method is called\n  // If an ACL key still exists here, something is wrong.\n  if (restKey === 'ACL') {\n    throw 'There was a problem transforming an ACL.';\n  }\n\n  // Handle arrays\n  if (restValue instanceof Array) {\n    value = restValue.map(transformInteriorValue);\n    return {key: restKey, value: value};\n  }\n\n  // Handle normal objects by recursing\n  if (Object.keys(restValue).some(key => key.includes('$') || key.includes('.'))) {\n    throw new Parse.Error(Parse.Error.INVALID_NESTED_KEY, \"Nested keys should not contain the '$' or '.' characters\");\n  }\n  value = mapValues(restValue, transformInteriorValue);\n  return {key: restKey, value};\n}\n\nconst parseObjectToMongoObjectForCreate = (className, restCreate, schema) => {\n  restCreate = addLegacyACL(restCreate);\n  const mongoCreate = {}\n  for (const restKey in restCreate) {\n    if (restCreate[restKey] && restCreate[restKey].__type === 'Relation') {\n      continue;\n    }\n    const { key, value } = parseObjectKeyValueToMongoObjectKeyValue(\n      restKey,\n      restCreate[restKey],\n      schema\n    );\n    if (value !== undefined) {\n      mongoCreate[key] = value;\n    }\n  }\n\n  // Use the legacy mongo format for createdAt and updatedAt\n  if (mongoCreate.createdAt) {\n    mongoCreate._created_at = new Date(mongoCreate.createdAt.iso || mongoCreate.createdAt);\n    delete mongoCreate.createdAt;\n  }\n  if (mongoCreate.updatedAt) {\n    mongoCreate._updated_at = new Date(mongoCreate.updatedAt.iso || mongoCreate.updatedAt);\n    delete mongoCreate.updatedAt;\n  }\n\n  return mongoCreate;\n}\n\n// Main exposed method to help update old objects.\nconst transformUpdate = (className, restUpdate, parseFormatSchema) => {\n  const mongoUpdate = {};\n  const acl = addLegacyACL(restUpdate);\n  if (acl._rperm || acl._wperm || acl._acl) {\n    mongoUpdate.$set = {};\n    if (acl._rperm) {\n      mongoUpdate.$set._rperm = acl._rperm;\n    }\n    if (acl._wperm) {\n      mongoUpdate.$set._wperm = acl._wperm;\n    }\n    if (acl._acl) {\n      mongoUpdate.$set._acl = acl._acl;\n    }\n  }\n  for (var restKey in restUpdate) {\n    if (restUpdate[restKey] && restUpdate[restKey].__type === 'Relation') {\n      continue;\n    }\n    var out = transformKeyValueForUpdate(className, restKey, restUpdate[restKey], parseFormatSchema);\n\n    // If the output value is an object with any $ keys, it's an\n    // operator that needs to be lifted onto the top level update\n    // object.\n    if (typeof out.value === 'object' && out.value !== null && out.value.__op) {\n      mongoUpdate[out.value.__op] = mongoUpdate[out.value.__op] || {};\n      mongoUpdate[out.value.__op][out.key] = out.value.arg;\n    } else {\n      mongoUpdate['$set'] = mongoUpdate['$set'] || {};\n      mongoUpdate['$set'][out.key] = out.value;\n    }\n  }\n\n  return mongoUpdate;\n}\n\n// Add the legacy _acl format.\nconst addLegacyACL = restObject => {\n  const restObjectCopy = {...restObject};\n  const _acl = {};\n\n  if (restObject._wperm) {\n    restObject._wperm.forEach(entry => {\n      _acl[entry] = { w: true };\n    });\n    restObjectCopy._acl = _acl;\n  }\n\n  if (restObject._rperm) {\n    restObject._rperm.forEach(entry => {\n      if (!(entry in _acl)) {\n        _acl[entry] = { r: true };\n      } else {\n        _acl[entry].r = true;\n      }\n    });\n    restObjectCopy._acl = _acl;\n  }\n\n  return restObjectCopy;\n}\n\n\n// A sentinel value that helper transformations return when they\n// cannot perform a transformation\nfunction CannotTransform() {}\n\nconst transformInteriorAtom = (atom) => {\n  // TODO: check validity harder for the __type-defined types\n  if (typeof atom === 'object' && atom && !(atom instanceof Date) && atom.__type === 'Pointer') {\n    return {\n      __type: 'Pointer',\n      className: atom.className,\n      objectId: atom.objectId\n    };\n  } else if (typeof atom === 'function' || typeof atom === 'symbol') {\n    throw new Parse.Error(Parse.Error.INVALID_JSON, `cannot transform value: ${atom}`);\n  } else if (DateCoder.isValidJSON(atom)) {\n    return DateCoder.JSONToDatabase(atom);\n  } else if (BytesCoder.isValidJSON(atom)) {\n    return BytesCoder.JSONToDatabase(atom);\n  } else if (typeof atom === 'object' && atom && atom.$regex !== undefined) {\n    return new RegExp(atom.$regex);\n  } else {\n    return atom;\n  }\n}\n\n// Helper function to transform an atom from REST format to Mongo format.\n// An atom is anything that can't contain other expressions. So it\n// includes things where objects are used to represent other\n// datatypes, like pointers and dates, but it does not include objects\n// or arrays with generic stuff inside.\n// Raises an error if this cannot possibly be valid REST format.\n// Returns CannotTransform if it's just not an atom\nfunction transformTopLevelAtom(atom, field) {\n  switch(typeof atom) {\n  case 'number':\n  case 'boolean':\n  case 'undefined':\n    return atom;\n  case 'string':\n    if (field && field.type === 'Pointer') {\n      return `${field.targetClass}$${atom}`;\n    }\n    return atom;\n  case 'symbol':\n  case 'function':\n    throw new Parse.Error(Parse.Error.INVALID_JSON, `cannot transform value: ${atom}`);\n  case 'object':\n    if (atom instanceof Date) {\n      // Technically dates are not rest format, but, it seems pretty\n      // clear what they should be transformed to, so let's just do it.\n      return atom;\n    }\n\n    if (atom === null) {\n      return atom;\n    }\n\n    // TODO: check validity harder for the __type-defined types\n    if (atom.__type == 'Pointer') {\n      return `${atom.className}$${atom.objectId}`;\n    }\n    if (DateCoder.isValidJSON(atom)) {\n      return DateCoder.JSONToDatabase(atom);\n    }\n    if (BytesCoder.isValidJSON(atom)) {\n      return BytesCoder.JSONToDatabase(atom);\n    }\n    if (GeoPointCoder.isValidJSON(atom)) {\n      return GeoPointCoder.JSONToDatabase(atom);\n    }\n    if (PolygonCoder.isValidJSON(atom)) {\n      return PolygonCoder.JSONToDatabase(atom);\n    }\n    if (FileCoder.isValidJSON(atom)) {\n      return FileCoder.JSONToDatabase(atom);\n    }\n    return CannotTransform;\n\n  default:\n    // I don't think typeof can ever let us get here\n    throw new Parse.Error(Parse.Error.INTERNAL_SERVER_ERROR, `really did not expect value: ${atom}`);\n  }\n}\n\nfunction relativeTimeToDate(text, now = new Date()) {\n  text = text.toLowerCase();\n\n  let parts = text.split(' ');\n\n  // Filter out whitespace\n  parts = parts.filter((part) => part !== '');\n\n  const future = parts[0] === 'in';\n  const past = parts[parts.length - 1] === 'ago';\n\n  if (!future && !past && text !== 'now') {\n    return { status: 'error', info: \"Time should either start with 'in' or end with 'ago'\" };\n  }\n\n  if (future && past) {\n    return {\n      status: 'error',\n      info: \"Time cannot have both 'in' and 'ago'\",\n    };\n  }\n\n  // strip the 'ago' or 'in'\n  if (future) {\n    parts = parts.slice(1);\n  } else { // past\n    parts = parts.slice(0, parts.length - 1);\n  }\n\n  if (parts.length % 2 !== 0 && text !== 'now') {\n    return {\n      status: 'error',\n      info: 'Invalid time string. Dangling unit or number.',\n    };\n  }\n\n  const pairs = [];\n  while(parts.length) {\n    pairs.push([ parts.shift(), parts.shift() ]);\n  }\n\n  let seconds = 0;\n  for (const [num, interval] of pairs) {\n    const val = Number(num);\n    if (!Number.isInteger(val)) {\n      return {\n        status: 'error',\n        info: `'${num}' is not an integer.`,\n      };\n    }\n\n    switch(interval) {\n    case 'yr':\n    case 'yrs':\n    case 'year':\n    case 'years':\n      seconds += val * 31536000; // 365 * 24 * 60 * 60\n      break;\n\n    case 'wk':\n    case 'wks':\n    case 'week':\n    case 'weeks':\n      seconds += val * 604800; // 7 * 24 * 60 * 60\n      break;\n\n    case 'd':\n    case 'day':\n    case 'days':\n      seconds += val * 86400; // 24 * 60 * 60\n      break;\n\n    case 'hr':\n    case 'hrs':\n    case 'hour':\n    case 'hours':\n      seconds += val * 3600; // 60 * 60\n      break;\n\n    case 'min':\n    case 'mins':\n    case 'minute':\n    case 'minutes':\n      seconds += val * 60;\n      break;\n\n    case 'sec':\n    case 'secs':\n    case 'second':\n    case 'seconds':\n      seconds += val;\n      break;\n\n    default:\n      return {\n        status: 'error',\n        info: `Invalid interval: '${interval}'`,\n      };\n    }\n  }\n\n  const milliseconds = seconds * 1000;\n  if (future) {\n    return {\n      status: 'success',\n      info: 'future',\n      result: new Date(now.valueOf() + milliseconds)\n    };\n  } else if (past) {\n    return {\n      status: 'success',\n      info: 'past',\n      result: new Date(now.valueOf() - milliseconds)\n    };\n  } else {\n    return {\n      status: 'success',\n      info: 'present',\n      result: new Date(now.valueOf())\n    }\n  }\n}\n\n// Transforms a query constraint from REST API format to Mongo format.\n// A constraint is something with fields like $lt.\n// If it is not a valid constraint but it could be a valid something\n// else, return CannotTransform.\n// inArray is whether this is an array field.\nfunction transformConstraint(constraint, field) {\n  const inArray = field && field.type && field.type === 'Array';\n  if (typeof constraint !== 'object' || !constraint) {\n    return CannotTransform;\n  }\n  const transformFunction = inArray ? transformInteriorAtom : transformTopLevelAtom;\n  const transformer = (atom) => {\n    const result = transformFunction(atom, field);\n    if (result === CannotTransform) {\n      throw new Parse.Error(Parse.Error.INVALID_JSON, `bad atom: ${JSON.stringify(atom)}`);\n    }\n    return result;\n  }\n  // keys is the constraints in reverse alphabetical order.\n  // This is a hack so that:\n  //   $regex is handled before $options\n  //   $nearSphere is handled before $maxDistance\n  var keys = Object.keys(constraint).sort().reverse();\n  var answer = {};\n  for (var key of keys) {\n    switch(key) {\n    case '$lt':\n    case '$lte':\n    case '$gt':\n    case '$gte':\n    case '$exists':\n    case '$ne':\n    case '$eq': {\n      const val = constraint[key];\n      if (val && typeof val === 'object' && val.$relativeTime) {\n        if (field && field.type !== 'Date') {\n          throw new Parse.Error(Parse.Error.INVALID_JSON, '$relativeTime can only be used with Date field');\n        }\n\n        switch (key) {\n        case '$exists':\n        case '$ne':\n        case '$eq':\n          throw new Parse.Error(Parse.Error.INVALID_JSON, '$relativeTime can only be used with the $lt, $lte, $gt, and $gte operators');\n        }\n\n        const parserResult = relativeTimeToDate(val.$relativeTime);\n        if (parserResult.status === 'success') {\n          answer[key] = parserResult.result;\n          break;\n        }\n\n        log.info('Error while parsing relative date', parserResult);\n        throw new Parse.Error(Parse.Error.INVALID_JSON, `bad $relativeTime (${key}) value. ${parserResult.info}`);\n      }\n\n      answer[key] = transformer(val);\n      break;\n    }\n\n    case '$in':\n    case '$nin': {\n      const arr = constraint[key];\n      if (!(arr instanceof Array)) {\n        throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad ' + key + ' value');\n      }\n      answer[key] = _.flatMap(arr, value => {\n        return ((atom) => {\n          if (Array.isArray(atom)) {\n            return value.map(transformer);\n          } else {\n            return transformer(atom);\n          }\n        })(value);\n      });\n      break;\n    }\n    case '$all': {\n      const arr = constraint[key];\n      if (!(arr instanceof Array)) {\n        throw new Parse.Error(Parse.Error.INVALID_JSON,\n          'bad ' + key + ' value');\n      }\n      answer[key] = arr.map(transformInteriorAtom);\n\n      const values = answer[key];\n      if (isAnyValueRegex(values) && !isAllValuesRegexOrNone(values)) {\n        throw new Parse.Error(Parse.Error.INVALID_JSON, 'All $all values must be of regex type or none: '\n          + values);\n      }\n\n      break;\n    }\n    case '$regex':\n      var s = constraint[key];\n      if (typeof s !== 'string') {\n        throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad regex: ' + s);\n      }\n      answer[key] = s;\n      break;\n\n    case '$containedBy': {\n      const arr = constraint[key];\n      if (!(arr instanceof Array)) {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $containedBy: should be an array`\n        );\n      }\n      answer.$elemMatch = {\n        $nin: arr.map(transformer)\n      };\n      break;\n    }\n    case '$options':\n      answer[key] = constraint[key];\n      break;\n\n    case '$text': {\n      const search = constraint[key].$search;\n      if (typeof search !== 'object') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $text: $search, should be object`\n        );\n      }\n      if (!search.$term || typeof search.$term !== 'string') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $text: $term, should be string`\n        );\n      } else {\n        answer[key] = {\n          '$search': search.$term\n        }\n      }\n      if (search.$language && typeof search.$language !== 'string') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $text: $language, should be string`\n        );\n      } else if (search.$language) {\n        answer[key].$language = search.$language;\n      }\n      if (search.$caseSensitive && typeof search.$caseSensitive !== 'boolean') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $text: $caseSensitive, should be boolean`\n        );\n      } else if (search.$caseSensitive) {\n        answer[key].$caseSensitive = search.$caseSensitive;\n      }\n      if (search.$diacriticSensitive && typeof search.$diacriticSensitive !== 'boolean') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $text: $diacriticSensitive, should be boolean`\n        );\n      } else if (search.$diacriticSensitive) {\n        answer[key].$diacriticSensitive = search.$diacriticSensitive;\n      }\n      break;\n    }\n    case '$nearSphere':\n      var point = constraint[key];\n      answer[key] = [point.longitude, point.latitude];\n      break;\n\n    case '$maxDistance':\n      answer[key] = constraint[key];\n      break;\n\n    // The SDKs don't seem to use these but they are documented in the\n    // REST API docs.\n    case '$maxDistanceInRadians':\n      answer['$maxDistance'] = constraint[key];\n      break;\n    case '$maxDistanceInMiles':\n      answer['$maxDistance'] = constraint[key] / 3959;\n      break;\n    case '$maxDistanceInKilometers':\n      answer['$maxDistance'] = constraint[key] / 6371;\n      break;\n\n    case '$select':\n    case '$dontSelect':\n      throw new Parse.Error(\n        Parse.Error.COMMAND_UNAVAILABLE,\n        'the ' + key + ' constraint is not supported yet');\n\n    case '$within':\n      var box = constraint[key]['$box'];\n      if (!box || box.length != 2) {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          'malformatted $within arg');\n      }\n      answer[key] = {\n        '$box': [\n          [box[0].longitude, box[0].latitude],\n          [box[1].longitude, box[1].latitude]\n        ]\n      };\n      break;\n\n    case '$geoWithin': {\n      const polygon = constraint[key]['$polygon'];\n      const centerSphere = constraint[key]['$centerSphere'];\n      if (polygon !== undefined) {\n        let points;\n        if (typeof polygon === 'object' && polygon.__type === 'Polygon') {\n          if (!polygon.coordinates || polygon.coordinates.length < 3) {\n            throw new Parse.Error(\n              Parse.Error.INVALID_JSON,\n              'bad $geoWithin value; Polygon.coordinates should contain at least 3 lon/lat pairs'\n            );\n          }\n          points = polygon.coordinates;\n        } else if (polygon instanceof Array) {\n          if (polygon.length < 3) {\n            throw new Parse.Error(\n              Parse.Error.INVALID_JSON,\n              'bad $geoWithin value; $polygon should contain at least 3 GeoPoints'\n            );\n          }\n          points = polygon;\n        } else {\n          throw new Parse.Error(\n            Parse.Error.INVALID_JSON,\n            'bad $geoWithin value; $polygon should be Polygon object or Array of Parse.GeoPoint\\'s'\n          );\n        }\n        points = points.map((point) => {\n          if (point instanceof Array && point.length === 2) {\n            Parse.GeoPoint._validate(point[1], point[0]);\n            return point;\n          }\n          if (!GeoPointCoder.isValidJSON(point)) {\n            throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad $geoWithin value');\n          } else {\n            Parse.GeoPoint._validate(point.latitude, point.longitude);\n          }\n          return [point.longitude, point.latitude];\n        });\n        answer[key] = {\n          '$polygon': points\n        };\n      } else if (centerSphere !== undefined) {\n        if (!(centerSphere instanceof Array) || centerSphere.length < 2) {\n          throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad $geoWithin value; $centerSphere should be an array of Parse.GeoPoint and distance');\n        }\n        // Get point, convert to geo point if necessary and validate\n        let point = centerSphere[0];\n        if (point instanceof Array && point.length === 2) {\n          point = new Parse.GeoPoint(point[1], point[0]);\n        } else if (!GeoPointCoder.isValidJSON(point)) {\n          throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad $geoWithin value; $centerSphere geo point invalid');\n        }\n        Parse.GeoPoint._validate(point.latitude, point.longitude);\n        // Get distance and validate\n        const distance = centerSphere[1];\n        if(isNaN(distance) || distance < 0) {\n          throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad $geoWithin value; $centerSphere distance invalid');\n        }\n        answer[key] = {\n          '$centerSphere': [\n            [point.longitude, point.latitude],\n            distance\n          ]\n        };\n      }\n      break;\n    }\n    case '$geoIntersects': {\n      const point = constraint[key]['$point'];\n      if (!GeoPointCoder.isValidJSON(point)) {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          'bad $geoIntersect value; $point should be GeoPoint'\n        );\n      } else {\n        Parse.GeoPoint._validate(point.latitude, point.longitude);\n      }\n      answer[key] = {\n        $geometry: {\n          type: 'Point',\n          coordinates: [point.longitude, point.latitude]\n        }\n      };\n      break;\n    }\n    default:\n      if (key.match(/^\\$+/)) {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          'bad constraint: ' + key);\n      }\n      return CannotTransform;\n    }\n  }\n  return answer;\n}\n\n// Transforms an update operator from REST format to mongo format.\n// To be transformed, the input should have an __op field.\n// If flatten is true, this will flatten operators to their static\n// data format. For example, an increment of 2 would simply become a\n// 2.\n// The output for a non-flattened operator is a hash with __op being\n// the mongo op, and arg being the argument.\n// The output for a flattened operator is just a value.\n// Returns undefined if this should be a no-op.\n\nfunction transformUpdateOperator({\n  __op,\n  amount,\n  objects,\n}, flatten) {\n  switch(__op) {\n  case 'Delete':\n    if (flatten) {\n      return undefined;\n    } else {\n      return {__op: '$unset', arg: ''};\n    }\n\n  case 'Increment':\n    if (typeof amount !== 'number') {\n      throw new Parse.Error(Parse.Error.INVALID_JSON, 'incrementing must provide a number');\n    }\n    if (flatten) {\n      return amount;\n    } else {\n      return {__op: '$inc', arg: amount};\n    }\n\n  case 'Add':\n  case 'AddUnique':\n    if (!(objects instanceof Array)) {\n      throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to add must be an array');\n    }\n    var toAdd = objects.map(transformInteriorAtom);\n    if (flatten) {\n      return toAdd;\n    } else {\n      var mongoOp = {\n        Add: '$push',\n        AddUnique: '$addToSet'\n      }[__op];\n      return {__op: mongoOp, arg: {'$each': toAdd}};\n    }\n\n  case 'Remove':\n    if (!(objects instanceof Array)) {\n      throw new Parse.Error(Parse.Error.INVALID_JSON, 'objects to remove must be an array');\n    }\n    var toRemove = objects.map(transformInteriorAtom);\n    if (flatten) {\n      return [];\n    } else {\n      return {__op: '$pullAll', arg: toRemove};\n    }\n\n  default:\n    throw new Parse.Error(Parse.Error.COMMAND_UNAVAILABLE, `The ${__op} operator is not supported yet.`);\n  }\n}\nfunction mapValues(object, iterator) {\n  const result = {};\n  Object.keys(object).forEach((key) => {\n    result[key] = iterator(object[key]);\n  });\n  return result;\n}\n\nconst nestedMongoObjectToNestedParseObject = mongoObject => {\n  switch(typeof mongoObject) {\n  case 'string':\n  case 'number':\n  case 'boolean':\n    return mongoObject;\n  case 'undefined':\n  case 'symbol':\n  case 'function':\n    throw 'bad value in mongoObjectToParseObject';\n  case 'object':\n    if (mongoObject === null) {\n      return null;\n    }\n    if (mongoObject instanceof Array) {\n      return mongoObject.map(nestedMongoObjectToNestedParseObject);\n    }\n\n    if (mongoObject instanceof Date) {\n      return Parse._encode(mongoObject);\n    }\n\n    if (mongoObject instanceof mongodb.Long) {\n      return mongoObject.toNumber();\n    }\n\n    if (mongoObject instanceof mongodb.Double) {\n      return mongoObject.value;\n    }\n\n    if (BytesCoder.isValidDatabaseObject(mongoObject)) {\n      return BytesCoder.databaseToJSON(mongoObject);\n    }\n\n    if (mongoObject.hasOwnProperty('__type') && mongoObject.__type == 'Date' && mongoObject.iso instanceof Date) {\n      mongoObject.iso = mongoObject.iso.toJSON();\n      return mongoObject;\n    }\n\n    return mapValues(mongoObject, nestedMongoObjectToNestedParseObject);\n  default:\n    throw 'unknown js type';\n  }\n}\n\nconst transformPointerString = (schema, field, pointerString) => {\n  const objData = pointerString.split('$');\n  if (objData[0] !== schema.fields[field].targetClass) {\n    throw 'pointer to incorrect className';\n  }\n  return {\n    __type: 'Pointer',\n    className: objData[0],\n    objectId: objData[1]\n  };\n}\n\n// Converts from a mongo-format object to a REST-format object.\n// Does not strip out anything based on a lack of authentication.\nconst mongoObjectToParseObject = (className, mongoObject, schema) => {\n  switch(typeof mongoObject) {\n  case 'string':\n  case 'number':\n  case 'boolean':\n    return mongoObject;\n  case 'undefined':\n  case 'symbol':\n  case 'function':\n    throw 'bad value in mongoObjectToParseObject';\n  case 'object': {\n    if (mongoObject === null) {\n      return null;\n    }\n    if (mongoObject instanceof Array) {\n      return mongoObject.map(nestedMongoObjectToNestedParseObject);\n    }\n\n    if (mongoObject instanceof Date) {\n      return Parse._encode(mongoObject);\n    }\n\n    if (mongoObject instanceof mongodb.Long) {\n      return mongoObject.toNumber();\n    }\n\n    if (mongoObject instanceof mongodb.Double) {\n      return mongoObject.value;\n    }\n\n    if (BytesCoder.isValidDatabaseObject(mongoObject)) {\n      return BytesCoder.databaseToJSON(mongoObject);\n    }\n\n    const restObject = {};\n    if (mongoObject._rperm || mongoObject._wperm) {\n      restObject._rperm = mongoObject._rperm || [];\n      restObject._wperm = mongoObject._wperm || [];\n      delete mongoObject._rperm;\n      delete mongoObject._wperm;\n    }\n\n    for (var key in mongoObject) {\n      switch(key) {\n      case '_id':\n        restObject['objectId'] = '' + mongoObject[key];\n        break;\n      case '_hashed_password':\n        restObject._hashed_password = mongoObject[key];\n        break;\n      case '_acl':\n        break;\n      case '_email_verify_token':\n      case '_perishable_token':\n      case '_perishable_token_expires_at':\n      case '_password_changed_at':\n      case '_tombstone':\n      case '_email_verify_token_expires_at':\n      case '_account_lockout_expires_at':\n      case '_failed_login_count':\n      case '_password_history':\n        // Those keys will be deleted if needed in the DB Controller\n        restObject[key] = mongoObject[key];\n        break;\n      case '_session_token':\n        restObject['sessionToken'] = mongoObject[key];\n        break;\n      case 'updatedAt':\n      case '_updated_at':\n        restObject['updatedAt'] = Parse._encode(new Date(mongoObject[key])).iso;\n        break;\n      case 'createdAt':\n      case '_created_at':\n        restObject['createdAt'] = Parse._encode(new Date(mongoObject[key])).iso;\n        break;\n      case 'expiresAt':\n      case '_expiresAt':\n        restObject['expiresAt'] = Parse._encode(new Date(mongoObject[key]));\n        break;\n      case 'lastUsed':\n      case '_last_used':\n        restObject['lastUsed'] = Parse._encode(new Date(mongoObject[key])).iso;\n        break;\n      case 'timesUsed':\n      case 'times_used':\n        restObject['timesUsed'] = mongoObject[key];\n        break;\n      default:\n        // Check other auth data keys\n        var authDataMatch = key.match(/^_auth_data_([a-zA-Z0-9_]+)$/);\n        if (authDataMatch) {\n          var provider = authDataMatch[1];\n          restObject['authData'] = restObject['authData'] || {};\n          restObject['authData'][provider] = mongoObject[key];\n          break;\n        }\n\n        if (key.indexOf('_p_') == 0) {\n          var newKey = key.substring(3);\n          if (!schema.fields[newKey]) {\n            log.info('transform.js', 'Found a pointer column not in the schema, dropping it.', className, newKey);\n            break;\n          }\n          if (schema.fields[newKey].type !== 'Pointer') {\n            log.info('transform.js', 'Found a pointer in a non-pointer column, dropping it.', className, key);\n            break;\n          }\n          if (mongoObject[key] === null) {\n            break;\n          }\n          restObject[newKey] = transformPointerString(schema, newKey, mongoObject[key]);\n          break;\n        } else if (key[0] == '_' && key != '__type') {\n          throw ('bad key in untransform: ' + key);\n        } else {\n          var value = mongoObject[key];\n          if (schema.fields[key] && schema.fields[key].type === 'File' && FileCoder.isValidDatabaseObject(value)) {\n            restObject[key] = FileCoder.databaseToJSON(value);\n            break;\n          }\n          if (schema.fields[key] && schema.fields[key].type === 'GeoPoint' && GeoPointCoder.isValidDatabaseObject(value)) {\n            restObject[key] = GeoPointCoder.databaseToJSON(value);\n            break;\n          }\n          if (schema.fields[key] && schema.fields[key].type === 'Polygon' && PolygonCoder.isValidDatabaseObject(value)) {\n            restObject[key] = PolygonCoder.databaseToJSON(value);\n            break;\n          }\n          if (schema.fields[key] && schema.fields[key].type === 'Bytes' && BytesCoder.isValidDatabaseObject(value)) {\n            restObject[key] = BytesCoder.databaseToJSON(value);\n            break;\n          }\n        }\n        restObject[key] = nestedMongoObjectToNestedParseObject(mongoObject[key]);\n      }\n    }\n\n    const relationFieldNames = Object.keys(schema.fields).filter(fieldName => schema.fields[fieldName].type === 'Relation');\n    const relationFields = {};\n    relationFieldNames.forEach(relationFieldName => {\n      relationFields[relationFieldName] = {\n        __type: 'Relation',\n        className: schema.fields[relationFieldName].targetClass,\n      }\n    });\n\n    return { ...restObject, ...relationFields };\n  }\n  default:\n    throw 'unknown js type';\n  }\n}\n\nvar DateCoder = {\n  JSONToDatabase(json) {\n    return new Date(json.iso);\n  },\n\n  isValidJSON(value) {\n    return (typeof value === 'object' &&\n      value !== null &&\n      value.__type === 'Date'\n    );\n  }\n};\n\nvar BytesCoder = {\n  base64Pattern: new RegExp(\"^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$\"),\n  isBase64Value(object) {\n    if (typeof object !== 'string') {\n      return false;\n    }\n    return this.base64Pattern.test(object);\n  },\n\n  databaseToJSON(object) {\n    let value;\n    if (this.isBase64Value(object)) {\n      value = object;\n    } else {\n      value = object.buffer.toString('base64');\n    }\n    return {\n      __type: 'Bytes',\n      base64: value\n    };\n  },\n\n  isValidDatabaseObject(object) {\n    return (object instanceof mongodb.Binary) || this.isBase64Value(object);\n  },\n\n  JSONToDatabase(json) {\n    return new mongodb.Binary(new Buffer(json.base64, 'base64'));\n  },\n\n  isValidJSON(value) {\n    return (typeof value === 'object' &&\n      value !== null &&\n      value.__type === 'Bytes'\n    );\n  }\n};\n\nvar GeoPointCoder = {\n  databaseToJSON(object) {\n    return {\n      __type: 'GeoPoint',\n      latitude: object[1],\n      longitude: object[0]\n    }\n  },\n\n  isValidDatabaseObject(object) {\n    return (object instanceof Array &&\n      object.length == 2\n    );\n  },\n\n  JSONToDatabase(json) {\n    return [ json.longitude, json.latitude ];\n  },\n\n  isValidJSON(value) {\n    return (typeof value === 'object' &&\n      value !== null &&\n      value.__type === 'GeoPoint'\n    );\n  }\n};\n\nvar PolygonCoder = {\n  databaseToJSON(object) {\n    // Convert lng/lat -> lat/lng\n    const coords = object.coordinates[0].map((coord) => {\n      return [coord[1], coord[0]];\n    });\n    return {\n      __type: 'Polygon',\n      coordinates: coords\n    }\n  },\n\n  isValidDatabaseObject(object) {\n    const coords = object.coordinates[0];\n    if (object.type !== 'Polygon' || !(coords instanceof Array)) {\n      return false;\n    }\n    for (let i = 0; i < coords.length; i++) {\n      const point = coords[i];\n      if (!GeoPointCoder.isValidDatabaseObject(point)) {\n        return false;\n      }\n      Parse.GeoPoint._validate(parseFloat(point[1]), parseFloat(point[0]));\n    }\n    return true;\n  },\n\n  JSONToDatabase(json) {\n    let coords = json.coordinates;\n    // Add first point to the end to close polygon\n    if (coords[0][0] !== coords[coords.length - 1][0] ||\n        coords[0][1] !== coords[coords.length - 1][1]) {\n      coords.push(coords[0]);\n    }\n    const unique = coords.filter((item, index, ar) => {\n      let foundIndex = -1;\n      for (let i = 0; i < ar.length; i += 1) {\n        const pt = ar[i];\n        if (pt[0] === item[0] &&\n            pt[1] === item[1]) {\n          foundIndex = i;\n          break;\n        }\n      }\n      return foundIndex === index;\n    });\n    if (unique.length < 3) {\n      throw new Parse.Error(\n        Parse.Error.INTERNAL_SERVER_ERROR,\n        'GeoJSON: Loop must have at least 3 different vertices'\n      );\n    }\n    // Convert lat/long -> long/lat\n    coords = coords.map((coord) => {\n      return [coord[1], coord[0]];\n    });\n    return { type: 'Polygon', coordinates: [coords] };\n  },\n\n  isValidJSON(value) {\n    return (typeof value === 'object' &&\n      value !== null &&\n      value.__type === 'Polygon'\n    );\n  }\n};\n\nvar FileCoder = {\n  databaseToJSON(object) {\n    return {\n      __type: 'File',\n      name: object\n    }\n  },\n\n  isValidDatabaseObject(object) {\n    return (typeof object === 'string');\n  },\n\n  JSONToDatabase(json) {\n    return json.name;\n  },\n\n  isValidJSON(value) {\n    return (typeof value === 'object' &&\n      value !== null &&\n      value.__type === 'File'\n    );\n  }\n};\n\nmodule.exports = {\n  transformKey,\n  parseObjectToMongoObjectForCreate,\n  transformUpdate,\n  transformWhere,\n  mongoObjectToParseObject,\n  relativeTimeToDate,\n  transformConstraint,\n  transformPointerString,\n};\n"]}