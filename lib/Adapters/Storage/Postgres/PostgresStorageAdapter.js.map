{"version":3,"sources":["../../../../src/Adapters/Storage/Postgres/PostgresStorageAdapter.js"],"names":["PostgresRelationDoesNotExistError","PostgresDuplicateRelationError","PostgresDuplicateColumnError","PostgresMissingColumnError","PostgresDuplicateObjectError","PostgresUniqueIndexViolationError","PostgresTransactionAbortedError","logger","require","debug","args","arguments","concat","slice","length","log","getLogger","apply","parseTypeToPostgresType","type","contents","JSON","stringify","ParseToPosgresComparator","mongoAggregateToPostgres","$dayOfMonth","$dayOfWeek","$dayOfYear","$isoDayOfWeek","$isoWeekYear","$hour","$minute","$second","$millisecond","$month","$week","$year","toPostgresValue","value","__type","iso","name","transformValue","objectId","emptyCLPS","Object","freeze","find","get","create","update","delete","addField","defaultCLPS","toParseSchema","schema","className","fields","_hashed_password","_wperm","_rperm","clps","classLevelPermissions","indexes","toPostgresSchema","_password_history","handleDotFields","object","keys","forEach","fieldName","indexOf","components","split","first","shift","currentObj","next","__op","undefined","transformDotFieldToComponents","map","cmpt","index","transformDotField","join","transformAggregateField","substr","validateKeys","key","includes","Parse","Error","INVALID_NESTED_KEY","joinTablesForSchema","list","field","push","buildWhereClause","query","patterns","values","sorts","isArrayField","initialPatternsLength","fieldValue","$exists","$in","inPatterns","listElem","$regex","MAX_INT_PLUS_ONE","clauses","clauseValues","subQuery","clause","pattern","orOrAnd","not","$ne","$eq","isInOrNin","Array","isArray","$nin","allowNull","listIndex","createConstraint","baseArray","notIn","_","flatMap","elt","INVALID_JSON","$all","isAnyValueRegexStartsWith","isAllValuesRegexOrNone","i","processRegexPattern","substring","$containedBy","arr","$text","search","$search","language","$term","$language","$caseSensitive","$diacriticSensitive","$nearSphere","point","distance","$maxDistance","distanceInKM","longitude","latitude","$within","$box","box","left","bottom","right","top","$geoWithin","$centerSphere","centerSphere","GeoPoint","GeoPointCoder","isValidJSON","_validate","isNaN","$polygon","polygon","points","coordinates","$geoIntersects","$point","regex","operator","opts","$options","removeWhiteSpace","convertPolygonToSQL","cmp","pgComparator","OPERATION_FORBIDDEN","PostgresStorageAdapter","constructor","uri","collectionPrefix","databaseOptions","_collectionPrefix","client","pgp","_client","_pgp","canSortOnJoinTables","handleShutdown","$pool","end","_ensureSchemaCollectionExists","conn","none","catch","error","code","classExists","one","a","exists","setClassLevelPermissions","CLPs","self","task","t","setIndexesWithSchemaFormat","submittedIndexes","existingIndexes","Promise","resolve","_id_","_id","deletedIndexes","insertedIndexes","INVALID_QUERY","hasOwnProperty","tx","createIndexes","dropIndexes","createClass","q1","createTable","q2","q3","batch","then","err","data","result","detail","DUPLICATE_VALUE","valuesArray","patternsArray","assign","_email_verify_token_expires_at","_email_verify_token","_account_lockout_expires_at","_failed_login_count","_perishable_token","_perishable_token_expires_at","_password_changed_at","relations","parseType","qs","joinTable","schemaUpgrade","columns","column_name","newColumns","filter","item","addFieldIfNotExists","postgresType","any","path","deleteClass","operations","helpers","deleteAllClasses","now","Date","getTime","results","joins","reduce","classes","queries","dropDatabase","deleteFields","fieldNames","idx","getAllClasses","row","getClass","createObject","columnsArray","geoPoints","authDataMatch","match","provider","pop","initialValues","val","termination","geoPointsInjects","l","columnsPattern","col","valuesPattern","ops","underlyingError","constraint","matches","userInfo","duplicated_field","deleteObjectsByQuery","where","count","OBJECT_NOT_FOUND","findOneAndUpdate","updateObjectsByQuery","updatePatterns","originalUpdate","generate","jsonb","lastKey","fieldNameIndex","str","amount","objects","keysToIncrement","k","incrementPatterns","c","keysToDelete","deletePatterns","p","expectedType","reject","whereClause","upsertOneObject","createValue","skip","limit","sort","hasLimit","hasSkip","wherePattern","limitPattern","skipPattern","sortPattern","sortCopy","sorting","transformKey","postgresObjectToParseObject","targetClass","y","x","coords","parseFloat","createdAt","toISOString","updatedAt","expiresAt","ensureUniqueness","constraintName","constraintPatterns","message","distinct","column","isNested","isPointerField","transformer","child","aggregate","pipeline","countField","groupValues","groupPattern","stage","$group","groupByFields","alias","operation","source","$sum","$max","$min","$avg","$project","$match","$or","collapse","element","matchPatterns","$limit","$skip","$sort","order","parseInt","performInitialization","VolatileClassesSchemas","promises","INVALID_CLASS_NAME","all","sql","misc","jsonObjectSetKeys","array","add","addUnique","remove","containsAll","containsAllRegex","contains","duration","console","createIndexesIfNeeded","getIndexes","updateSchemaWithIndexes","unique","ar","foundIndex","pt","INTERNAL_SERVER_ERROR","endsWith","replace","trim","s","startsWith","literalizeRegexPart","isStartsWithRegex","firstValuesIsRegex","some","createLiteralRegex","remaining","matcher1","result1","prefix","matcher2","result2"],"mappings":"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","file":"PostgresStorageAdapter.js","sourcesContent":["// @flow\nimport { createClient } from './PostgresClient';\n// @flow-disable-next\nimport Parse            from 'parse/node';\n// @flow-disable-next\nimport _                from 'lodash';\nimport sql              from './sql';\n\nconst PostgresRelationDoesNotExistError = '42P01';\nconst PostgresDuplicateRelationError = '42P07';\nconst PostgresDuplicateColumnError = '42701';\nconst PostgresMissingColumnError = '42703';\nconst PostgresDuplicateObjectError = '42710';\nconst PostgresUniqueIndexViolationError = '23505';\nconst PostgresTransactionAbortedError = '25P02';\nconst logger = require('../../../logger');\n\nconst debug = function(...args: any) {\n  args = ['PG: ' + arguments[0]].concat(args.slice(1, args.length));\n  const log = logger.getLogger();\n  log.debug.apply(log, args);\n}\n\nimport { StorageAdapter }    from '../StorageAdapter';\nimport type { SchemaType,\n  QueryType,\n  QueryOptions } from '../StorageAdapter';\n\nconst parseTypeToPostgresType = type => {\n  switch (type.type) {\n  case 'String': return 'text';\n  case 'Date': return 'timestamp with time zone';\n  case 'Object': return 'jsonb';\n  case 'File': return 'text';\n  case 'Boolean': return 'boolean';\n  case 'Pointer': return 'char(10)';\n  case 'Number': return 'double precision';\n  case 'GeoPoint': return 'point';\n  case 'Bytes': return 'jsonb';\n  case 'Polygon': return 'polygon';\n  case 'Array':\n    if (type.contents && type.contents.type === 'String') {\n      return 'text[]';\n    } else {\n      return 'jsonb';\n    }\n  default: throw `no type for ${JSON.stringify(type)} yet`;\n  }\n};\n\nconst ParseToPosgresComparator = {\n  '$gt': '>',\n  '$lt': '<',\n  '$gte': '>=',\n  '$lte': '<='\n}\n\nconst mongoAggregateToPostgres = {\n  $dayOfMonth: 'DAY',\n  $dayOfWeek: 'DOW',\n  $dayOfYear: 'DOY',\n  $isoDayOfWeek: 'ISODOW',\n  $isoWeekYear:'ISOYEAR',\n  $hour: 'HOUR',\n  $minute: 'MINUTE',\n  $second: 'SECOND',\n  $millisecond: 'MILLISECONDS',\n  $month: 'MONTH',\n  $week: 'WEEK',\n  $year: 'YEAR',\n};\n\nconst toPostgresValue = value => {\n  if (typeof value === 'object') {\n    if (value.__type === 'Date') {\n      return value.iso;\n    }\n    if (value.__type === 'File') {\n      return value.name;\n    }\n  }\n  return value;\n}\n\nconst transformValue = value => {\n  if (typeof value === 'object' &&\n        value.__type === 'Pointer') {\n    return value.objectId;\n  }\n  return value;\n}\n\n// Duplicate from then mongo adapter...\nconst emptyCLPS = Object.freeze({\n  find: {},\n  get: {},\n  create: {},\n  update: {},\n  delete: {},\n  addField: {},\n});\n\nconst defaultCLPS = Object.freeze({\n  find: {'*': true},\n  get: {'*': true},\n  create: {'*': true},\n  update: {'*': true},\n  delete: {'*': true},\n  addField: {'*': true},\n});\n\nconst toParseSchema = (schema) => {\n  if (schema.className === '_User') {\n    delete schema.fields._hashed_password;\n  }\n  if (schema.fields) {\n    delete schema.fields._wperm;\n    delete schema.fields._rperm;\n  }\n  let clps = defaultCLPS;\n  if (schema.classLevelPermissions) {\n    clps = {...emptyCLPS, ...schema.classLevelPermissions};\n  }\n  let indexes = {};\n  if (schema.indexes) {\n    indexes = {...schema.indexes};\n  }\n  return {\n    className: schema.className,\n    fields: schema.fields,\n    classLevelPermissions: clps,\n    indexes,\n  };\n}\n\nconst toPostgresSchema = (schema) => {\n  if (!schema) {\n    return schema;\n  }\n  schema.fields = schema.fields || {};\n  schema.fields._wperm = {type: 'Array', contents: {type: 'String'}}\n  schema.fields._rperm = {type: 'Array', contents: {type: 'String'}}\n  if (schema.className === '_User') {\n    schema.fields._hashed_password = {type: 'String'};\n    schema.fields._password_history = {type: 'Array'};\n  }\n  return schema;\n}\n\nconst handleDotFields = (object) => {\n  Object.keys(object).forEach(fieldName => {\n    if (fieldName.indexOf('.') > -1) {\n      const components = fieldName.split('.');\n      const first = components.shift();\n      object[first] = object[first] || {};\n      let currentObj = object[first];\n      let next;\n      let value = object[fieldName];\n      if (value && value.__op === 'Delete') {\n        value = undefined;\n      }\n      /* eslint-disable no-cond-assign */\n      while(next = components.shift()) {\n      /* eslint-enable no-cond-assign */\n        currentObj[next] = currentObj[next] || {};\n        if (components.length === 0) {\n          currentObj[next] = value;\n        }\n        currentObj = currentObj[next];\n      }\n      delete object[fieldName];\n    }\n  });\n  return object;\n}\n\nconst transformDotFieldToComponents = (fieldName) => {\n  return fieldName.split('.').map((cmpt, index) => {\n    if (index === 0) {\n      return `\"${cmpt}\"`;\n    }\n    return `'${cmpt}'`;\n  });\n}\n\nconst transformDotField = (fieldName) => {\n  if (fieldName.indexOf('.') === -1) {\n    return `\"${fieldName}\"`;\n  }\n  const components = transformDotFieldToComponents(fieldName);\n  let name = components.slice(0, components.length - 1).join('->');\n  name += '->>' + components[components.length - 1];\n  return name;\n}\n\nconst transformAggregateField = (fieldName) => {\n  if (typeof fieldName !== 'string') {\n    return fieldName;\n  }\n  if (fieldName === '$_created_at') {\n    return 'createdAt';\n  }\n  if (fieldName === '$_updated_at') {\n    return 'updatedAt';\n  }\n  return fieldName.substr(1);\n}\n\nconst validateKeys = (object) => {\n  if (typeof object == 'object') {\n    for (const key in object) {\n      if (typeof object[key] == 'object') {\n        validateKeys(object[key]);\n      }\n\n      if(key.includes('$') || key.includes('.')){\n        throw new Parse.Error(Parse.Error.INVALID_NESTED_KEY, \"Nested keys should not contain the '$' or '.' characters\");\n      }\n    }\n  }\n}\n\n// Returns the list of join tables on a schema\nconst joinTablesForSchema = (schema) => {\n  const list = [];\n  if (schema) {\n    Object.keys(schema.fields).forEach((field) => {\n      if (schema.fields[field].type === 'Relation') {\n        list.push(`_Join:${field}:${schema.className}`);\n      }\n    });\n  }\n  return list;\n}\n\ninterface WhereClause {\n  pattern: string;\n  values: Array<any>;\n  sorts: Array<any>;\n}\n\nconst buildWhereClause = ({ schema, query, index }): WhereClause => {\n  const patterns = [];\n  let values = [];\n  const sorts = [];\n\n  schema = toPostgresSchema(schema);\n  for (const fieldName in query) {\n    const isArrayField = schema.fields\n          && schema.fields[fieldName]\n          && schema.fields[fieldName].type === 'Array';\n    const initialPatternsLength = patterns.length;\n    const fieldValue = query[fieldName];\n\n    // nothingin the schema, it's gonna blow up\n    if (!schema.fields[fieldName]) {\n      // as it won't exist\n      if (fieldValue && fieldValue.$exists === false) {\n        continue;\n      }\n    }\n\n    if (fieldName.indexOf('.') >= 0) {\n      let name = transformDotField(fieldName);\n      if (fieldValue === null) {\n        patterns.push(`${name} IS NULL`);\n      } else {\n        if (fieldValue.$in) {\n          const inPatterns = [];\n          name = transformDotFieldToComponents(fieldName).join('->');\n          fieldValue.$in.forEach((listElem) => {\n            if (typeof listElem === 'string') {\n              inPatterns.push(`\"${listElem}\"`);\n            } else {\n              inPatterns.push(`${listElem}`);\n            }\n          });\n          patterns.push(`(${name})::jsonb @> '[${inPatterns.join()}]'::jsonb`);\n        } else if (fieldValue.$regex) {\n          // Handle later\n        } else {\n          patterns.push(`${name} = '${fieldValue}'`);\n        }\n      }\n    } else if (fieldValue === null || fieldValue === undefined) {\n      patterns.push(`$${index}:name IS NULL`);\n      values.push(fieldName);\n      index += 1;\n      continue;\n    } else if (typeof fieldValue === 'string') {\n      patterns.push(`$${index}:name = $${index + 1}`);\n      values.push(fieldName, fieldValue);\n      index += 2;\n    } else if (typeof fieldValue === 'boolean') {\n      patterns.push(`$${index}:name = $${index + 1}`);\n      // Can't cast boolean to double precision\n      if (schema.fields[fieldName] && schema.fields[fieldName].type === 'Number') {\n        // Should always return zero results\n        const MAX_INT_PLUS_ONE = 9223372036854775808;\n        values.push(fieldName, MAX_INT_PLUS_ONE);\n      } else {\n        values.push(fieldName, fieldValue);\n      }\n      index += 2;\n    } else if (typeof fieldValue === 'number') {\n      patterns.push(`$${index}:name = $${index + 1}`);\n      values.push(fieldName, fieldValue);\n      index += 2;\n    } else if (['$or', '$nor', '$and'].includes(fieldName)) {\n      const clauses = [];\n      const clauseValues = [];\n      fieldValue.forEach((subQuery) =>  {\n        const clause = buildWhereClause({ schema, query: subQuery, index });\n        if (clause.pattern.length > 0) {\n          clauses.push(clause.pattern);\n          clauseValues.push(...clause.values);\n          index += clause.values.length;\n        }\n      });\n\n      const orOrAnd = fieldName === '$and' ? ' AND ' : ' OR ';\n      const not = fieldName === '$nor' ? ' NOT ' : '';\n\n      patterns.push(`${not}(${clauses.join(orOrAnd)})`);\n      values.push(...clauseValues);\n    }\n\n    if (fieldValue.$ne !== undefined) {\n      if (isArrayField) {\n        fieldValue.$ne = JSON.stringify([fieldValue.$ne]);\n        patterns.push(`NOT array_contains($${index}:name, $${index + 1})`);\n      } else {\n        if (fieldValue.$ne === null) {\n          patterns.push(`$${index}:name IS NOT NULL`);\n          values.push(fieldName);\n          index += 1;\n          continue;\n        } else {\n          // if not null, we need to manually exclude null\n          patterns.push(`($${index}:name <> $${index + 1} OR $${index}:name IS NULL)`);\n        }\n      }\n\n      // TODO: support arrays\n      values.push(fieldName, fieldValue.$ne);\n      index += 2;\n    }\n    if (fieldValue.$eq !== undefined) {\n      if (fieldValue.$eq === null) {\n        patterns.push(`$${index}:name IS NULL`);\n        values.push(fieldName);\n        index += 1;\n      } else {\n        patterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, fieldValue.$eq);\n        index += 2;\n      }\n    }\n    const isInOrNin = Array.isArray(fieldValue.$in) || Array.isArray(fieldValue.$nin);\n    if (Array.isArray(fieldValue.$in) &&\n        isArrayField &&\n        schema.fields[fieldName].contents &&\n        schema.fields[fieldName].contents.type === 'String') {\n      const inPatterns = [];\n      let allowNull = false;\n      values.push(fieldName);\n      fieldValue.$in.forEach((listElem, listIndex) => {\n        if (listElem === null) {\n          allowNull = true;\n        } else {\n          values.push(listElem);\n          inPatterns.push(`$${index + 1 + listIndex - (allowNull ? 1 : 0)}`);\n        }\n      });\n      if (allowNull) {\n        patterns.push(`($${index}:name IS NULL OR $${index}:name && ARRAY[${inPatterns.join()}])`);\n      } else {\n        patterns.push(`$${index}:name && ARRAY[${inPatterns.join()}]`);\n      }\n      index = index + 1 + inPatterns.length;\n    } else if (isInOrNin) {\n      var createConstraint = (baseArray, notIn) => {\n        if (baseArray.length > 0) {\n          const not = notIn ? ' NOT ' : '';\n          if (isArrayField) {\n            patterns.push(`${not} array_contains($${index}:name, $${index + 1})`);\n            values.push(fieldName, JSON.stringify(baseArray));\n            index += 2;\n          } else {\n            // Handle Nested Dot Notation Above\n            if (fieldName.indexOf('.') >= 0) {\n              return;\n            }\n            const inPatterns = [];\n            values.push(fieldName);\n            baseArray.forEach((listElem, listIndex) => {\n              if (listElem !== null) {\n                values.push(listElem);\n                inPatterns.push(`$${index + 1 + listIndex}`);\n              }\n            });\n            patterns.push(`$${index}:name ${not} IN (${inPatterns.join()})`);\n            index = index + 1 + inPatterns.length;\n          }\n        } else if (!notIn) {\n          values.push(fieldName);\n          patterns.push(`$${index}:name IS NULL`);\n          index = index + 1;\n        }\n      }\n      if (fieldValue.$in) {\n        createConstraint(_.flatMap(fieldValue.$in, elt => elt), false);\n      }\n      if (fieldValue.$nin) {\n        createConstraint(_.flatMap(fieldValue.$nin, elt => elt), true);\n      }\n    } else if(typeof fieldValue.$in !== 'undefined') {\n      throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad $in value');\n    } else if (typeof fieldValue.$nin !== 'undefined') {\n      throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad $nin value');\n    }\n\n    if (Array.isArray(fieldValue.$all) && isArrayField) {\n      if (isAnyValueRegexStartsWith(fieldValue.$all)) {\n        if (!isAllValuesRegexOrNone(fieldValue.$all)) {\n          throw new Parse.Error(Parse.Error.INVALID_JSON, 'All $all values must be of regex type or none: '\n            + fieldValue.$all);\n        }\n\n        for (let i = 0; i < fieldValue.$all.length; i += 1) {\n          const value = processRegexPattern(fieldValue.$all[i].$regex);\n          fieldValue.$all[i] = value.substring(1) + '%';\n        }\n        patterns.push(`array_contains_all_regex($${index}:name, $${index + 1}::jsonb)`);\n      } else {\n        patterns.push(`array_contains_all($${index}:name, $${index + 1}::jsonb)`);\n      }\n      values.push(fieldName, JSON.stringify(fieldValue.$all));\n      index += 2;\n    }\n\n    if (typeof fieldValue.$exists !== 'undefined') {\n      if (fieldValue.$exists) {\n        patterns.push(`$${index}:name IS NOT NULL`);\n      } else {\n        patterns.push(`$${index}:name IS NULL`);\n      }\n      values.push(fieldName);\n      index += 1;\n    }\n\n    if (fieldValue.$containedBy) {\n      const arr = fieldValue.$containedBy;\n      if (!(arr instanceof Array)) {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $containedBy: should be an array`\n        );\n      }\n\n      patterns.push(`$${index}:name <@ $${index + 1}::jsonb`);\n      values.push(fieldName, JSON.stringify(arr));\n      index += 2;\n    }\n\n    if (fieldValue.$text) {\n      const search = fieldValue.$text.$search;\n      let language = 'english';\n      if (typeof search !== 'object') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $text: $search, should be object`\n        );\n      }\n      if (!search.$term || typeof search.$term !== 'string') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $text: $term, should be string`\n        );\n      }\n      if (search.$language && typeof search.$language !== 'string') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $text: $language, should be string`\n        );\n      } else if (search.$language) {\n        language = search.$language;\n      }\n      if (search.$caseSensitive && typeof search.$caseSensitive !== 'boolean') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $text: $caseSensitive, should be boolean`\n        );\n      } else if (search.$caseSensitive) {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $text: $caseSensitive not supported, please use $regex or create a separate lower case column.`\n        );\n      }\n      if (search.$diacriticSensitive && typeof search.$diacriticSensitive !== 'boolean') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $text: $diacriticSensitive, should be boolean`\n        );\n      } else if (search.$diacriticSensitive === false) {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          `bad $text: $diacriticSensitive - false not supported, install Postgres Unaccent Extension`\n        );\n      }\n      patterns.push(`to_tsvector($${index}, $${index + 1}:name) @@ to_tsquery($${index + 2}, $${index + 3})`);\n      values.push(language, fieldName, language, search.$term);\n      index += 4;\n    }\n\n    if (fieldValue.$nearSphere) {\n      const point = fieldValue.$nearSphere;\n      const distance = fieldValue.$maxDistance;\n      const distanceInKM = distance * 6371 * 1000;\n      patterns.push(`ST_distance_sphere($${index}:name::geometry, POINT($${index + 1}, $${index + 2})::geometry) <= $${index + 3}`);\n      sorts.push(`ST_distance_sphere($${index}:name::geometry, POINT($${index + 1}, $${index + 2})::geometry) ASC`)\n      values.push(fieldName, point.longitude, point.latitude, distanceInKM);\n      index += 4;\n    }\n\n    if (fieldValue.$within && fieldValue.$within.$box) {\n      const box = fieldValue.$within.$box;\n      const left = box[0].longitude;\n      const bottom = box[0].latitude;\n      const right = box[1].longitude;\n      const top = box[1].latitude;\n\n      patterns.push(`$${index}:name::point <@ $${index + 1}::box`);\n      values.push(fieldName, `((${left}, ${bottom}), (${right}, ${top}))`);\n      index += 2;\n    }\n\n    if (fieldValue.$geoWithin && fieldValue.$geoWithin.$centerSphere) {\n      const centerSphere = fieldValue.$geoWithin.$centerSphere;\n      if (!(centerSphere instanceof Array) || centerSphere.length < 2) {\n        throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad $geoWithin value; $centerSphere should be an array of Parse.GeoPoint and distance');\n      }\n      // Get point, convert to geo point if necessary and validate\n      let point = centerSphere[0];\n      if (point instanceof Array && point.length === 2) {\n        point = new Parse.GeoPoint(point[1], point[0]);\n      } else if (!GeoPointCoder.isValidJSON(point)) {\n        throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad $geoWithin value; $centerSphere geo point invalid');\n      }\n      Parse.GeoPoint._validate(point.latitude, point.longitude);\n      // Get distance and validate\n      const distance = centerSphere[1];\n      if(isNaN(distance) || distance < 0) {\n        throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad $geoWithin value; $centerSphere distance invalid');\n      }\n      const distanceInKM = distance * 6371 * 1000;\n      patterns.push(`ST_distance_sphere($${index}:name::geometry, POINT($${index + 1}, $${index + 2})::geometry) <= $${index + 3}`);\n      values.push(fieldName, point.longitude, point.latitude, distanceInKM);\n      index += 4;\n    }\n\n    if (fieldValue.$geoWithin && fieldValue.$geoWithin.$polygon) {\n      const polygon = fieldValue.$geoWithin.$polygon;\n      let points;\n      if (typeof polygon === 'object' && polygon.__type === 'Polygon') {\n        if (!polygon.coordinates || polygon.coordinates.length < 3) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_JSON,\n            'bad $geoWithin value; Polygon.coordinates should contain at least 3 lon/lat pairs'\n          );\n        }\n        points = polygon.coordinates;\n      } else if ((polygon instanceof Array)) {\n        if (polygon.length < 3) {\n          throw new Parse.Error(\n            Parse.Error.INVALID_JSON,\n            'bad $geoWithin value; $polygon should contain at least 3 GeoPoints'\n          );\n        }\n        points = polygon;\n      } else {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          'bad $geoWithin value; $polygon should be Polygon object or Array of Parse.GeoPoint\\'s'\n        );\n      }\n      points = points.map((point) => {\n        if (point instanceof Array && point.length === 2) {\n          Parse.GeoPoint._validate(point[1], point[0]);\n          return `(${point[0]}, ${point[1]})`;\n        }\n        if (typeof point !== 'object' || point.__type !== 'GeoPoint') {\n          throw new Parse.Error(Parse.Error.INVALID_JSON, 'bad $geoWithin value');\n        } else {\n          Parse.GeoPoint._validate(point.latitude, point.longitude);\n        }\n        return `(${point.longitude}, ${point.latitude})`;\n      }).join(', ');\n\n      patterns.push(`$${index}:name::point <@ $${index + 1}::polygon`);\n      values.push(fieldName, `(${points})`);\n      index += 2;\n    }\n    if (fieldValue.$geoIntersects && fieldValue.$geoIntersects.$point) {\n      const point = fieldValue.$geoIntersects.$point;\n      if (typeof point !== 'object' || point.__type !== 'GeoPoint') {\n        throw new Parse.Error(\n          Parse.Error.INVALID_JSON,\n          'bad $geoIntersect value; $point should be GeoPoint'\n        );\n      } else {\n        Parse.GeoPoint._validate(point.latitude, point.longitude);\n      }\n      patterns.push(`$${index}:name::polygon @> $${index + 1}::point`);\n      values.push(fieldName, `(${point.longitude}, ${point.latitude})`);\n      index += 2;\n    }\n\n    if (fieldValue.$regex) {\n      let regex = fieldValue.$regex;\n      let operator = '~';\n      const opts = fieldValue.$options;\n      if (opts) {\n        if (opts.indexOf('i') >= 0) {\n          operator = '~*';\n        }\n        if (opts.indexOf('x') >= 0) {\n          regex = removeWhiteSpace(regex);\n        }\n      }\n\n      const name = transformDotField(fieldName);\n      regex = processRegexPattern(regex);\n\n      patterns.push(`$${index}:raw ${operator} '$${index + 1}:raw'`);\n      values.push(name, regex);\n      index += 2;\n    }\n\n    if (fieldValue.__type === 'Pointer') {\n      if (isArrayField) {\n        patterns.push(`array_contains($${index}:name, $${index + 1})`);\n        values.push(fieldName, JSON.stringify([fieldValue]));\n        index += 2;\n      } else {\n        patterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, fieldValue.objectId);\n        index += 2;\n      }\n    }\n\n    if (fieldValue.__type === 'Date') {\n      patterns.push(`$${index}:name = $${index + 1}`);\n      values.push(fieldName, fieldValue.iso);\n      index += 2;\n    }\n\n    if (fieldValue.__type === 'GeoPoint') {\n      patterns.push('$' + index + ':name ~= POINT($' + (index + 1) + ', $' + (index + 2) + ')');\n      values.push(fieldName, fieldValue.longitude, fieldValue.latitude);\n      index += 3;\n    }\n\n    if (fieldValue.__type === 'Polygon') {\n      const value = convertPolygonToSQL(fieldValue.coordinates);\n      patterns.push(`$${index}:name ~= $${index + 1}::polygon`);\n      values.push(fieldName, value);\n      index += 2;\n    }\n\n    Object.keys(ParseToPosgresComparator).forEach(cmp => {\n      if (fieldValue[cmp] || fieldValue[cmp] === 0) {\n        const pgComparator = ParseToPosgresComparator[cmp];\n        patterns.push(`$${index}:name ${pgComparator} $${index + 1}`);\n        values.push(fieldName, toPostgresValue(fieldValue[cmp]));\n        index += 2;\n      }\n    });\n\n    if (initialPatternsLength === patterns.length) {\n      throw new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, `Postgres doesn't support this query type yet ${JSON.stringify(fieldValue)}`);\n    }\n  }\n  values = values.map(transformValue);\n  return { pattern: patterns.join(' AND '), values, sorts };\n}\n\nexport class PostgresStorageAdapter implements StorageAdapter {\n\n  canSortOnJoinTables: boolean;\n\n  // Private\n  _collectionPrefix: string;\n  _client: any;\n  _pgp: any;\n\n  constructor({\n    uri,\n    collectionPrefix = '',\n    databaseOptions\n  }: any) {\n    this._collectionPrefix = collectionPrefix;\n    const { client, pgp } = createClient(uri, databaseOptions);\n    this._client = client;\n    this._pgp = pgp;\n    this.canSortOnJoinTables = false;\n  }\n\n  handleShutdown() {\n    if (!this._client) {\n      return;\n    }\n    this._client.$pool.end();\n  }\n\n  _ensureSchemaCollectionExists(conn: any) {\n    conn = conn || this._client;\n    return conn.none('CREATE TABLE IF NOT EXISTS \"_SCHEMA\" ( \"className\" varChar(120), \"schema\" jsonb, \"isParseClass\" bool, PRIMARY KEY (\"className\") )')\n      .catch(error => {\n        if (error.code === PostgresDuplicateRelationError\n          || error.code === PostgresUniqueIndexViolationError\n          || error.code === PostgresDuplicateObjectError) {\n        // Table already exists, must have been created by a different request. Ignore error.\n        } else {\n          throw error;\n        }\n      });\n  }\n\n  classExists(name: string) {\n    return this._client.one('SELECT EXISTS (SELECT 1 FROM information_schema.tables WHERE table_name = $1)', [name], a => a.exists);\n  }\n\n  setClassLevelPermissions(className: string, CLPs: any) {\n    const self = this;\n    return this._client.task('set-class-level-permissions', function * (t) {\n      yield self._ensureSchemaCollectionExists(t);\n      const values = [className, 'schema', 'classLevelPermissions', JSON.stringify(CLPs)];\n      yield t.none(`UPDATE \"_SCHEMA\" SET $2:name = json_object_set_key($2:name, $3::text, $4::jsonb) WHERE \"className\"=$1`, values);\n    });\n  }\n\n  setIndexesWithSchemaFormat(className: string, submittedIndexes: any, existingIndexes: any = {}, fields: any, conn: ?any): Promise<void> {\n    conn = conn || this._client;\n    const self = this;\n    if (submittedIndexes === undefined) {\n      return Promise.resolve();\n    }\n    if (Object.keys(existingIndexes).length === 0) {\n      existingIndexes = { _id_: { _id: 1} };\n    }\n    const deletedIndexes = [];\n    const insertedIndexes = [];\n    Object.keys(submittedIndexes).forEach(name => {\n      const field = submittedIndexes[name];\n      if (existingIndexes[name] && field.__op !== 'Delete') {\n        throw new Parse.Error(Parse.Error.INVALID_QUERY, `Index ${name} exists, cannot update.`);\n      }\n      if (!existingIndexes[name] && field.__op === 'Delete') {\n        throw new Parse.Error(Parse.Error.INVALID_QUERY, `Index ${name} does not exist, cannot delete.`);\n      }\n      if (field.__op === 'Delete') {\n        deletedIndexes.push(name);\n        delete existingIndexes[name];\n      } else {\n        Object.keys(field).forEach(key => {\n          if (!fields.hasOwnProperty(key)) {\n            throw new Parse.Error(Parse.Error.INVALID_QUERY, `Field ${key} does not exist, cannot add index.`);\n          }\n        });\n        existingIndexes[name] = field;\n        insertedIndexes.push({\n          key: field,\n          name,\n        });\n      }\n    });\n    return conn.tx('set-indexes-with-schema-format', function * (t) {\n      if (insertedIndexes.length > 0) {\n        yield self.createIndexes(className, insertedIndexes, t);\n      }\n      if (deletedIndexes.length > 0) {\n        yield self.dropIndexes(className, deletedIndexes, t);\n      }\n      yield self._ensureSchemaCollectionExists(t);\n      yield t.none('UPDATE \"_SCHEMA\" SET $2:name = json_object_set_key($2:name, $3::text, $4::jsonb) WHERE \"className\"=$1', [className, 'schema', 'indexes', JSON.stringify(existingIndexes)]);\n    });\n  }\n\n  createClass(className: string, schema: SchemaType, conn: ?any) {\n    conn = conn || this._client;\n    return conn.tx('create-class', t => {\n      const q1 = this.createTable(className, schema, t);\n      const q2 = t.none('INSERT INTO \"_SCHEMA\" (\"className\", \"schema\", \"isParseClass\") VALUES ($<className>, $<schema>, true)', { className, schema });\n      const q3 = this.setIndexesWithSchemaFormat(className, schema.indexes, {}, schema.fields, t);\n      return t.batch([q1, q2, q3]);\n    })\n      .then(() => {\n        return toParseSchema(schema);\n      })\n      .catch(err => {\n        if (err.data[0].result.code === PostgresTransactionAbortedError) {\n          err = err.data[1].result;\n        }\n        if (err.code === PostgresUniqueIndexViolationError && err.detail.includes(className)) {\n          throw new Parse.Error(Parse.Error.DUPLICATE_VALUE, `Class ${className} already exists.`)\n        }\n        throw err;\n      })\n  }\n\n  // Just create a table, do not insert in schema\n  createTable(className: string, schema: SchemaType, conn: any) {\n    conn = conn || this._client;\n    const self = this;\n    debug('createTable', className, schema);\n    const valuesArray = [];\n    const patternsArray = [];\n    const fields = Object.assign({}, schema.fields);\n    if (className === '_User') {\n      fields._email_verify_token_expires_at = {type: 'Date'};\n      fields._email_verify_token = {type: 'String'};\n      fields._account_lockout_expires_at = {type: 'Date'};\n      fields._failed_login_count = {type: 'Number'};\n      fields._perishable_token = {type: 'String'};\n      fields._perishable_token_expires_at = {type: 'Date'};\n      fields._password_changed_at = {type: 'Date'};\n      fields._password_history = { type: 'Array'};\n    }\n    let index = 2;\n    const relations = [];\n    Object.keys(fields).forEach((fieldName) => {\n      const parseType = fields[fieldName];\n      // Skip when it's a relation\n      // We'll create the tables later\n      if (parseType.type === 'Relation') {\n        relations.push(fieldName)\n        return;\n      }\n      if (['_rperm', '_wperm'].indexOf(fieldName) >= 0) {\n        parseType.contents = { type: 'String' };\n      }\n      valuesArray.push(fieldName);\n      valuesArray.push(parseTypeToPostgresType(parseType));\n      patternsArray.push(`$${index}:name $${index + 1}:raw`);\n      if (fieldName === 'objectId') {\n        patternsArray.push(`PRIMARY KEY ($${index}:name)`)\n      }\n      index = index + 2;\n    });\n    const qs = `CREATE TABLE IF NOT EXISTS $1:name (${patternsArray.join()})`;\n    const values = [className, ...valuesArray];\n\n    return conn.task('create-table', function * (t) {\n      try {\n        yield self._ensureSchemaCollectionExists(t);\n        yield t.none(qs, values);\n      } catch(error) {\n        if (error.code !== PostgresDuplicateRelationError) {\n          throw error;\n        }\n        // ELSE: Table already exists, must have been created by a different request. Ignore the error.\n      }\n      yield t.tx('create-table-tx', tx => {\n        return tx.batch(relations.map(fieldName => {\n          return tx.none('CREATE TABLE IF NOT EXISTS $<joinTable:name> (\"relatedId\" varChar(120), \"owningId\" varChar(120), PRIMARY KEY(\"relatedId\", \"owningId\") )', {joinTable: `_Join:${fieldName}:${className}`});\n        }));\n      });\n    });\n  }\n\n  schemaUpgrade(className: string, schema: SchemaType, conn: any) {\n    debug('schemaUpgrade', { className, schema });\n    conn = conn || this._client;\n    const self = this;\n\n    return conn.tx('schema-upgrade', function * (t) {\n      const columns = yield t.map('SELECT column_name FROM information_schema.columns WHERE table_name = $<className>', { className }, a => a.column_name);\n      const newColumns = Object.keys(schema.fields)\n        .filter(item => columns.indexOf(item) === -1)\n        .map(fieldName => self.addFieldIfNotExists(className, fieldName, schema.fields[fieldName], t));\n\n      yield t.batch(newColumns);\n    });\n  }\n\n  addFieldIfNotExists(className: string, fieldName: string, type: any, conn: any) {\n    // TODO: Must be revised for invalid logic...\n    debug('addFieldIfNotExists', {className, fieldName, type});\n    conn = conn || this._client;\n    const self = this;\n    return conn.tx('add-field-if-not-exists', function * (t) {\n      if (type.type !== 'Relation') {\n        try {\n          yield t.none('ALTER TABLE $<className:name> ADD COLUMN $<fieldName:name> $<postgresType:raw>', {\n            className,\n            fieldName,\n            postgresType: parseTypeToPostgresType(type)\n          });\n        } catch(error) {\n          if (error.code === PostgresRelationDoesNotExistError) {\n            return yield self.createClass(className, {fields: {[fieldName]: type}}, t);\n          }\n          if (error.code !== PostgresDuplicateColumnError) {\n            throw error;\n          }\n          // Column already exists, created by other request. Carry on to see if it's the right type.\n        }\n      } else {\n        yield t.none('CREATE TABLE IF NOT EXISTS $<joinTable:name> (\"relatedId\" varChar(120), \"owningId\" varChar(120), PRIMARY KEY(\"relatedId\", \"owningId\") )', {joinTable: `_Join:${fieldName}:${className}`});\n      }\n\n      const result = yield t.any('SELECT \"schema\" FROM \"_SCHEMA\" WHERE \"className\" = $<className> and (\"schema\"::json->\\'fields\\'->$<fieldName>) is not null', {className, fieldName});\n\n      if (result[0]) {\n        throw 'Attempted to add a field that already exists';\n      } else {\n        const path = `{fields,${fieldName}}`;\n        yield t.none('UPDATE \"_SCHEMA\" SET \"schema\"=jsonb_set(\"schema\", $<path>, $<type>)  WHERE \"className\"=$<className>', {path, type, className});\n      }\n    });\n  }\n\n  // Drops a collection. Resolves with true if it was a Parse Schema (eg. _User, Custom, etc.)\n  // and resolves with false if it wasn't (eg. a join table). Rejects if deletion was impossible.\n  deleteClass(className: string) {\n    const operations = [\n      {query: `DROP TABLE IF EXISTS $1:name`, values: [className]},\n      {query: `DELETE FROM \"_SCHEMA\" WHERE \"className\" = $1`, values: [className]}\n    ];\n    return this._client.tx(t => t.none(this._pgp.helpers.concat(operations)))\n      .then(() => className.indexOf('_Join:') != 0); // resolves with false when _Join table\n  }\n\n  // Delete all data known to this adapter. Used for testing.\n  deleteAllClasses() {\n    const now = new Date().getTime();\n    const helpers = this._pgp.helpers;\n    debug('deleteAllClasses');\n\n    return this._client.task('delete-all-classes', function * (t) {\n      try {\n        const results = yield t.any('SELECT * FROM \"_SCHEMA\"');\n        const joins = results.reduce((list: Array<string>, schema: any) => {\n          return list.concat(joinTablesForSchema(schema.schema));\n        }, []);\n        const classes = ['_SCHEMA', '_PushStatus', '_JobStatus', '_JobSchedule', '_Hooks', '_GlobalConfig', '_Audience', ...results.map(result => result.className), ...joins];\n        const queries = classes.map(className => ({query: 'DROP TABLE IF EXISTS $<className:name>', values: {className}}));\n        yield t.tx(tx => tx.none(helpers.concat(queries)));\n      } catch(error) {\n        if (error.code !== PostgresRelationDoesNotExistError) {\n          throw error;\n        }\n        // No _SCHEMA collection. Don't delete anything.\n      }\n    })\n      .then(() => {\n        debug(`deleteAllClasses done in ${new Date().getTime() - now}`);\n      });\n  }\n\n  dropDatabase() {\n    return this.deleteAllClasses();\n  }\n\n  // Remove the column and all the data. For Relations, the _Join collection is handled\n  // specially, this function does not delete _Join columns. It should, however, indicate\n  // that the relation fields does not exist anymore. In mongo, this means removing it from\n  // the _SCHEMA collection.  There should be no actual data in the collection under the same name\n  // as the relation column, so it's fine to attempt to delete it. If the fields listed to be\n  // deleted do not exist, this function should return successfully anyways. Checking for\n  // attempts to delete non-existent fields is the responsibility of Parse Server.\n\n  // This function is not obligated to delete fields atomically. It is given the field\n  // names in a list so that databases that are capable of deleting fields atomically\n  // may do so.\n\n  // Returns a Promise.\n  deleteFields(className: string, schema: SchemaType, fieldNames: string[]): Promise<void> {\n    debug('deleteFields', className, fieldNames);\n    fieldNames = fieldNames.reduce((list: Array<string>, fieldName: string) => {\n      const field = schema.fields[fieldName]\n      if (field.type !== 'Relation') {\n        list.push(fieldName);\n      }\n      delete schema.fields[fieldName];\n      return list;\n    }, []);\n\n    const values = [className, ...fieldNames];\n    const columns = fieldNames.map((name, idx) => {\n      return `$${idx + 2}:name`;\n    }).join(', DROP COLUMN');\n\n    return this._client.tx('delete-fields', function * (t) {\n      yield t.none('UPDATE \"_SCHEMA\" SET \"schema\"=$<schema> WHERE \"className\"=$<className>', {schema, className});\n      if (values.length > 1) {\n        yield t.none(`ALTER TABLE $1:name DROP COLUMN ${columns}`, values);\n      }\n    });\n  }\n\n  // Return a promise for all schemas known to this adapter, in Parse format. In case the\n  // schemas cannot be retrieved, returns a promise that rejects. Requirements for the\n  // rejection reason are TBD.\n  getAllClasses() {\n    const self = this;\n    return this._client.task('get-all-classes', function * (t) {\n      yield self._ensureSchemaCollectionExists(t);\n      return yield t.map('SELECT * FROM \"_SCHEMA\"', null, row => toParseSchema({ className: row.className, ...row.schema }));\n    });\n  }\n\n  // Return a promise for the schema with the given name, in Parse format. If\n  // this adapter doesn't know about the schema, return a promise that rejects with\n  // undefined as the reason.\n  getClass(className: string) {\n    debug('getClass', className);\n    return this._client.any('SELECT * FROM \"_SCHEMA\" WHERE \"className\"=$<className>', { className })\n      .then(result => {\n        if (result.length !== 1) {\n          throw undefined;\n        }\n        return result[0].schema;\n      })\n      .then(toParseSchema);\n  }\n\n  // TODO: remove the mongo format dependency in the return value\n  createObject(className: string, schema: SchemaType, object: any) {\n    debug('createObject', className, object);\n    let columnsArray = [];\n    const valuesArray = [];\n    schema = toPostgresSchema(schema);\n    const geoPoints = {};\n\n    object = handleDotFields(object);\n\n    validateKeys(object);\n\n    Object.keys(object).forEach(fieldName => {\n      if (object[fieldName] === null) {\n        return;\n      }\n      var authDataMatch = fieldName.match(/^_auth_data_([a-zA-Z0-9_]+)$/);\n      if (authDataMatch) {\n        var provider = authDataMatch[1];\n        object['authData'] = object['authData'] || {};\n        object['authData'][provider] = object[fieldName];\n        delete object[fieldName];\n        fieldName = 'authData';\n      }\n\n      columnsArray.push(fieldName);\n      if (!schema.fields[fieldName] && className === '_User') {\n        if (fieldName === '_email_verify_token' ||\n            fieldName === '_failed_login_count' ||\n            fieldName === '_perishable_token' ||\n            fieldName === '_password_history'){\n          valuesArray.push(object[fieldName]);\n        }\n\n        if (fieldName === '_email_verify_token_expires_at') {\n          if (object[fieldName]) {\n            valuesArray.push(object[fieldName].iso);\n          } else {\n            valuesArray.push(null);\n          }\n        }\n\n        if (fieldName === '_account_lockout_expires_at' ||\n            fieldName === '_perishable_token_expires_at' ||\n            fieldName === '_password_changed_at') {\n          if (object[fieldName]) {\n            valuesArray.push(object[fieldName].iso);\n          } else {\n            valuesArray.push(null);\n          }\n        }\n        return;\n      }\n      switch (schema.fields[fieldName].type) {\n      case 'Date':\n        if (object[fieldName]) {\n          valuesArray.push(object[fieldName].iso);\n        } else {\n          valuesArray.push(null);\n        }\n        break;\n      case 'Pointer':\n        valuesArray.push(object[fieldName].objectId);\n        break;\n      case 'Array':\n        if (['_rperm', '_wperm'].indexOf(fieldName) >= 0) {\n          valuesArray.push(object[fieldName]);\n        } else {\n          valuesArray.push(JSON.stringify(object[fieldName]));\n        }\n        break;\n      case 'Object':\n      case 'Bytes':\n      case 'String':\n      case 'Number':\n      case 'Boolean':\n        valuesArray.push(object[fieldName]);\n        break;\n      case 'File':\n        valuesArray.push(object[fieldName].name);\n        break;\n      case 'Polygon': {\n        const value = convertPolygonToSQL(object[fieldName].coordinates);\n        valuesArray.push(value);\n        break;\n      }\n      case 'GeoPoint':\n        // pop the point and process later\n        geoPoints[fieldName] = object[fieldName];\n        columnsArray.pop();\n        break;\n      default:\n        throw `Type ${schema.fields[fieldName].type} not supported yet`;\n      }\n    });\n\n    columnsArray = columnsArray.concat(Object.keys(geoPoints));\n    const initialValues = valuesArray.map((val, index) => {\n      let termination = '';\n      const fieldName = columnsArray[index];\n      if (['_rperm','_wperm'].indexOf(fieldName) >= 0) {\n        termination = '::text[]';\n      } else if (schema.fields[fieldName] && schema.fields[fieldName].type === 'Array') {\n        termination = '::jsonb';\n      }\n      return `$${index + 2 + columnsArray.length}${termination}`;\n    });\n    const geoPointsInjects = Object.keys(geoPoints).map((key) => {\n      const value = geoPoints[key];\n      valuesArray.push(value.longitude, value.latitude);\n      const l = valuesArray.length + columnsArray.length;\n      return `POINT($${l}, $${l + 1})`;\n    });\n\n    const columnsPattern = columnsArray.map((col, index) => `$${index + 2}:name`).join();\n    const valuesPattern = initialValues.concat(geoPointsInjects).join()\n\n    const qs = `INSERT INTO $1:name (${columnsPattern}) VALUES (${valuesPattern})`\n    const values = [className, ...columnsArray, ...valuesArray]\n    debug(qs, values);\n    return this._client.none(qs, values)\n      .then(() => ({ ops: [object] }))\n      .catch(error => {\n        if (error.code === PostgresUniqueIndexViolationError) {\n          const err = new Parse.Error(Parse.Error.DUPLICATE_VALUE, 'A duplicate value for a field with unique values was provided');\n          err.underlyingError = error;\n          if (error.constraint) {\n            const matches = error.constraint.match(/unique_([a-zA-Z]+)/);\n            if (matches && Array.isArray(matches)) {\n              err.userInfo = { duplicated_field: matches[1] };\n            }\n          }\n          error = err;\n        }\n        throw error;\n      });\n  }\n\n  // Remove all objects that match the given Parse Query.\n  // If no objects match, reject with OBJECT_NOT_FOUND. If objects are found and deleted, resolve with undefined.\n  // If there is some other error, reject with INTERNAL_SERVER_ERROR.\n  deleteObjectsByQuery(className: string, schema: SchemaType, query: QueryType) {\n    debug('deleteObjectsByQuery', className, query);\n    const values = [className];\n    const index = 2;\n    const where = buildWhereClause({ schema, index, query })\n    values.push(...where.values);\n    if (Object.keys(query).length === 0) {\n      where.pattern = 'TRUE';\n    }\n    const qs = `WITH deleted AS (DELETE FROM $1:name WHERE ${where.pattern} RETURNING *) SELECT count(*) FROM deleted`;\n    debug(qs, values);\n    return this._client.one(qs, values , a => +a.count)\n      .then(count => {\n        if (count === 0) {\n          throw new Parse.Error(Parse.Error.OBJECT_NOT_FOUND, 'Object not found.');\n        } else {\n          return count;\n        }\n      })\n      .catch(error => {\n        if (error.code !== PostgresRelationDoesNotExistError) {\n          throw error;\n        }\n        // ELSE: Don't delete anything if doesn't exist\n      });\n  }\n  // Return value not currently well specified.\n  findOneAndUpdate(className: string, schema: SchemaType, query: QueryType, update: any): Promise<any> {\n    debug('findOneAndUpdate', className, query, update);\n    return this.updateObjectsByQuery(className, schema, query, update)\n      .then((val) => val[0]);\n  }\n\n  // Apply the update to all objects that match the given Parse Query.\n  updateObjectsByQuery(className: string, schema: SchemaType, query: QueryType, update: any): Promise<[any]> {\n    debug('updateObjectsByQuery', className, query, update);\n    const updatePatterns = [];\n    const values = [className]\n    let index = 2;\n    schema = toPostgresSchema(schema);\n\n    const originalUpdate = {...update};\n    update = handleDotFields(update);\n    // Resolve authData first,\n    // So we don't end up with multiple key updates\n    for (const fieldName in update) {\n      const authDataMatch = fieldName.match(/^_auth_data_([a-zA-Z0-9_]+)$/);\n      if (authDataMatch) {\n        var provider = authDataMatch[1];\n        const value = update[fieldName];\n        delete update[fieldName];\n        update['authData'] = update['authData'] || {};\n        update['authData'][provider] = value;\n      }\n    }\n\n    for (const fieldName in update) {\n      const fieldValue = update[fieldName];\n      if (fieldValue === null) {\n        updatePatterns.push(`$${index}:name = NULL`);\n        values.push(fieldName);\n        index += 1;\n      } else if (fieldName == 'authData') {\n        // This recursively sets the json_object\n        // Only 1 level deep\n        const generate = (jsonb: string, key: string, value: any) => {\n          return `json_object_set_key(COALESCE(${jsonb}, '{}'::jsonb), ${key}, ${value})::jsonb`;\n        }\n        const lastKey = `$${index}:name`;\n        const fieldNameIndex = index;\n        index += 1;\n        values.push(fieldName);\n        const update = Object.keys(fieldValue).reduce((lastKey: string, key: string) => {\n          const str = generate(lastKey, `$${index}::text`, `$${index + 1}::jsonb`)\n          index += 2;\n          let value = fieldValue[key];\n          if (value) {\n            if (value.__op === 'Delete') {\n              value = null;\n            } else {\n              value = JSON.stringify(value)\n            }\n          }\n          values.push(key, value);\n          return str;\n        }, lastKey);\n        updatePatterns.push(`$${fieldNameIndex}:name = ${update}`);\n      } else if (fieldValue.__op === 'Increment') {\n        updatePatterns.push(`$${index}:name = COALESCE($${index}:name, 0) + $${index + 1}`);\n        values.push(fieldName, fieldValue.amount);\n        index += 2;\n      } else if (fieldValue.__op === 'Add') {\n        updatePatterns.push(`$${index}:name = array_add(COALESCE($${index}:name, '[]'::jsonb), $${index + 1}::jsonb)`);\n        values.push(fieldName, JSON.stringify(fieldValue.objects));\n        index += 2;\n      } else if (fieldValue.__op === 'Delete') {\n        updatePatterns.push(`$${index}:name = $${index + 1}`)\n        values.push(fieldName, null);\n        index += 2;\n      } else if (fieldValue.__op === 'Remove') {\n        updatePatterns.push(`$${index}:name = array_remove(COALESCE($${index}:name, '[]'::jsonb), $${index + 1}::jsonb)`)\n        values.push(fieldName, JSON.stringify(fieldValue.objects));\n        index += 2;\n      } else if (fieldValue.__op === 'AddUnique') {\n        updatePatterns.push(`$${index}:name = array_add_unique(COALESCE($${index}:name, '[]'::jsonb), $${index + 1}::jsonb)`);\n        values.push(fieldName, JSON.stringify(fieldValue.objects));\n        index += 2;\n      } else if (fieldName === 'updatedAt') { //TODO: stop special casing this. It should check for __type === 'Date' and use .iso\n        updatePatterns.push(`$${index}:name = $${index + 1}`)\n        values.push(fieldName, fieldValue);\n        index += 2;\n      } else if (typeof fieldValue === 'string') {\n        updatePatterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, fieldValue);\n        index += 2;\n      } else if (typeof fieldValue === 'boolean') {\n        updatePatterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, fieldValue);\n        index += 2;\n      } else if (fieldValue.__type === 'Pointer') {\n        updatePatterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, fieldValue.objectId);\n        index += 2;\n      } else if (fieldValue.__type === 'Date') {\n        updatePatterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, toPostgresValue(fieldValue));\n        index += 2;\n      } else if (fieldValue instanceof Date) {\n        updatePatterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, fieldValue);\n        index += 2;\n      } else if (fieldValue.__type === 'File') {\n        updatePatterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, toPostgresValue(fieldValue));\n        index += 2;\n      } else if (fieldValue.__type === 'GeoPoint') {\n        updatePatterns.push(`$${index}:name = POINT($${index + 1}, $${index + 2})`);\n        values.push(fieldName, fieldValue.longitude, fieldValue.latitude);\n        index += 3;\n      } else if (fieldValue.__type === 'Polygon') {\n        const value = convertPolygonToSQL(fieldValue.coordinates);\n        updatePatterns.push(`$${index}:name = $${index + 1}::polygon`);\n        values.push(fieldName, value);\n        index += 2;\n      } else if (fieldValue.__type === 'Relation') {\n        // noop\n      } else if (typeof fieldValue === 'number') {\n        updatePatterns.push(`$${index}:name = $${index + 1}`);\n        values.push(fieldName, fieldValue);\n        index += 2;\n      } else if (typeof fieldValue === 'object'\n                    && schema.fields[fieldName]\n                    && schema.fields[fieldName].type === 'Object') {\n        // Gather keys to increment\n        const keysToIncrement = Object.keys(originalUpdate).filter(k => {\n          // choose top level fields that have a delete operation set\n          // Note that Object.keys is iterating over the **original** update object\n          // and that some of the keys of the original update could be null or undefined:\n          // (See the above check `if (fieldValue === null || typeof fieldValue == \"undefined\")`)\n          const value = originalUpdate[k];\n          return value && value.__op === 'Increment' && k.split('.').length === 2 && k.split(\".\")[0] === fieldName;\n        }).map(k => k.split('.')[1]);\n\n        let incrementPatterns = '';\n        if (keysToIncrement.length > 0) {\n          incrementPatterns = ' || ' + keysToIncrement.map((c) => {\n            const amount = fieldValue[c].amount;\n            return `CONCAT('{\"${c}\":', COALESCE($${index}:name->>'${c}','0')::int + ${amount}, '}')::jsonb`;\n          }).join(' || ');\n          // Strip the keys\n          keysToIncrement.forEach((key) => {\n            delete fieldValue[key];\n          });\n        }\n\n        const keysToDelete: Array<string> = Object.keys(originalUpdate).filter(k => {\n          // choose top level fields that have a delete operation set.\n          const value = originalUpdate[k];\n          return value && value.__op === 'Delete' && k.split('.').length === 2 && k.split(\".\")[0] === fieldName;\n        }).map(k => k.split('.')[1]);\n\n        const deletePatterns = keysToDelete.reduce((p: string, c: string, i: number) => {\n          return p + ` - '$${index + 1 + i}:value'`;\n        }, '');\n\n        updatePatterns.push(`$${index}:name = ('{}'::jsonb ${deletePatterns} ${incrementPatterns} || $${index + 1 + keysToDelete.length}::jsonb )`);\n\n        values.push(fieldName, ...keysToDelete, JSON.stringify(fieldValue));\n        index += 2 + keysToDelete.length;\n      } else if (Array.isArray(fieldValue)\n                    && schema.fields[fieldName]\n                    && schema.fields[fieldName].type === 'Array') {\n        const expectedType = parseTypeToPostgresType(schema.fields[fieldName]);\n        if (expectedType === 'text[]') {\n          updatePatterns.push(`$${index}:name = $${index + 1}::text[]`);\n        } else {\n          let type = 'text';\n          for (const elt of fieldValue) {\n            if (typeof elt == 'object') {\n              type = 'json';\n              break;\n            }\n          }\n          updatePatterns.push(`$${index}:name = array_to_json($${index + 1}::${type}[])::jsonb`);\n        }\n        values.push(fieldName, fieldValue);\n        index += 2;\n      } else {\n        debug('Not supported update', fieldName, fieldValue);\n        return Promise.reject(new Parse.Error(Parse.Error.OPERATION_FORBIDDEN, `Postgres doesn't support update ${JSON.stringify(fieldValue)} yet`));\n      }\n    }\n\n    const where = buildWhereClause({ schema, index, query })\n    values.push(...where.values);\n\n    const whereClause = where.pattern.length > 0 ? `WHERE ${where.pattern}` : '';\n    const qs = `UPDATE $1:name SET ${updatePatterns.join()} ${whereClause} RETURNING *`;\n    debug('update: ', qs, values);\n    return this._client.any(qs, values);\n  }\n\n  // Hopefully, we can get rid of this. It's only used for config and hooks.\n  upsertOneObject(className: string, schema: SchemaType, query: QueryType, update: any) {\n    debug('upsertOneObject', {className, query, update});\n    const createValue = Object.assign({}, query, update);\n    return this.createObject(className, schema, createValue)\n      .catch(error => {\n        // ignore duplicate value errors as it's upsert\n        if (error.code !== Parse.Error.DUPLICATE_VALUE) {\n          throw error;\n        }\n        return this.findOneAndUpdate(className, schema, query, update);\n      });\n  }\n\n  find(className: string, schema: SchemaType, query: QueryType, { skip, limit, sort, keys }: QueryOptions) {\n    debug('find', className, query, {skip, limit, sort, keys });\n    const hasLimit = limit !== undefined;\n    const hasSkip = skip !== undefined;\n    let values = [className];\n    const where = buildWhereClause({ schema, query, index: 2 })\n    values.push(...where.values);\n\n    const wherePattern = where.pattern.length > 0 ? `WHERE ${where.pattern}` : '';\n    const limitPattern = hasLimit ? `LIMIT $${values.length + 1}` : '';\n    if (hasLimit) {\n      values.push(limit);\n    }\n    const skipPattern = hasSkip ? `OFFSET $${values.length + 1}` : '';\n    if (hasSkip) {\n      values.push(skip);\n    }\n\n    let sortPattern = '';\n    if (sort) {\n      const sortCopy: any = sort;\n      const sorting = Object.keys(sort).map((key) => {\n        const transformKey = transformDotFieldToComponents(key).join('->');\n        // Using $idx pattern gives:  non-integer constant in ORDER BY\n        if (sortCopy[key] === 1) {\n          return `${transformKey} ASC`;\n        }\n        return `${transformKey} DESC`;\n      }).join();\n      sortPattern = sort !== undefined && Object.keys(sort).length > 0 ? `ORDER BY ${sorting}` : '';\n    }\n    if (where.sorts && Object.keys((where.sorts: any)).length > 0) {\n      sortPattern = `ORDER BY ${where.sorts.join()}`;\n    }\n\n    let columns = '*';\n    if (keys) {\n      // Exclude empty keys\n      keys = keys.filter((key) => {\n        return key.length > 0;\n      });\n      columns = keys.map((key, index) => {\n        if (key === '$score') {\n          return `ts_rank_cd(to_tsvector($${2}, $${3}:name), to_tsquery($${4}, $${5}), 32) as score`;\n        }\n        return `$${index + values.length + 1}:name`;\n      }).join();\n      values = values.concat(keys);\n    }\n\n    const qs = `SELECT ${columns} FROM $1:name ${wherePattern} ${sortPattern} ${limitPattern} ${skipPattern}`;\n    debug(qs, values);\n    return this._client.any(qs, values)\n      .catch(error => {\n        // Query on non existing table, don't crash\n        if (error.code !== PostgresRelationDoesNotExistError) {\n          throw error;\n        }\n        return [];\n      })\n      .then(results => results.map(object => this.postgresObjectToParseObject(className, object, schema)));\n  }\n\n  // Converts from a postgres-format object to a REST-format object.\n  // Does not strip out anything based on a lack of authentication.\n  postgresObjectToParseObject(className: string, object: any, schema: any) {\n    Object.keys(schema.fields).forEach(fieldName => {\n      if (schema.fields[fieldName].type === 'Pointer' && object[fieldName]) {\n        object[fieldName] = { objectId: object[fieldName], __type: 'Pointer', className: schema.fields[fieldName].targetClass };\n      }\n      if (schema.fields[fieldName].type === 'Relation') {\n        object[fieldName] = {\n          __type: \"Relation\",\n          className: schema.fields[fieldName].targetClass\n        }\n      }\n      if (object[fieldName] && schema.fields[fieldName].type === 'GeoPoint') {\n        object[fieldName] = {\n          __type: \"GeoPoint\",\n          latitude: object[fieldName].y,\n          longitude: object[fieldName].x\n        }\n      }\n      if (object[fieldName] && schema.fields[fieldName].type === 'Polygon') {\n        let coords = object[fieldName];\n        coords = coords.substr(2, coords.length - 4).split('),(');\n        coords = coords.map((point) => {\n          return [\n            parseFloat(point.split(',')[1]),\n            parseFloat(point.split(',')[0])\n          ];\n        });\n        object[fieldName] = {\n          __type: \"Polygon\",\n          coordinates: coords\n        }\n      }\n      if (object[fieldName] && schema.fields[fieldName].type === 'File') {\n        object[fieldName] = {\n          __type: 'File',\n          name: object[fieldName]\n        }\n      }\n    });\n    //TODO: remove this reliance on the mongo format. DB adapter shouldn't know there is a difference between created at and any other date field.\n    if (object.createdAt) {\n      object.createdAt = object.createdAt.toISOString();\n    }\n    if (object.updatedAt) {\n      object.updatedAt = object.updatedAt.toISOString();\n    }\n    if (object.expiresAt) {\n      object.expiresAt = { __type: 'Date', iso: object.expiresAt.toISOString() };\n    }\n    if (object._email_verify_token_expires_at) {\n      object._email_verify_token_expires_at = { __type: 'Date', iso: object._email_verify_token_expires_at.toISOString() };\n    }\n    if (object._account_lockout_expires_at) {\n      object._account_lockout_expires_at = { __type: 'Date', iso: object._account_lockout_expires_at.toISOString() };\n    }\n    if (object._perishable_token_expires_at) {\n      object._perishable_token_expires_at = { __type: 'Date', iso: object._perishable_token_expires_at.toISOString() };\n    }\n    if (object._password_changed_at) {\n      object._password_changed_at = { __type: 'Date', iso: object._password_changed_at.toISOString() };\n    }\n\n    for (const fieldName in object) {\n      if (object[fieldName] === null) {\n        delete object[fieldName];\n      }\n      if (object[fieldName] instanceof Date) {\n        object[fieldName] = { __type: 'Date', iso: object[fieldName].toISOString() };\n      }\n    }\n\n    return object;\n  }\n\n  // Create a unique index. Unique indexes on nullable fields are not allowed. Since we don't\n  // currently know which fields are nullable and which aren't, we ignore that criteria.\n  // As such, we shouldn't expose this function to users of parse until we have an out-of-band\n  // Way of determining if a field is nullable. Undefined doesn't count against uniqueness,\n  // which is why we use sparse indexes.\n  ensureUniqueness(className: string, schema: SchemaType, fieldNames: string[]) {\n    // Use the same name for every ensureUniqueness attempt, because postgres\n    // Will happily create the same index with multiple names.\n    const constraintName = `unique_${fieldNames.sort().join('_')}`;\n    const constraintPatterns = fieldNames.map((fieldName, index) => `$${index + 3}:name`);\n    const qs = `ALTER TABLE $1:name ADD CONSTRAINT $2:name UNIQUE (${constraintPatterns.join()})`;\n    return this._client.none(qs, [className, constraintName, ...fieldNames])\n      .catch(error => {\n        if (error.code === PostgresDuplicateRelationError && error.message.includes(constraintName)) {\n        // Index already exists. Ignore error.\n        } else if (error.code === PostgresUniqueIndexViolationError && error.message.includes(constraintName)) {\n        // Cast the error into the proper parse error\n          throw new Parse.Error(Parse.Error.DUPLICATE_VALUE, 'A duplicate value for a field with unique values was provided');\n        } else {\n          throw error;\n        }\n      });\n  }\n\n  // Executes a count.\n  count(className: string, schema: SchemaType, query: QueryType) {\n    debug('count', className, query);\n    const values = [className];\n    const where = buildWhereClause({ schema, query, index: 2 });\n    values.push(...where.values);\n\n    const wherePattern = where.pattern.length > 0 ? `WHERE ${where.pattern}` : '';\n    const qs = `SELECT count(*) FROM $1:name ${wherePattern}`;\n    return this._client.one(qs, values, a => +a.count)\n      .catch(error => {\n        if (error.code !== PostgresRelationDoesNotExistError) {\n          throw error;\n        }\n        return 0;\n      });\n  }\n\n  distinct(className: string, schema: SchemaType, query: QueryType, fieldName: string) {\n    debug('distinct', className, query);\n    let field = fieldName;\n    let column = fieldName;\n    const isNested = fieldName.indexOf('.') >= 0;\n    if (isNested) {\n      field = transformDotFieldToComponents(fieldName).join('->');\n      column = fieldName.split('.')[0];\n    }\n    const isArrayField = schema.fields\n          && schema.fields[fieldName]\n          && schema.fields[fieldName].type === 'Array';\n    const isPointerField = schema.fields\n          && schema.fields[fieldName]\n          && schema.fields[fieldName].type === 'Pointer';\n    const values = [field, column, className];\n    const where = buildWhereClause({ schema, query, index: 4 });\n    values.push(...where.values);\n\n    const wherePattern = where.pattern.length > 0 ? `WHERE ${where.pattern}` : '';\n    const transformer = isArrayField ? 'jsonb_array_elements' : 'ON';\n    let qs = `SELECT DISTINCT ${transformer}($1:name) $2:name FROM $3:name ${wherePattern}`;\n    if (isNested) {\n      qs = `SELECT DISTINCT ${transformer}($1:raw) $2:raw FROM $3:name ${wherePattern}`;\n    }\n    debug(qs, values);\n    return this._client.any(qs, values)\n      .catch((error) => {\n        if (error.code === PostgresMissingColumnError) {\n          return [];\n        }\n        throw error;\n      })\n      .then((results) => {\n        if (!isNested) {\n          results = results.filter((object) => object[field] !== null);\n          return results.map(object => {\n            if (!isPointerField) {\n              return object[field];\n            }\n            return {\n              __type: 'Pointer',\n              className:  schema.fields[fieldName].targetClass,\n              objectId: object[field]\n            };\n          });\n        }\n        const child = fieldName.split('.')[1];\n        return results.map(object => object[column][child]);\n      })\n      .then(results => results.map(object => this.postgresObjectToParseObject(className, object, schema)));\n  }\n\n  aggregate(className: string, schema: any, pipeline: any) {\n    debug('aggregate', className, pipeline);\n    const values = [className];\n    let index: number = 2;\n    let columns: string[] = [];\n    let countField = null;\n    let groupValues = null;\n    let wherePattern = '';\n    let limitPattern = '';\n    let skipPattern = '';\n    let sortPattern = '';\n    let groupPattern = '';\n    for (let i = 0; i < pipeline.length; i += 1) {\n      const stage = pipeline[i];\n      if (stage.$group) {\n        for (const field in stage.$group) {\n          const value = stage.$group[field];\n          if (value === null || value === undefined) {\n            continue;\n          }\n          if (field === '_id' && (typeof value === 'string') && value !== '') {\n            columns.push(`$${index}:name AS \"objectId\"`);\n            groupPattern = `GROUP BY $${index}:name`;\n            values.push(transformAggregateField(value));\n            index += 1;\n            continue;\n          }\n          if (field === '_id' && (typeof value === 'object') && Object.keys(value).length !== 0) {\n            groupValues = value;\n            const groupByFields = [];\n            for (const alias in value) {\n              const operation = Object.keys(value[alias])[0];\n              const source = transformAggregateField(value[alias][operation]);\n              if (mongoAggregateToPostgres[operation]) {\n                if (!groupByFields.includes(`\"${source}\"`)) {\n                  groupByFields.push(`\"${source}\"`);\n                }\n                columns.push(`EXTRACT(${mongoAggregateToPostgres[operation]} FROM $${index}:name AT TIME ZONE 'UTC') AS $${index + 1}:name`);\n                values.push(source, alias);\n                index += 2;\n              }\n            }\n            groupPattern = `GROUP BY $${index}:raw`;\n            values.push(groupByFields.join());\n            index += 1;\n            continue;\n          }\n          if (value.$sum) {\n            if (typeof value.$sum === 'string') {\n              columns.push(`SUM($${index}:name) AS $${index + 1}:name`);\n              values.push(transformAggregateField(value.$sum), field);\n              index += 2;\n            } else {\n              countField = field;\n              columns.push(`COUNT(*) AS $${index}:name`);\n              values.push(field);\n              index += 1;\n            }\n          }\n          if (value.$max) {\n            columns.push(`MAX($${index}:name) AS $${index + 1}:name`);\n            values.push(transformAggregateField(value.$max), field);\n            index += 2;\n          }\n          if (value.$min) {\n            columns.push(`MIN($${index}:name) AS $${index + 1}:name`);\n            values.push(transformAggregateField(value.$min), field);\n            index += 2;\n          }\n          if (value.$avg) {\n            columns.push(`AVG($${index}:name) AS $${index + 1}:name`);\n            values.push(transformAggregateField(value.$avg), field);\n            index += 2;\n          }\n        }\n      } else {\n        columns.push('*');\n      }\n      if (stage.$project) {\n        if (columns.includes('*')) {\n          columns = [];\n        }\n        for (const field in stage.$project) {\n          const value = stage.$project[field];\n          if ((value === 1 || value === true)) {\n            columns.push(`$${index}:name`);\n            values.push(field);\n            index += 1;\n          }\n        }\n      }\n      if (stage.$match) {\n        const patterns = [];\n        const orOrAnd = stage.$match.hasOwnProperty('$or') ? ' OR ' : ' AND ';\n\n        if (stage.$match.$or) {\n          const collapse = {};\n          stage.$match.$or.forEach((element) => {\n            for (const key in element) {\n              collapse[key] = element[key];\n            }\n          });\n          stage.$match = collapse;\n        }\n        for (const field in stage.$match) {\n          const value = stage.$match[field];\n          const matchPatterns = [];\n          Object.keys(ParseToPosgresComparator).forEach((cmp) => {\n            if (value[cmp]) {\n              const pgComparator = ParseToPosgresComparator[cmp];\n              matchPatterns.push(`$${index}:name ${pgComparator} $${index + 1}`);\n              values.push(field, toPostgresValue(value[cmp]));\n              index += 2;\n            }\n          });\n          if (matchPatterns.length > 0) {\n            patterns.push(`(${matchPatterns.join(' AND ')})`);\n          }\n          if (schema.fields[field] && schema.fields[field].type && matchPatterns.length === 0) {\n            patterns.push(`$${index}:name = $${index + 1}`);\n            values.push(field, value);\n            index += 2;\n          }\n        }\n        wherePattern = patterns.length > 0 ? `WHERE ${patterns.join(` ${orOrAnd} `)}` : '';\n      }\n      if (stage.$limit) {\n        limitPattern = `LIMIT $${index}`;\n        values.push(stage.$limit);\n        index += 1;\n      }\n      if (stage.$skip) {\n        skipPattern = `OFFSET $${index}`;\n        values.push(stage.$skip);\n        index += 1;\n      }\n      if (stage.$sort) {\n        const sort = stage.$sort;\n        const keys = Object.keys(sort);\n        const sorting = keys.map((key) => {\n          const transformer = sort[key] === 1 ? 'ASC' : 'DESC';\n          const order = `$${index}:name ${transformer}`;\n          index += 1;\n          return order;\n        }).join();\n        values.push(...keys);\n        sortPattern = sort !== undefined && sorting.length > 0 ? `ORDER BY ${sorting}` : '';\n      }\n    }\n\n    const qs = `SELECT ${columns.join()} FROM $1:name ${wherePattern} ${sortPattern} ${limitPattern} ${skipPattern} ${groupPattern}`;\n    debug(qs, values);\n    return this._client.map(qs, values, a => this.postgresObjectToParseObject(className, a, schema))\n      .then(results => {\n        results.forEach(result => {\n          if (!result.hasOwnProperty('objectId')) {\n            result.objectId = null;\n          }\n          if (groupValues) {\n            result.objectId = {};\n            for (const key in groupValues) {\n              result.objectId[key] = result[key];\n              delete result[key];\n            }\n          }\n          if (countField) {\n            result[countField] = parseInt(result[countField], 10);\n          }\n        });\n        return results;\n      });\n  }\n\n  performInitialization({ VolatileClassesSchemas }: any) {\n    // TODO: This method needs to be rewritten to make proper use of connections (@vitaly-t)\n    debug('performInitialization');\n    const promises = VolatileClassesSchemas.map((schema) => {\n      return this.createTable(schema.className, schema)\n        .catch((err) => {\n          if (err.code === PostgresDuplicateRelationError || err.code === Parse.Error.INVALID_CLASS_NAME) {\n            return Promise.resolve();\n          }\n          throw err;\n        })\n        .then(() => this.schemaUpgrade(schema.className, schema));\n    });\n    return Promise.all(promises)\n      .then(() => {\n        return this._client.tx('perform-initialization', t => {\n          return t.batch([\n            t.none(sql.misc.jsonObjectSetKeys),\n            t.none(sql.array.add),\n            t.none(sql.array.addUnique),\n            t.none(sql.array.remove),\n            t.none(sql.array.containsAll),\n            t.none(sql.array.containsAllRegex),\n            t.none(sql.array.contains)\n          ]);\n        });\n      })\n      .then(data => {\n        debug(`initializationDone in ${data.duration}`);\n      })\n      .catch(error => {\n        /* eslint-disable no-console */\n        console.error(error);\n      });\n  }\n\n  createIndexes(className: string, indexes: any, conn: ?any): Promise<void> {\n    return (conn || this._client).tx(t => t.batch(indexes.map(i => {\n      return t.none('CREATE INDEX $1:name ON $2:name ($3:name)', [i.name, className, i.key]);\n    })));\n  }\n\n  createIndexesIfNeeded(className: string, fieldName: string, type: any, conn: ?any): Promise<void> {\n    return (conn || this._client).none('CREATE INDEX $1:name ON $2:name ($3:name)', [fieldName, className, type]);\n  }\n\n  dropIndexes(className: string, indexes: any, conn: any): Promise<void> {\n    const queries = indexes.map(i => ({query: 'DROP INDEX $1:name', values: i}));\n    return (conn || this._client).tx(t => t.none(this._pgp.helpers.concat(queries)));\n  }\n\n  getIndexes(className: string) {\n    const qs = 'SELECT * FROM pg_indexes WHERE tablename = ${className}';\n    return this._client.any(qs, {className});\n  }\n\n  updateSchemaWithIndexes(): Promise<void> {\n    return Promise.resolve();\n  }\n}\n\nfunction convertPolygonToSQL(polygon) {\n  if (polygon.length < 3) {\n    throw new Parse.Error(\n      Parse.Error.INVALID_JSON,\n      `Polygon must have at least 3 values`\n    );\n  }\n  if (polygon[0][0] !== polygon[polygon.length - 1][0] ||\n    polygon[0][1] !== polygon[polygon.length - 1][1]) {\n    polygon.push(polygon[0]);\n  }\n  const unique = polygon.filter((item, index, ar) => {\n    let foundIndex = -1;\n    for (let i = 0; i < ar.length; i += 1) {\n      const pt = ar[i];\n      if (pt[0] === item[0] &&\n          pt[1] === item[1]) {\n        foundIndex = i;\n        break;\n      }\n    }\n    return foundIndex === index;\n  });\n  if (unique.length < 3) {\n    throw new Parse.Error(\n      Parse.Error.INTERNAL_SERVER_ERROR,\n      'GeoJSON: Loop must have at least 3 different vertices'\n    );\n  }\n  const points = polygon.map((point) => {\n    Parse.GeoPoint._validate(parseFloat(point[1]), parseFloat(point[0]));\n    return `(${point[1]}, ${point[0]})`;\n  }).join(', ');\n  return `(${points})`;\n}\n\nfunction removeWhiteSpace(regex) {\n  if (!regex.endsWith('\\n')){\n    regex += '\\n';\n  }\n\n  // remove non escaped comments\n  return regex.replace(/([^\\\\])#.*\\n/gmi, '$1')\n    // remove lines starting with a comment\n    .replace(/^#.*\\n/gmi, '')\n    // remove non escaped whitespace\n    .replace(/([^\\\\])\\s+/gmi, '$1')\n    // remove whitespace at the beginning of a line\n    .replace(/^\\s+/, '')\n    .trim();\n}\n\nfunction processRegexPattern(s) {\n  if (s && s.startsWith('^')){\n    // regex for startsWith\n    return '^' + literalizeRegexPart(s.slice(1));\n\n  } else if (s && s.endsWith('$')) {\n    // regex for endsWith\n    return literalizeRegexPart(s.slice(0, s.length - 1)) + '$';\n  }\n\n  // regex for contains\n  return literalizeRegexPart(s);\n}\n\nfunction isStartsWithRegex(value) {\n  if (!value || typeof value !== 'string' || !value.startsWith('^')) {\n    return false;\n  }\n\n  const matches = value.match(/\\^\\\\Q.*\\\\E/);\n  return !!matches;\n}\n\nfunction isAllValuesRegexOrNone(values) {\n  if (!values || !Array.isArray(values) || values.length === 0) {\n    return true;\n  }\n\n  const firstValuesIsRegex = isStartsWithRegex(values[0].$regex);\n  if (values.length === 1) {\n    return firstValuesIsRegex;\n  }\n\n  for (let i = 1, length = values.length; i < length; ++i) {\n    if (firstValuesIsRegex !== isStartsWithRegex(values[i].$regex)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction isAnyValueRegexStartsWith(values) {\n  return values.some(function (value) {\n    return isStartsWithRegex(value.$regex);\n  });\n}\n\nfunction createLiteralRegex(remaining) {\n  return remaining.split('').map(c => {\n    if (c.match(/[0-9a-zA-Z]/) !== null) {\n      // don't escape alphanumeric characters\n      return c;\n    }\n    // escape everything else (single quotes with single quotes, everything else with a backslash)\n    return c === `'` ? `''` : `\\\\${c}`;\n  }).join('');\n}\n\nfunction literalizeRegexPart(s: string) {\n  const matcher1 = /\\\\Q((?!\\\\E).*)\\\\E$/\n  const result1: any = s.match(matcher1);\n  if(result1 && result1.length > 1 && result1.index > -1) {\n    // process regex that has a beginning and an end specified for the literal text\n    const prefix = s.substr(0, result1.index);\n    const remaining = result1[1];\n\n    return literalizeRegexPart(prefix) + createLiteralRegex(remaining);\n  }\n\n  // process regex that has a beginning specified for the literal text\n  const matcher2 = /\\\\Q((?!\\\\E).*)$/\n  const result2: any = s.match(matcher2);\n  if(result2 && result2.length > 1 && result2.index > -1){\n    const prefix = s.substr(0, result2.index);\n    const remaining = result2[1];\n\n    return literalizeRegexPart(prefix) + createLiteralRegex(remaining);\n  }\n\n  // remove all instances of \\Q and \\E from the remaining text & escape single quotes\n  return (\n    s.replace(/([^\\\\])(\\\\E)/, '$1')\n      .replace(/([^\\\\])(\\\\Q)/, '$1')\n      .replace(/^\\\\E/, '')\n      .replace(/^\\\\Q/, '')\n      .replace(/([^'])'/, `$1''`)\n      .replace(/^'([^'])/, `''$1`)\n  );\n}\n\nvar GeoPointCoder = {\n  isValidJSON(value) {\n    return (typeof value === 'object' &&\n      value !== null &&\n      value.__type === 'GeoPoint'\n    );\n  }\n};\n\nexport default PostgresStorageAdapter;\n"]}